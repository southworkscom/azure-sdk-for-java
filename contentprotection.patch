From 8791c7b2adfb453e53aa41d154640d0ba825994d Mon Sep 17 00:00:00 2001
From: Emanuel Vecchio <vecchioemanuel@gmail.com>
Date: Mon, 20 Jul 2015 18:04:25 -0300
Subject: [PATCH 01/21] Added support for the following new entities:
 ContentKeyAuthorizationPolicy, ContentKeyAuthorizationPolicyOptions,
 ContentKeyAuthorizationPolicyRestrictions, and AssetDeliveryPolicy

---
 .../entityoperations/EntityUnlinkOperation.java    |  74 +++++++++
 .../media/implementation/ODataAtomMarshaller.java  |   8 +
 .../content/AssetDeliveryPolicyRestType.java       | 166 ++++++++++++++++++++
 .../ContentKeyAuthorizationPolicyOptionType.java   |  74 +++++++++
 ...ntentKeyAuthorizationPolicyRestrictionType.java |  49 ++++++
 .../content/ContentKeyAuthorizationPolicyType.java |  47 ++++++
 .../implementation/content/ObjectFactory.java      |  36 +++++
 .../services/media/models/AssetDeliveryPolicy.java | 171 +++++++++++++++++++++
 .../AssetDeliveryPolicyConfigurationKey.java       |  91 +++++++++++
 .../media/models/AssetDeliveryPolicyInfo.java      | 107 +++++++++++++
 .../media/models/AssetDeliveryPolicyType.java      |  82 ++++++++++
 .../media/models/AssetDeliveryProtocol.java        | 102 ++++++++++++
 .../models/ContentKeyAuthorizationPolicy.java      | 164 ++++++++++++++++++++
 .../models/ContentKeyAuthorizationPolicyInfo.java  |  67 ++++++++
 .../ContentKeyAuthorizationPolicyOption.java       | 152 ++++++++++++++++++
 .../ContentKeyAuthorizationPolicyOptionInfo.java   | 103 +++++++++++++
 .../ContentKeyAuthorizationPolicyRestriction.java  |  87 +++++++++++
 .../ContentKeyAuthorizationPolicyEntityTest.java   | 107 +++++++++++++
 .../ContentKeyAuthorizationPolicyInfoTest.java     |  53 +++++++
 ...tentKeyAuthorizationPolicyOptionEntityTest.java | 109 +++++++++++++
 ...ontentKeyAuthorizationPolicyOptionInfoTest.java | 110 +++++++++++++
 21 files changed, 1959 insertions(+)
 create mode 100644 media/src/main/java/com/microsoft/windowsazure/services/media/entityoperations/EntityUnlinkOperation.java
 create mode 100644 media/src/main/java/com/microsoft/windowsazure/services/media/implementation/content/AssetDeliveryPolicyRestType.java
 create mode 100644 media/src/main/java/com/microsoft/windowsazure/services/media/implementation/content/ContentKeyAuthorizationPolicyOptionType.java
 create mode 100644 media/src/main/java/com/microsoft/windowsazure/services/media/implementation/content/ContentKeyAuthorizationPolicyRestrictionType.java
 create mode 100644 media/src/main/java/com/microsoft/windowsazure/services/media/implementation/content/ContentKeyAuthorizationPolicyType.java
 create mode 100644 media/src/main/java/com/microsoft/windowsazure/services/media/models/AssetDeliveryPolicy.java
 create mode 100644 media/src/main/java/com/microsoft/windowsazure/services/media/models/AssetDeliveryPolicyConfigurationKey.java
 create mode 100644 media/src/main/java/com/microsoft/windowsazure/services/media/models/AssetDeliveryPolicyInfo.java
 create mode 100644 media/src/main/java/com/microsoft/windowsazure/services/media/models/AssetDeliveryPolicyType.java
 create mode 100644 media/src/main/java/com/microsoft/windowsazure/services/media/models/AssetDeliveryProtocol.java
 create mode 100644 media/src/main/java/com/microsoft/windowsazure/services/media/models/ContentKeyAuthorizationPolicy.java
 create mode 100644 media/src/main/java/com/microsoft/windowsazure/services/media/models/ContentKeyAuthorizationPolicyInfo.java
 create mode 100644 media/src/main/java/com/microsoft/windowsazure/services/media/models/ContentKeyAuthorizationPolicyOption.java
 create mode 100644 media/src/main/java/com/microsoft/windowsazure/services/media/models/ContentKeyAuthorizationPolicyOptionInfo.java
 create mode 100644 media/src/main/java/com/microsoft/windowsazure/services/media/models/ContentKeyAuthorizationPolicyRestriction.java
 create mode 100644 media/src/test/java/com/microsoft/windowsazure/services/media/contentprotection/ContentKeyAuthorizationPolicyEntityTest.java
 create mode 100644 media/src/test/java/com/microsoft/windowsazure/services/media/contentprotection/ContentKeyAuthorizationPolicyInfoTest.java
 create mode 100644 media/src/test/java/com/microsoft/windowsazure/services/media/contentprotection/ContentKeyAuthorizationPolicyOptionEntityTest.java
 create mode 100644 media/src/test/java/com/microsoft/windowsazure/services/media/contentprotection/ContentKeyAuthorizationPolicyOptionInfoTest.java

diff --git a/media/src/main/java/com/microsoft/windowsazure/services/media/entityoperations/EntityUnlinkOperation.java b/media/src/main/java/com/microsoft/windowsazure/services/media/entityoperations/EntityUnlinkOperation.java
new file mode 100644
index 0000000..5ed5695
--- /dev/null
+++ b/media/src/main/java/com/microsoft/windowsazure/services/media/entityoperations/EntityUnlinkOperation.java
@@ -0,0 +1,74 @@
+/**
+ * Copyright Microsoft Corporation
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.microsoft.windowsazure.services.media.entityoperations;
+
+import java.io.UnsupportedEncodingException;
+import java.net.URLEncoder;
+import java.security.InvalidParameterException;
+
+/**
+ * Generic implementation of $link operation of two entities.
+ */
+public class EntityUnlinkOperation extends DefaultDeleteOperation {
+
+    /** The primary entity set. */
+    private final String primaryEntitySet;
+
+    /** The primary entity id. */
+    private final String primaryEntityId;
+
+    /** The secondary entity set. */
+    private final String secondaryEntitySet;
+    
+    /** The secondary entity id. */
+    private final String secondaryEntityId;
+
+    /**
+     * Instantiates a new entity unlink operation.
+     * 
+     * @param primaryEntitySet
+     *            the primary entity set
+     * @param primaryEntityId
+     *            the primary entity id
+     * @param secondaryEntitySet
+     *            the secondary entity set
+     * @param secondaryEntityUri
+     *            the secondary entity id
+     */
+    public EntityUnlinkOperation(String primaryEntitySet, String primaryEntityId,
+            String secondaryEntitySet, String secondaryEntityId) {
+        super(primaryEntitySet, primaryEntityId);
+        this.primaryEntitySet = primaryEntitySet;
+        this.primaryEntityId = primaryEntityId;
+        this.secondaryEntitySet = secondaryEntitySet;
+        this.secondaryEntityId = secondaryEntityId;
+    }
+    
+    @Override
+    public String getUri() {
+        String escapedPrimaryEntityId;
+        String escapedSecondaryEntityId;
+        try {
+            escapedPrimaryEntityId = URLEncoder.encode(primaryEntityId, "UTF-8");
+            escapedSecondaryEntityId = URLEncoder.encode(secondaryEntityId, "UTF-8");
+        } catch (UnsupportedEncodingException e) {
+            throw new InvalidParameterException(
+                    "UTF-8 encoding is not supported.");
+        }
+        return String.format("%s('%s')/$links/%s('%s')", primaryEntitySet,
+                escapedPrimaryEntityId, secondaryEntitySet, escapedSecondaryEntityId);
+    }
+}
diff --git a/media/src/main/java/com/microsoft/windowsazure/services/media/implementation/ODataAtomMarshaller.java b/media/src/main/java/com/microsoft/windowsazure/services/media/implementation/ODataAtomMarshaller.java
index 9f6059b..1fbfdc6 100644
--- a/media/src/main/java/com/microsoft/windowsazure/services/media/implementation/ODataAtomMarshaller.java
+++ b/media/src/main/java/com/microsoft/windowsazure/services/media/implementation/ODataAtomMarshaller.java
@@ -34,10 +34,14 @@ import com.microsoft.windowsazure.services.media.implementation.atom.ContentType
 import com.microsoft.windowsazure.services.media.implementation.atom.EntryType;
 import com.microsoft.windowsazure.services.media.implementation.atom.FeedType;
 import com.microsoft.windowsazure.services.media.implementation.content.AccessPolicyType;
+import com.microsoft.windowsazure.services.media.implementation.content.AssetDeliveryPolicyRestType;
 import com.microsoft.windowsazure.services.media.implementation.content.AssetFileType;
 import com.microsoft.windowsazure.services.media.implementation.content.AssetType;
 import com.microsoft.windowsazure.services.media.implementation.content.ChannelType;
 import com.microsoft.windowsazure.services.media.implementation.content.Constants;
+import com.microsoft.windowsazure.services.media.implementation.content.ContentKeyAuthorizationPolicyOptionType;
+import com.microsoft.windowsazure.services.media.implementation.content.ContentKeyAuthorizationPolicyRestrictionType;
+import com.microsoft.windowsazure.services.media.implementation.content.ContentKeyAuthorizationPolicyType;
 import com.microsoft.windowsazure.services.media.implementation.content.ContentKeyRestType;
 import com.microsoft.windowsazure.services.media.implementation.content.JobNotificationSubscriptionType;
 import com.microsoft.windowsazure.services.media.implementation.content.JobType;
@@ -137,9 +141,13 @@ public class ODataAtomMarshaller {
     private static Class<?>[] getMarshalledClasses() {
         List<Class<?>> classes = new ArrayList<Class<?>>();
         classes.add(AccessPolicyType.class);
+        classes.add(AssetDeliveryPolicyRestType.class);
         classes.add(AssetType.class);
         classes.add(AssetFileType.class);
         classes.add(ChannelType.class);
+        classes.add(ContentKeyAuthorizationPolicyType.class);
+        classes.add(ContentKeyAuthorizationPolicyOptionType.class);
+        classes.add(ContentKeyAuthorizationPolicyRestrictionType.class);
         classes.add(ContentKeyRestType.class);
         classes.add(EntryType.class);
         classes.add(FeedType.class);
diff --git a/media/src/main/java/com/microsoft/windowsazure/services/media/implementation/content/AssetDeliveryPolicyRestType.java b/media/src/main/java/com/microsoft/windowsazure/services/media/implementation/content/AssetDeliveryPolicyRestType.java
new file mode 100644
index 0000000..bff9937
--- /dev/null
+++ b/media/src/main/java/com/microsoft/windowsazure/services/media/implementation/content/AssetDeliveryPolicyRestType.java
@@ -0,0 +1,166 @@
+/**
+ * Copyright Microsoft Corporation
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.microsoft.windowsazure.services.media.implementation.content;
+
+import java.util.Date;
+
+import javax.xml.bind.annotation.XmlAccessType;
+import javax.xml.bind.annotation.XmlAccessorType;
+import javax.xml.bind.annotation.XmlElement;
+
+/**
+ * This type maps the XML returned in the odata ATOM serialization for Asset
+ * entities.
+ * 
+ */
+@XmlAccessorType(XmlAccessType.FIELD)
+public class AssetDeliveryPolicyRestType implements MediaServiceDTO {
+
+    @XmlElement(name = "Id", namespace = Constants.ODATA_DATA_NS)
+    private String id;
+    
+    @XmlElement(name = "Created", namespace = Constants.ODATA_DATA_NS)
+    private Date created;
+
+    @XmlElement(name = "LastModified", namespace = Constants.ODATA_DATA_NS)
+    private Date lastModified;
+
+    @XmlElement(name = "Name", namespace = Constants.ODATA_DATA_NS)
+    private String name;
+
+    @XmlElement(name = "AssetDeliveryProtocol", namespace = Constants.ODATA_DATA_NS)
+    private Integer assetDeliveryProtocol;
+    
+    @XmlElement(name = "AssetDeliveryPolicyType", namespace = Constants.ODATA_DATA_NS)
+    private Integer assetDeliveryPolicyType;
+    
+    @XmlElement(name = "AssetDeliveryConfiguration", namespace = Constants.ODATA_DATA_NS)
+    private String assetDeliveryConfiguration;
+
+    /**
+     * @return the id
+     */
+    public String getId() {
+        return id;
+    }
+
+    /**
+     * @param id
+     *            the id to set
+     */
+    public AssetDeliveryPolicyRestType setId(String id) {
+        this.id = id;
+        return this;
+    }
+
+    /**
+     * @return the created
+     */
+    public Date getCreated() {
+        return created;
+    }
+
+    /**
+     * @param created
+     *            the created to set
+     */
+    public AssetDeliveryPolicyRestType setCreated(Date created) {
+        this.created = created;
+        return this;
+    }
+
+    /**
+     * @return the lastModified
+     */
+    public Date getLastModified() {
+        return lastModified;
+    }
+
+    /**
+     * @param lastModified
+     *            the lastModified to set
+     */
+    public AssetDeliveryPolicyRestType setLastModified(Date lastModified) {
+        this.lastModified = lastModified;
+        return this;
+    }
+
+    /**
+     * @return the alternateId
+     */
+    public Integer getAssetDeliveryProtocol() {
+        return assetDeliveryProtocol;
+    }
+
+    /**
+     * @param alternateId
+     *            the alternateId to set
+     */
+    public AssetDeliveryPolicyRestType setAssetDeliveryProtocol(Integer assetDeliveryProtocol) {
+        this.assetDeliveryProtocol = assetDeliveryProtocol;
+        return this;
+    }
+
+    /**
+     * @return the name
+     */
+    public String getName() {
+        return name;
+    }
+
+    /**
+     * @param name
+     *            the name to set
+     */
+    public AssetDeliveryPolicyRestType setName(String name) {
+        this.name = name;
+        return this;
+    }
+    
+    /**
+     * @return the asset delivery policy type
+     */
+    public Integer getAssetDeliveryPolicyType() {
+        return assetDeliveryPolicyType;
+    }
+
+    /**
+     * @param assetDeliveryPolicyType
+     *            the asset delivery policy type
+     */
+    public AssetDeliveryPolicyRestType setAssetDeliveryPolicyType(Integer assetDeliveryPolicyType) {
+        this.assetDeliveryPolicyType = assetDeliveryPolicyType;
+        return this;
+    }
+    
+    /**
+     * @return the asset delivery configuration
+     */
+    public String getAssetDeliveryConfiguration() {
+        return assetDeliveryConfiguration;
+    }
+
+    /**
+     * @param assetDeliveryConfiguration
+     *            the asset delivery configuration to set
+     */
+    public AssetDeliveryPolicyRestType setAssetDeliveryConfiguration(String assetDeliveryConfiguration) {
+        this.assetDeliveryConfiguration = assetDeliveryConfiguration;
+        return this;
+    }
+
+    
+}
diff --git a/media/src/main/java/com/microsoft/windowsazure/services/media/implementation/content/ContentKeyAuthorizationPolicyOptionType.java b/media/src/main/java/com/microsoft/windowsazure/services/media/implementation/content/ContentKeyAuthorizationPolicyOptionType.java
new file mode 100644
index 0000000..f2b8202
--- /dev/null
+++ b/media/src/main/java/com/microsoft/windowsazure/services/media/implementation/content/ContentKeyAuthorizationPolicyOptionType.java
@@ -0,0 +1,74 @@
+package com.microsoft.windowsazure.services.media.implementation.content;
+
+import java.util.List;
+
+import javax.xml.bind.annotation.XmlAccessType;
+import javax.xml.bind.annotation.XmlAccessorType;
+import javax.xml.bind.annotation.XmlElement;
+import javax.xml.bind.annotation.XmlElementWrapper;
+
+@XmlAccessorType(XmlAccessType.FIELD)
+public class ContentKeyAuthorizationPolicyOptionType implements MediaServiceDTO {
+
+    @XmlElement(name = "Id", namespace = Constants.ODATA_DATA_NS)
+    private String id;
+
+    @XmlElement(name = "Name", namespace = Constants.ODATA_DATA_NS)
+    private String name;
+
+    @XmlElement(name = "KeyDeliveryType", namespace = Constants.ODATA_DATA_NS)
+    private int keyDeliveryType;
+
+    @XmlElement(name = "KeyDeliveryConfiguration", namespace = Constants.ODATA_DATA_NS)
+    private String keyDeliveryConfiguration;
+
+    @XmlElementWrapper(name = "Restrictions", namespace = Constants.ODATA_DATA_NS)
+    @XmlElement(name = "element", namespace = Constants.ODATA_DATA_NS)
+    private List<ContentKeyAuthorizationPolicyRestrictionType> restrictions;
+
+    public String getId() {
+        return id;
+    }
+
+    public ContentKeyAuthorizationPolicyOptionType setId(String id) {
+        this.id = id;
+        return this;
+    }
+
+    public String getName() {
+        return name;
+    }
+
+    public ContentKeyAuthorizationPolicyOptionType setName(String name) {
+        this.name = name;
+        return this;
+    }
+
+    public int getKeyDeliveryType() {
+        return keyDeliveryType;
+    }
+
+    public ContentKeyAuthorizationPolicyOptionType setKeyDeliveryType(int keyDeliveryType) {
+        this.keyDeliveryType = keyDeliveryType;
+        return this;
+    }
+
+    public String getKeyDeliveryConfiguration() {
+        return keyDeliveryConfiguration;
+    }
+
+    public ContentKeyAuthorizationPolicyOptionType setKeyDeliveryConfiguration(String keyDeliveryConfiguration) {
+        this.keyDeliveryConfiguration = keyDeliveryConfiguration;
+        return this;
+    }
+
+    public List<ContentKeyAuthorizationPolicyRestrictionType> getRestrictions() {
+        return restrictions;
+    }
+
+    public ContentKeyAuthorizationPolicyOptionType setRestrictions(
+            List<ContentKeyAuthorizationPolicyRestrictionType> restrictions) {
+        this.restrictions = restrictions;
+        return this;
+    }
+}
diff --git a/media/src/main/java/com/microsoft/windowsazure/services/media/implementation/content/ContentKeyAuthorizationPolicyRestrictionType.java b/media/src/main/java/com/microsoft/windowsazure/services/media/implementation/content/ContentKeyAuthorizationPolicyRestrictionType.java
new file mode 100644
index 0000000..0276f17
--- /dev/null
+++ b/media/src/main/java/com/microsoft/windowsazure/services/media/implementation/content/ContentKeyAuthorizationPolicyRestrictionType.java
@@ -0,0 +1,49 @@
+package com.microsoft.windowsazure.services.media.implementation.content;
+
+import javax.xml.bind.annotation.XmlAccessType;
+import javax.xml.bind.annotation.XmlAccessorType;
+import javax.xml.bind.annotation.XmlElement;
+
+@XmlAccessorType(XmlAccessType.FIELD)
+public class ContentKeyAuthorizationPolicyRestrictionType implements MediaServiceDTO {
+
+    /** The name. */
+    @XmlElement(name = "Name", namespace = Constants.ODATA_DATA_NS)
+    private String name;
+
+    /** The KeyRestrictionType. */
+    @XmlElement(name = "KeyRestrictionType", namespace = Constants.ODATA_DATA_NS)
+    private int keyRestrictionType;
+
+    /** The KeyRestrictionType. */
+    @XmlElement(name = "Requirements", namespace = Constants.ODATA_DATA_NS)
+    private String requirements;
+
+    public String getName() {
+        return name;
+    }
+
+    public ContentKeyAuthorizationPolicyRestrictionType setName(String name) {
+        this.name = name;
+        return this;
+    }
+
+    public int getKeyRestrictionType() {
+        return keyRestrictionType;
+    }
+
+    public ContentKeyAuthorizationPolicyRestrictionType setKeyRestrictionType(int keyRestrictionType) {
+        this.keyRestrictionType = keyRestrictionType;
+        return this;
+    }
+
+    public String getRequirements() {
+        return requirements;
+    }
+
+    public ContentKeyAuthorizationPolicyRestrictionType setRequirements(String requirements) {
+        this.requirements = requirements;
+        return this;
+    }
+
+}
diff --git a/media/src/main/java/com/microsoft/windowsazure/services/media/implementation/content/ContentKeyAuthorizationPolicyType.java b/media/src/main/java/com/microsoft/windowsazure/services/media/implementation/content/ContentKeyAuthorizationPolicyType.java
new file mode 100644
index 0000000..15785f6
--- /dev/null
+++ b/media/src/main/java/com/microsoft/windowsazure/services/media/implementation/content/ContentKeyAuthorizationPolicyType.java
@@ -0,0 +1,47 @@
+package com.microsoft.windowsazure.services.media.implementation.content;
+
+import javax.xml.bind.annotation.XmlAccessType;
+import javax.xml.bind.annotation.XmlAccessorType;
+import javax.xml.bind.annotation.XmlElement;
+
+@XmlAccessorType(XmlAccessType.FIELD)
+public class ContentKeyAuthorizationPolicyType implements MediaServiceDTO {
+
+    @XmlElement(name = "Id", namespace = Constants.ODATA_DATA_NS)
+    private String id;
+
+    @XmlElement(name = "Name", namespace = Constants.ODATA_DATA_NS)
+    private String name;
+
+    /**
+     * @return the id
+     */
+    public String getId() {
+        return id;
+    }
+
+    /**
+     * @param id
+     *            the id to set
+     */
+    public ContentKeyAuthorizationPolicyType setId(String id) {
+        this.id = id;
+        return this;
+    }
+
+    /**
+     * @return the name
+     */
+    public String getName() {
+        return name;
+    }
+
+    /**
+     * @param name
+     *            the name to set
+     */
+    public ContentKeyAuthorizationPolicyType setName(String name) {
+        this.name = name;
+        return this;
+    }
+}
diff --git a/media/src/main/java/com/microsoft/windowsazure/services/media/implementation/content/ObjectFactory.java b/media/src/main/java/com/microsoft/windowsazure/services/media/implementation/content/ObjectFactory.java
index 1fda19a..8cfe7b5 100644
--- a/media/src/main/java/com/microsoft/windowsazure/services/media/implementation/content/ObjectFactory.java
+++ b/media/src/main/java/com/microsoft/windowsazure/services/media/implementation/content/ObjectFactory.java
@@ -176,4 +176,40 @@ public class ObjectFactory {
     public ProgramType createProgramType() {
         return new ProgramType();
     }
+    
+    /**
+     * Creates a instance of (@link @ContentKeyAuthorizationPolicyOptionType).
+     * 
+     * @return the content key authorization policy option type
+     */
+    public ContentKeyAuthorizationPolicyOptionType createContentKeyAuthorizationPolicyOptionType() {
+        return new ContentKeyAuthorizationPolicyOptionType();
+    }
+    
+    /**
+     * Creates a instance of (@link @ContentKeyAuthorizationPolicyRestrictionType).
+     * 
+     * @return the content key authorization policy restriction type
+     */
+    public ContentKeyAuthorizationPolicyRestrictionType createContentKeyAuthorizationPolicyRestrictionType() {
+        return new ContentKeyAuthorizationPolicyRestrictionType();
+    }
+    
+    /**
+     * Creates a instance of (@link @ContentKeyAuthorizationPolicyType).
+     * 
+     * @return the content key authorization policy type
+     */
+    public ContentKeyAuthorizationPolicyType createContentKeyAuthorizationPolicyType() {
+        return new ContentKeyAuthorizationPolicyType();
+    }
+    
+    /**
+     * Creates a instance of (@link @AssetDeliveryPolicyType).
+     * 
+     * @return the asset delivery policy type
+     */
+    public AssetDeliveryPolicyRestType createAssetDeliveryPolicyType() {
+        return new AssetDeliveryPolicyRestType();
+    }
 }
diff --git a/media/src/main/java/com/microsoft/windowsazure/services/media/models/AssetDeliveryPolicy.java b/media/src/main/java/com/microsoft/windowsazure/services/media/models/AssetDeliveryPolicy.java
new file mode 100644
index 0000000..9ed7125
--- /dev/null
+++ b/media/src/main/java/com/microsoft/windowsazure/services/media/models/AssetDeliveryPolicy.java
@@ -0,0 +1,171 @@
+/**
+ * Copyright Microsoft Corporation
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.microsoft.windowsazure.services.media.models;
+
+import java.util.EnumSet;
+
+import com.microsoft.windowsazure.services.media.entityoperations.DefaultDeleteOperation;
+import com.microsoft.windowsazure.services.media.entityoperations.DefaultGetOperation;
+import com.microsoft.windowsazure.services.media.entityoperations.DefaultListOperation;
+import com.microsoft.windowsazure.services.media.entityoperations.EntityCreateOperation;
+import com.microsoft.windowsazure.services.media.entityoperations.EntityDeleteOperation;
+import com.microsoft.windowsazure.services.media.entityoperations.EntityGetOperation;
+import com.microsoft.windowsazure.services.media.entityoperations.EntityOperationSingleResultBase;
+import com.microsoft.windowsazure.services.media.implementation.content.AssetDeliveryPolicyRestType;
+import com.sun.jersey.api.client.GenericType;
+
+/**
+ * Class for creating operations to manipulate Asset Delivery Policy entities.
+ * 
+ */
+public final class AssetDeliveryPolicy {
+
+    private static final String ENTITY_SET = "AssetDeliveryPolicies";
+
+    private AssetDeliveryPolicy() {
+    }
+
+    /**
+     * Creates an operation to create a new AssetDeliveryPolicy
+     * 
+     * @param name
+     *            name of the asset delivery policy
+     * @return The operation
+     */
+    public static Creator create() {
+        return new Creator();
+    }
+
+    public static class Creator extends EntityOperationSingleResultBase<AssetDeliveryPolicyInfo>
+            implements EntityCreateOperation<AssetDeliveryPolicyInfo> {
+
+        private String name;
+        private EnumSet<AssetDeliveryProtocol> assetDeliveryProtocol;
+        private AssetDeliveryPolicyType assetDeliveryPolicyType;
+        private String assetDeliveryConfiguration;
+
+        public Creator() {
+            super(ENTITY_SET, AssetDeliveryPolicyInfo.class);
+        }
+
+        @Override
+        public Object getRequestContents() {
+            return new AssetDeliveryPolicyRestType().setName(name)
+                    .setAssetDeliveryConfiguration(assetDeliveryConfiguration)
+                    .setAssetDeliveryPolicyType(assetDeliveryPolicyType.getCode())
+                    .setAssetDeliveryProtocol(AssetDeliveryProtocol.bitsFromProtocols(assetDeliveryProtocol));
+        }
+
+        /**
+         * Set the name of the Asset Delivery Policy to be created.
+         * 
+         * @param name
+         *            The name
+         * @return The creator object (for call chaining)
+         */
+        public Creator setName(String name) {
+            this.name = name;
+            return this;
+        }
+
+        /**
+         * Set the protocol of the Asset Delivery Policy to be created.
+         * 
+         * @param assetDeliveryProtocol
+         *            The protocol
+         * @return The creator object (for call chaining)
+         */
+        public Creator setAssetDeliveryProtocol(EnumSet<AssetDeliveryProtocol> assetDeliveryProtocol) {
+            this.assetDeliveryProtocol = assetDeliveryProtocol;
+            return this;
+        }
+
+        /**
+         * Set the type of the Asset Delivery Policy to be created.
+         * 
+         * @param assetDeliveryPolicyType
+         *            The type
+         * @return The creator object (for call chaining)
+         */
+        public Creator setAssetDeliveryPolicyType(AssetDeliveryPolicyType assetDeliveryPolicyType) {
+            this.assetDeliveryPolicyType = assetDeliveryPolicyType;
+            return this;
+        }
+
+        /**
+         * Set the configuration of the Asset Delivery Policy to be created.
+         * 
+         * @param assetDeliveryConfiguration
+         *            The configuration
+         * @return The creator object (for call chaining)
+         */
+        public Creator setAssetDeliveryConfiguration(String assetDeliveryConfiguration) {
+            this.assetDeliveryConfiguration = assetDeliveryConfiguration;
+            return this;
+        }
+
+    }
+
+    /**
+     * Create an operation that will retrieve the given asset delivery policy
+     * 
+     * @param assetDeliveryPolicyId
+     *            id of asset delivery policy to retrieve
+     * @return the operation
+     */
+    public static EntityGetOperation<AssetDeliveryPolicyInfo> get(String assetDeliveryPolicyId) {
+        return new DefaultGetOperation<AssetDeliveryPolicyInfo>(ENTITY_SET, assetDeliveryPolicyId,
+                AssetDeliveryPolicyInfo.class);
+    }
+
+    /**
+     * Create an operation that will retrieve all asset delivery policies
+     * 
+     * @return the operation
+     */
+    public static DefaultListOperation<AssetDeliveryPolicyInfo> list() {
+        return new DefaultListOperation<AssetDeliveryPolicyInfo>(ENTITY_SET,
+                new GenericType<ListResult<AssetDeliveryPolicyInfo>>() {
+                });
+    }
+
+    /**
+     * Create an operation that will list all the asset delivery policies at the
+     * given link.
+     * 
+     * @param link
+     *            Link to request all the asset delivery policies.
+     * 
+     * @return The list operation.
+     */
+    public static DefaultListOperation<AssetDeliveryPolicyInfo> list(LinkInfo<AssetDeliveryPolicyInfo> link) {
+        return new DefaultListOperation<AssetDeliveryPolicyInfo>(link.getHref(),
+                new GenericType<ListResult<AssetDeliveryPolicyInfo>>() {
+                });
+    }
+
+    /**
+     * Create an operation to delete the given asset delivery policy
+     * 
+     * @param contentKeyAuthorizationPolicyId
+     *            id of content key authorization policy to delete
+     * @return the delete operation
+     */
+
+    public static EntityDeleteOperation delete(String assetDeliveryPolicyId) {
+        return new DefaultDeleteOperation(ENTITY_SET, assetDeliveryPolicyId);
+    }
+}
diff --git a/media/src/main/java/com/microsoft/windowsazure/services/media/models/AssetDeliveryPolicyConfigurationKey.java b/media/src/main/java/com/microsoft/windowsazure/services/media/models/AssetDeliveryPolicyConfigurationKey.java
new file mode 100644
index 0000000..0637d5c
--- /dev/null
+++ b/media/src/main/java/com/microsoft/windowsazure/services/media/models/AssetDeliveryPolicyConfigurationKey.java
@@ -0,0 +1,91 @@
+/*
+ * Copyright Microsoft Corporation
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.microsoft.windowsazure.services.media.models;
+
+import java.security.InvalidParameterException;
+
+/**
+ * Specifies the AssetDeliveryPolicyType.
+ */
+public enum AssetDeliveryPolicyConfigurationKey {
+
+    /** No policies. */
+    None(0),
+    /** Exact Envelope key URL. */
+    EnvelopeKeyAcquisitionUrl(1),
+    /** Base key url that will have KID=<Guid> appended for Envelope. */
+    EnvelopeBaseKeyAcquisitionUrl(2),
+    /** The initialization vector to use for envelope encryption in Base64 format. */
+    EnvelopeEncryptionIVAsBase64(3),
+    /** The PlayReady License Acquisition Url to use for common encryption. */
+    PlayReadyLicenseAcquisitionUrl(4),
+    /** The PlayReady Custom Attributes to add to the PlayReady Content Header. */
+    PlayReadyCustomAttributes(5),
+    /** The initialization vector to use for envelope encryption. */
+    EnvelopeEncryptionIV(6);
+    
+    
+
+    /** The AssetDeliveryPolicyType code. */
+    private int assetDeliveryPolicyConfigurationKey;
+
+    /**
+     * Instantiates a new AssetDeliveryPolicyConfigurationKey.
+     * 
+     * @param assetDeliveryPolicyConfigurationKey
+     *            the AssetDeliveryPolicyConfigurationKey code
+     */
+    private AssetDeliveryPolicyConfigurationKey(int assetDeliveryPolicyConfigurationKey) {
+        this.assetDeliveryPolicyConfigurationKey = assetDeliveryPolicyConfigurationKey;
+    }
+
+    /**
+     * Gets the code.
+     * 
+     * @return the code
+     */
+    public int getCode() {
+        return assetDeliveryPolicyConfigurationKey;
+    }
+
+    /**
+     * Create an AssetDeliveryPolicyConfigurationKey instance based on the given integer.
+     * 
+     * @param option
+     *            the integer value of option
+     * @return The AssetDeliveryPolicyType
+     */
+    public static AssetDeliveryPolicyConfigurationKey fromCode(int option) {
+        switch (option) {
+        case 0:
+            return AssetDeliveryPolicyConfigurationKey.None;
+        case 1:
+            return AssetDeliveryPolicyConfigurationKey.EnvelopeKeyAcquisitionUrl;
+        case 2:
+            return AssetDeliveryPolicyConfigurationKey.EnvelopeBaseKeyAcquisitionUrl;
+        case 3:
+            return AssetDeliveryPolicyConfigurationKey.EnvelopeEncryptionIVAsBase64;
+        case 4:
+            return AssetDeliveryPolicyConfigurationKey.PlayReadyLicenseAcquisitionUrl;
+        case 5:
+            return AssetDeliveryPolicyConfigurationKey.PlayReadyCustomAttributes;
+        case 6:
+            return AssetDeliveryPolicyConfigurationKey.EnvelopeEncryptionIV;
+        default:
+            throw new InvalidParameterException("option");
+        }
+    }
+}
diff --git a/media/src/main/java/com/microsoft/windowsazure/services/media/models/AssetDeliveryPolicyInfo.java b/media/src/main/java/com/microsoft/windowsazure/services/media/models/AssetDeliveryPolicyInfo.java
new file mode 100644
index 0000000..a8f3cf3
--- /dev/null
+++ b/media/src/main/java/com/microsoft/windowsazure/services/media/models/AssetDeliveryPolicyInfo.java
@@ -0,0 +1,107 @@
+/**
+ * Copyright Microsoft Corporation
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.microsoft.windowsazure.services.media.models;
+
+import java.util.Date;
+import java.util.EnumSet;
+
+import com.microsoft.windowsazure.services.media.implementation.ODataEntity;
+import com.microsoft.windowsazure.services.media.implementation.atom.EntryType;
+import com.microsoft.windowsazure.services.media.implementation.content.AssetDeliveryPolicyRestType;
+
+/**
+ * Type containing data about asset delivery policy.
+ * 
+ */
+public class AssetDeliveryPolicyInfo extends ODataEntity<AssetDeliveryPolicyRestType> {
+
+    /**
+     * Creates a new {@link AssetDeliveryPolicyInfo} wrapping the given ATOM
+     * entry and content objects.
+     * 
+     * @param entry
+     *            the entry
+     * @param content
+     *            the content
+     */
+    public AssetDeliveryPolicyInfo(EntryType entry, AssetDeliveryPolicyRestType content) {
+        super(entry, content);
+    }
+
+    /**
+     * Get the asset delivery policy id.
+     * 
+     * @return the id.
+     */
+    public String getId() {
+        return getContent().getId();
+    }
+
+    /**
+     * Get the asset delivery policy name.
+     * 
+     * @return the name.
+     */
+    public String getName() {
+        return getContent().getName();
+    }
+
+    /**
+     * Get the asset delivery policy type.
+     * 
+     * @return the type.
+     */
+    public AssetDeliveryPolicyType getAssetDeliveryPolicyType() {
+        return AssetDeliveryPolicyType.fromCode(getContent().getAssetDeliveryPolicyType());
+    }
+
+    /**
+     * Get the asset delivery policy protocol.
+     * 
+     * @return the protocol.
+     */
+    public EnumSet<AssetDeliveryProtocol> getAssetDeliveryProtocol() {
+        return AssetDeliveryProtocol.protocolsFromBits(getContent().getAssetDeliveryProtocol());
+    }
+
+    /**
+     * Get the asset delivery policy configuration.
+     * 
+     * @return the configuration.
+     */
+    public String getAssetDeliveryConfiguration() {
+        return getContent().getAssetDeliveryConfiguration();
+    }
+
+    /**
+     * Get the asset delivery policy creation date.
+     * 
+     * @return the creation date.
+     */
+    public Date getCreated() {
+        return getContent().getCreated();
+    }
+
+    /**
+     * Get last date where any asset delivery policy's property was changed.
+     * 
+     * @return the last date where any property was changed.
+     */
+    public Date getLastModified() {
+        return getContent().getLastModified();
+    }
+
+}
diff --git a/media/src/main/java/com/microsoft/windowsazure/services/media/models/AssetDeliveryPolicyType.java b/media/src/main/java/com/microsoft/windowsazure/services/media/models/AssetDeliveryPolicyType.java
new file mode 100644
index 0000000..1963078
--- /dev/null
+++ b/media/src/main/java/com/microsoft/windowsazure/services/media/models/AssetDeliveryPolicyType.java
@@ -0,0 +1,82 @@
+/*
+ * Copyright Microsoft Corporation
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.microsoft.windowsazure.services.media.models;
+
+import java.security.InvalidParameterException;
+
+/**
+ * Specifies the AssetDeliveryPolicyType.
+ */
+public enum AssetDeliveryPolicyType {
+
+    /** Delivery Policy Type not set.  An invalid value. */
+    None(0),
+    /** The Asset should not be delivered via this AssetDeliveryProtocol. */
+    Blocked(1),
+    /** Do not apply dynamic encryption to the asset. */
+    NoDynamicEncryption(2),
+    /** Apply Dynamic Envelope encryption. */
+    DynamicEnvelopeEncryption(3),
+    /** Apply Dynamic Common encryption. */
+    DynamicCommonEncryption(4);
+    
+
+    /** The AssetDeliveryPolicyType code. */
+    private int assetDeliveryPolicyTypeCode;
+
+    /**
+     * Instantiates a new AssetDeliveryPolicyType.
+     * 
+     * @param assetDeliveryPolicyTypeCode
+     *            the AssetDeliveryPolicyType code
+     */
+    private AssetDeliveryPolicyType(int assetDeliveryPolicyTypeCode) {
+        this.assetDeliveryPolicyTypeCode = assetDeliveryPolicyTypeCode;
+    }
+
+    /**
+     * Gets the code.
+     * 
+     * @return the code
+     */
+    public int getCode() {
+        return assetDeliveryPolicyTypeCode;
+    }
+
+    /**
+     * Create an AssetDeliveryPolicyType instance based on the given integer.
+     * 
+     * @param option
+     *            the integer value of option
+     * @return The AssetDeliveryPolicyType
+     */
+    public static AssetDeliveryPolicyType fromCode(int option) {
+        switch (option) {
+        case 0:
+            return AssetDeliveryPolicyType.None;
+        case 1:
+            return AssetDeliveryPolicyType.Blocked;
+        case 2:
+            return AssetDeliveryPolicyType.NoDynamicEncryption;
+        case 3:
+            return AssetDeliveryPolicyType.DynamicEnvelopeEncryption;
+        case 4:
+            return AssetDeliveryPolicyType.DynamicCommonEncryption;
+        default:
+            throw new InvalidParameterException("option");
+        }
+    }
+}
diff --git a/media/src/main/java/com/microsoft/windowsazure/services/media/models/AssetDeliveryProtocol.java b/media/src/main/java/com/microsoft/windowsazure/services/media/models/AssetDeliveryProtocol.java
new file mode 100644
index 0000000..39b2066
--- /dev/null
+++ b/media/src/main/java/com/microsoft/windowsazure/services/media/models/AssetDeliveryProtocol.java
@@ -0,0 +1,102 @@
+/*
+ * Copyright Microsoft Corporation
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.microsoft.windowsazure.services.media.models;
+
+import java.util.EnumSet;
+
+/**
+ * 
+ * Specifies the protocol of an AssetDeliveryPolicy.
+ * 
+ */
+public enum AssetDeliveryProtocol {
+
+    /** No protocols. */
+    None(0),
+    /** Smooth streaming protocol. */
+    SmoothStreaming (1),
+    /** MPEG Dynamic Adaptive Streaming over HTTP (DASH). */
+    Dash(2),
+    /** Apple HTTP Live Streaming protocol. */
+    HLS(4),
+    /** Adobe HTTP Dynamic Streaming (HDS). */
+    Hds(8),
+    /** Include all protocols */
+    All(0xFFFF);
+
+    /** The content key type code. */
+    private int falgValue;
+
+    /**
+     * Instantiates a new content key type.
+     * 
+     * @param contentKeyTypeCode
+     *            the content key type code
+     */
+    private AssetDeliveryProtocol(int falgValue) {
+        this.falgValue = falgValue;
+    }
+
+    /**
+     * Gets the flags value.
+     * 
+     * @return the flags value
+     */
+    public int getFlagValue() {
+        return falgValue;
+    }
+
+    /**
+     * Given an integer representing the protocols as a bit vector, convert it
+     * into an <code>EnumSet&lt;AssetDeliveryProtocol&gt;</code> object
+     * containing the correct protocols *
+     * 
+     * @param bits
+     *            The bit vector of protocols
+     * @return The set of protocols in an <code>EnumSet</code> object.
+     */
+    public static EnumSet<AssetDeliveryProtocol> protocolsFromBits(int bits) {
+        EnumSet<AssetDeliveryProtocol> perms = EnumSet
+                .of(AssetDeliveryProtocol.None);
+
+        for (AssetDeliveryProtocol p : AssetDeliveryProtocol.values()) {
+            if ((bits & p.getFlagValue()) != 0) {
+                perms.remove(AssetDeliveryProtocol.None);
+                perms.add(p);
+            }
+        }
+
+        return perms;
+    }
+
+    /**
+     * Convert an <code>EnumSet</code> containing protocols into the
+     * corresponding integer bit vector to be passed to Media services.
+     * 
+     * @param perms
+     *            The protocols
+     * @return The bit vector to go out over the wire.
+     */
+    public static int bitsFromProtocols(EnumSet<AssetDeliveryProtocol> protos) {
+        int result = 0;
+        
+        for (AssetDeliveryProtocol p : protos) {
+            result |= p.getFlagValue();
+        }
+        
+        return result;
+    }
+}
diff --git a/media/src/main/java/com/microsoft/windowsazure/services/media/models/ContentKeyAuthorizationPolicy.java b/media/src/main/java/com/microsoft/windowsazure/services/media/models/ContentKeyAuthorizationPolicy.java
new file mode 100644
index 0000000..608b03d
--- /dev/null
+++ b/media/src/main/java/com/microsoft/windowsazure/services/media/models/ContentKeyAuthorizationPolicy.java
@@ -0,0 +1,164 @@
+/**
+ * Copyright Microsoft Corporation
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.microsoft.windowsazure.services.media.models;
+
+import java.io.UnsupportedEncodingException;
+import java.net.URI;
+import java.net.URLEncoder;
+import java.security.InvalidParameterException;
+
+import com.microsoft.windowsazure.services.media.entityoperations.DefaultDeleteOperation;
+import com.microsoft.windowsazure.services.media.entityoperations.DefaultGetOperation;
+import com.microsoft.windowsazure.services.media.entityoperations.DefaultListOperation;
+import com.microsoft.windowsazure.services.media.entityoperations.EntityCreateOperation;
+import com.microsoft.windowsazure.services.media.entityoperations.EntityDeleteOperation;
+import com.microsoft.windowsazure.services.media.entityoperations.EntityGetOperation;
+import com.microsoft.windowsazure.services.media.entityoperations.EntityLinkOperation;
+import com.microsoft.windowsazure.services.media.entityoperations.EntityOperationSingleResultBase;
+import com.microsoft.windowsazure.services.media.entityoperations.EntityUnlinkOperation;
+import com.microsoft.windowsazure.services.media.implementation.content.ContentKeyAuthorizationPolicyType;
+import com.sun.jersey.api.client.GenericType;
+
+/**
+ * Class for creating operations to manipulate Content Key Authorization Policy
+ * entities.
+ * 
+ */
+public final class ContentKeyAuthorizationPolicy {
+
+    private static final String ENTITY_SET = "ContentKeyAuthorizationPolicies";
+
+    private ContentKeyAuthorizationPolicy() {
+    }
+
+    /**
+     * Creates an operation to create a new ContentKeyAuthorizationPolicy
+     * 
+     * @param name
+     *            name of the content key authorization policy
+     * @return The operation
+     */
+    public static EntityCreateOperation<ContentKeyAuthorizationPolicyInfo> create(String name) {
+        return new Creator(name);
+    }
+
+    private static class Creator extends EntityOperationSingleResultBase<ContentKeyAuthorizationPolicyInfo>
+            implements EntityCreateOperation<ContentKeyAuthorizationPolicyInfo> {
+
+        private String name;
+
+        public Creator(String name) {
+
+            super(ENTITY_SET, ContentKeyAuthorizationPolicyInfo.class);
+
+            this.name = name;
+        }
+
+        @Override
+        public Object getRequestContents() {
+            return new ContentKeyAuthorizationPolicyType().setName(name);
+        }
+
+    }
+
+    /**
+     * Create an operation that will retrieve the given content key
+     * authorization policy
+     * 
+     * @param contentKeyAuthorizationPolicyId
+     *            id of content key authorization policy to retrieve
+     * @return the operation
+     */
+    public static EntityGetOperation<ContentKeyAuthorizationPolicyInfo> get(String contentKeyAuthorizationPolicyId) {
+        return new DefaultGetOperation<ContentKeyAuthorizationPolicyInfo>(ENTITY_SET, contentKeyAuthorizationPolicyId,
+                ContentKeyAuthorizationPolicyInfo.class);
+    }
+
+    /**
+     * Create an operation that will retrieve the content key authorization
+     * policy at the given link
+     * 
+     * @param link
+     *            the link
+     * @return the operation
+     */
+    public static EntityGetOperation<ContentKeyAuthorizationPolicyInfo> get(
+            LinkInfo<ContentKeyAuthorizationPolicyInfo> link) {
+        return new DefaultGetOperation<ContentKeyAuthorizationPolicyInfo>(link.getHref(),
+                ContentKeyAuthorizationPolicyInfo.class);
+    }
+
+    /**
+     * Create an operation that will retrieve all content key authorization
+     * polices
+     * 
+     * @return the operation
+     */
+
+    public static DefaultListOperation<ContentKeyAuthorizationPolicyInfo> list() {
+        return new DefaultListOperation<ContentKeyAuthorizationPolicyInfo>(ENTITY_SET,
+                new GenericType<ListResult<ContentKeyAuthorizationPolicyInfo>>() {
+                });
+    }
+
+    /**
+     * Create an operation to delete the given content key authorization policy
+     * 
+     * @param contentKeyAuthorizationPolicyId
+     *            id of content key authorization policy to delete
+     * @return the delete operation
+     */
+
+    public static EntityDeleteOperation delete(String contentKeyAuthorizationPolicyId) {
+        return new DefaultDeleteOperation(ENTITY_SET, contentKeyAuthorizationPolicyId);
+    }
+
+    /**
+     * Link a content key authorization policy options.
+     * 
+     * @param contentKeyAuthorizationPolicyId
+     *            the content key authorization policy id
+     * @param contentKeyAuthorizationPolicyOptionId
+     *            the content key authorization policy option id
+     * @return the entity action operation
+     */
+    public static EntityLinkOperation linkOptions(String contentKeyAuthorizationPolicyId,
+            String contentKeyAuthorizationPolicyOptionId) {
+        String escapedContentKeyId = null;
+        try {
+            escapedContentKeyId = URLEncoder.encode(contentKeyAuthorizationPolicyOptionId, "UTF-8");
+        } catch (UnsupportedEncodingException e) {
+            throw new InvalidParameterException("contentKeyId");
+        }
+        URI contentKeyUri = URI
+                .create(String.format("ContentKeyAuthorizationPolicyOptions('%s')", escapedContentKeyId));
+        return new EntityLinkOperation(ENTITY_SET, contentKeyAuthorizationPolicyId, "Options", contentKeyUri);
+    }
+    
+    /**
+     * Unlink content key authorization policy options.
+     * 
+     * @param assetId
+     *            the asset id
+     * @param adpId
+     *            the Asset Delivery Policy id
+     * @return the entity action operation
+     */
+    public static EntityUnlinkOperation unlinkOptions(String contentKeyAuthorizationPolicyId,
+            String contentKeyAuthorizationPolicyOptionId) {
+        return new EntityUnlinkOperation(ENTITY_SET, contentKeyAuthorizationPolicyId, "Options", contentKeyAuthorizationPolicyOptionId);
+    }
+}
diff --git a/media/src/main/java/com/microsoft/windowsazure/services/media/models/ContentKeyAuthorizationPolicyInfo.java b/media/src/main/java/com/microsoft/windowsazure/services/media/models/ContentKeyAuthorizationPolicyInfo.java
new file mode 100644
index 0000000..7cdcff5
--- /dev/null
+++ b/media/src/main/java/com/microsoft/windowsazure/services/media/models/ContentKeyAuthorizationPolicyInfo.java
@@ -0,0 +1,67 @@
+/**
+ * Copyright Microsoft Corporation
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.microsoft.windowsazure.services.media.models;
+
+import com.microsoft.windowsazure.services.media.implementation.ODataEntity;
+import com.microsoft.windowsazure.services.media.implementation.atom.EntryType;
+import com.microsoft.windowsazure.services.media.implementation.content.ContentKeyAuthorizationPolicyType;
+
+/**
+ * Type containing data about content key authorization policy options.
+ * 
+ */
+public class ContentKeyAuthorizationPolicyInfo extends ODataEntity<ContentKeyAuthorizationPolicyType> {
+
+    /**
+     * Creates a new {@link ContentKeyAuthorizationPolicyInfo} wrapping the
+     * given ATOM entry and content objects.
+     * 
+     * @param entry
+     *            the entry
+     * @param content
+     *            the content
+     */
+    public ContentKeyAuthorizationPolicyInfo(EntryType entry, ContentKeyAuthorizationPolicyType content) {
+        super(entry, content);
+    }
+
+    /**
+     * Get the content key authorization policy id.
+     * 
+     * @return the id.
+     */
+    public String getId() {
+        return getContent().getId();
+    }
+
+    /**
+     * Get the content key authorization policy name.
+     * 
+     * @return the name.
+     */
+    public String getName() {
+        return getContent().getName();
+    }
+
+    /**
+     * Get a link to the content key authorization policy's options
+     * 
+     * @return the link to the content key authorization policy's options
+     */
+    public LinkInfo<ContentKeyAuthorizationPolicyOptionInfo> getOptions() {
+        return this.<ContentKeyAuthorizationPolicyOptionInfo> getRelationLink("Options");
+    }
+}
diff --git a/media/src/main/java/com/microsoft/windowsazure/services/media/models/ContentKeyAuthorizationPolicyOption.java b/media/src/main/java/com/microsoft/windowsazure/services/media/models/ContentKeyAuthorizationPolicyOption.java
new file mode 100644
index 0000000..bbea207
--- /dev/null
+++ b/media/src/main/java/com/microsoft/windowsazure/services/media/models/ContentKeyAuthorizationPolicyOption.java
@@ -0,0 +1,152 @@
+/**
+ * Copyright Microsoft Corporation
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.microsoft.windowsazure.services.media.models;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import com.microsoft.windowsazure.services.media.entityoperations.DefaultDeleteOperation;
+import com.microsoft.windowsazure.services.media.entityoperations.DefaultGetOperation;
+import com.microsoft.windowsazure.services.media.entityoperations.DefaultListOperation;
+import com.microsoft.windowsazure.services.media.entityoperations.EntityCreateOperation;
+import com.microsoft.windowsazure.services.media.entityoperations.EntityDeleteOperation;
+import com.microsoft.windowsazure.services.media.entityoperations.EntityGetOperation;
+import com.microsoft.windowsazure.services.media.entityoperations.EntityOperationSingleResultBase;
+import com.microsoft.windowsazure.services.media.implementation.content.ContentKeyAuthorizationPolicyOptionType;
+import com.microsoft.windowsazure.services.media.implementation.content.ContentKeyAuthorizationPolicyRestrictionType;
+import com.sun.jersey.api.client.GenericType;
+
+/**
+ * Class for creating operations to manipulate Access Policy entities.
+ * 
+ */
+public final class ContentKeyAuthorizationPolicyOption {
+
+    private static final String ENTITY_SET = "ContentKeyAuthorizationPolicyOptions";
+
+    private ContentKeyAuthorizationPolicyOption() {
+    }
+
+    /**
+     * Creates an operation to create a new content key authorization options
+     * 
+     * @param name
+     *            Friendly name of the authorization policy
+     * @param keyDeliveryType
+     *            Delivery method of the content key to the client
+     * @param keyDeliveryConfiguration
+     *            Xml data, specific to the key delivery type that defines how
+     *            the key is delivered to the client
+     * @param restrictions
+     *            Requirements defined in each restriction must be met in order
+     *            to deliver the key using the key delivery data
+     * @return The operation
+     */
+    public static EntityCreateOperation<ContentKeyAuthorizationPolicyOptionInfo> create(String name,
+            int keyDeliveryType, String keyDeliveryConfiguration,
+            List<ContentKeyAuthorizationPolicyRestriction> restrictions) {
+        return new Creator(name, keyDeliveryType, keyDeliveryConfiguration, restrictions);
+    }
+
+    private static class Creator extends EntityOperationSingleResultBase<ContentKeyAuthorizationPolicyOptionInfo>
+            implements EntityCreateOperation<ContentKeyAuthorizationPolicyOptionInfo> {
+
+        private String name;
+        private int keyDeliveryType;
+        private String keyDeliveryConfiguration;
+        private List<ContentKeyAuthorizationPolicyRestrictionType> restrictions;
+
+        public Creator(String name, int keyDeliveryType, String keyDeliveryConfiguration,
+                List<ContentKeyAuthorizationPolicyRestriction> restrictions) {
+
+            super(ENTITY_SET, ContentKeyAuthorizationPolicyOptionInfo.class);
+
+            this.name = name;
+            this.keyDeliveryType = keyDeliveryType;
+            this.keyDeliveryConfiguration = keyDeliveryConfiguration;
+            this.restrictions = new ArrayList<ContentKeyAuthorizationPolicyRestrictionType>();
+            for (ContentKeyAuthorizationPolicyRestriction restriction : restrictions) {
+                this.restrictions.add(new ContentKeyAuthorizationPolicyRestrictionType().setName(restriction.getName())
+                        .setKeyRestrictionType(restriction.getKeyRestrictionType())
+                        .setRequirements(restriction.getRequirements()));
+            }
+        }
+
+        @Override
+        public Object getRequestContents() {
+            return new ContentKeyAuthorizationPolicyOptionType().setName(name).setKeyDeliveryType(keyDeliveryType)
+                    .setKeyDeliveryConfiguration(keyDeliveryConfiguration).setRestrictions(restrictions);
+        }
+    }
+
+    /**
+     * 
+     * 
+     * Create an operation that will retrieve the given content key
+     * authorization policy option
+     * 
+     * @param contentKeyAuthorizationPolicyOptionId
+     *            id of content key authorization policy option to retrieve
+     * @return the operation
+     */
+    public static EntityGetOperation<ContentKeyAuthorizationPolicyOptionInfo> get(
+            String contentKeyAuthorizationPolicyOptionId) {
+        return new DefaultGetOperation<ContentKeyAuthorizationPolicyOptionInfo>(ENTITY_SET,
+                contentKeyAuthorizationPolicyOptionId, ContentKeyAuthorizationPolicyOptionInfo.class);
+    }
+
+    /**
+     * Create an operation that will list all the content keys authorization
+     * policy options at the given link.
+     * 
+     * @param link
+     *            Link to request content keys authorization policy options
+     *            from.
+     * @return The list operation.
+     */
+    public static DefaultListOperation<ContentKeyAuthorizationPolicyOptionInfo> list(
+            LinkInfo<ContentKeyAuthorizationPolicyOptionInfo> link) {
+        return new DefaultListOperation<ContentKeyAuthorizationPolicyOptionInfo>(link.getHref(),
+                new GenericType<ListResult<ContentKeyAuthorizationPolicyOptionInfo>>() {
+                });
+    }
+
+    /**
+     * Create an operation that will retrieve all content key authorization
+     * policy options
+     * 
+     * @return the operation
+     */
+
+    public static DefaultListOperation<ContentKeyAuthorizationPolicyOptionInfo> list() {
+        return new DefaultListOperation<ContentKeyAuthorizationPolicyOptionInfo>(ENTITY_SET,
+                new GenericType<ListResult<ContentKeyAuthorizationPolicyOptionInfo>>() {
+                });
+    }
+
+    /**
+     * Create an operation to delete the given content key authorization policy
+     * option
+     * 
+     * @param contentKeyAuthorizationPolicyOptionId
+     *            id of content key authorization policy option to delete
+     * @return the delete operation
+     */
+
+    public static EntityDeleteOperation delete(String contentKeyAuthorizationPolicyOptionId) {
+        return new DefaultDeleteOperation(ENTITY_SET, contentKeyAuthorizationPolicyOptionId);
+    }
+}
diff --git a/media/src/main/java/com/microsoft/windowsazure/services/media/models/ContentKeyAuthorizationPolicyOptionInfo.java b/media/src/main/java/com/microsoft/windowsazure/services/media/models/ContentKeyAuthorizationPolicyOptionInfo.java
new file mode 100644
index 0000000..59b7ddd
--- /dev/null
+++ b/media/src/main/java/com/microsoft/windowsazure/services/media/models/ContentKeyAuthorizationPolicyOptionInfo.java
@@ -0,0 +1,103 @@
+/**
+ * Copyright Microsoft Corporation
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.microsoft.windowsazure.services.media.models;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import com.microsoft.windowsazure.services.media.implementation.ODataEntity;
+import com.microsoft.windowsazure.services.media.implementation.atom.EntryType;
+import com.microsoft.windowsazure.services.media.implementation.content.ContentKeyAuthorizationPolicyOptionType;
+import com.microsoft.windowsazure.services.media.implementation.content.ContentKeyAuthorizationPolicyRestrictionType;
+
+/**
+ * Type containing data about content key authorization policy options.
+ * 
+ */
+public class ContentKeyAuthorizationPolicyOptionInfo extends ODataEntity<ContentKeyAuthorizationPolicyOptionType> {
+
+    /**
+     * Creates a new {@link ContentKeyAuthorizationPolicyOptionInfo} wrapping
+     * the given ATOM entry and content objects.
+     * 
+     * @param entry
+     *            the entry
+     * @param content
+     *            the content
+     */
+    public ContentKeyAuthorizationPolicyOptionInfo(EntryType entry, ContentKeyAuthorizationPolicyOptionType content) {
+        super(entry, content);
+    }
+
+    /**
+     * Get the access policy id.
+     * 
+     * @return the id.
+     */
+    public String getId() {
+        return getContent().getId();
+    }
+
+    /**
+     * Get the name.
+     * 
+     * @return the name.
+     */
+    public String getName() {
+        return getContent().getName();
+    }
+
+    /**
+     * Get the content key authorization policy options key delivery type.
+     * 
+     * @return the key delivery type.
+     */
+    public int getKeyDeliveryType() {
+        return getContent().getKeyDeliveryType();
+    }
+
+    /**
+     * Get the content key authorization policy options key delivery
+     * configuration.
+     * 
+     * @return the key delivery configuration.
+     */
+    public String getKeyDeliveryConfiguration() {
+        return getContent().getKeyDeliveryConfiguration();
+    }
+
+    /**
+     * Get the content key authorization policy options restrictions.
+     * 
+     * @return the restrictions.
+     */
+    public List<ContentKeyAuthorizationPolicyRestriction> getRestrictions() {
+        List<ContentKeyAuthorizationPolicyRestriction> result = new ArrayList<ContentKeyAuthorizationPolicyRestriction>();
+        List<ContentKeyAuthorizationPolicyRestrictionType> restrictionsTypes = getContent().getRestrictions();
+
+        if (restrictionsTypes != null) {
+            for (ContentKeyAuthorizationPolicyRestrictionType restrictionType : restrictionsTypes) {
+                ContentKeyAuthorizationPolicyRestriction contentKeyAuthPolicyRestriction = new ContentKeyAuthorizationPolicyRestriction(
+                        restrictionType.getName(), restrictionType.getKeyRestrictionType(),
+                        restrictionType.getRequirements());
+                result.add(contentKeyAuthPolicyRestriction);
+            }
+        }
+
+        return result;
+    }
+
+}
diff --git a/media/src/main/java/com/microsoft/windowsazure/services/media/models/ContentKeyAuthorizationPolicyRestriction.java b/media/src/main/java/com/microsoft/windowsazure/services/media/models/ContentKeyAuthorizationPolicyRestriction.java
new file mode 100644
index 0000000..292d906
--- /dev/null
+++ b/media/src/main/java/com/microsoft/windowsazure/services/media/models/ContentKeyAuthorizationPolicyRestriction.java
@@ -0,0 +1,87 @@
+/*
+ * Copyright Microsoft Corporation
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.microsoft.windowsazure.services.media.models;
+
+/**
+ * The Class ContentKeyAuthorizationPolicyRestriction.
+ */
+public class ContentKeyAuthorizationPolicyRestriction {
+    
+    public enum ContentKeyRestrictionType {
+        Open(0),
+        TokenRestricted(1),
+        IPRestricted(2);
+        
+        private final int value;
+        private ContentKeyRestrictionType(int value) {
+            this.value = value;
+        }
+
+        public int getValue() {
+            return value;
+        }
+
+    }
+
+    private final String name;
+
+    private final int keyRestrictionType;
+
+    private final String requirements;
+
+    /**
+     * Instantiates a new Content Key Authorization Policy Restriction
+     * 
+     * @param name
+     *            the name
+     * @param keyRestrictionType
+     *            the keyRestrictionType
+     * @param requirements
+     *            the requirements
+     */
+    public ContentKeyAuthorizationPolicyRestriction(String name, int keyRestrictionType, String requirements) {
+        this.name = name;
+        this.keyRestrictionType = keyRestrictionType;
+        this.requirements = requirements;
+    }
+
+    /**
+     * Gets the name.
+     * 
+     * @return the name
+     */
+    public String getName() {
+        return this.name;
+    }
+
+    /**
+     * Gets the key restriction type.
+     * 
+     * @return the key restriction type
+     */
+    public int getKeyRestrictionType() {
+        return this.keyRestrictionType;
+    }
+
+    /**
+     * Gets the requirements.
+     * 
+     * @return the time requirements
+     */
+    public String getRequirements() {
+        return this.requirements;
+    }
+}
diff --git a/media/src/test/java/com/microsoft/windowsazure/services/media/contentprotection/ContentKeyAuthorizationPolicyEntityTest.java b/media/src/test/java/com/microsoft/windowsazure/services/media/contentprotection/ContentKeyAuthorizationPolicyEntityTest.java
new file mode 100644
index 0000000..55f264f
--- /dev/null
+++ b/media/src/test/java/com/microsoft/windowsazure/services/media/contentprotection/ContentKeyAuthorizationPolicyEntityTest.java
@@ -0,0 +1,107 @@
+/**
+ * Copyright Microsoft Corporation
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.microsoft.windowsazure.services.media.contentprotection;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertNull;
+
+import java.net.URLEncoder;
+
+import org.junit.Test;
+
+import com.microsoft.windowsazure.exception.ServiceException;
+import com.microsoft.windowsazure.services.media.entityoperations.EntityDeleteOperation;
+import com.microsoft.windowsazure.services.media.entityoperations.EntityGetOperation;
+import com.microsoft.windowsazure.services.media.entityoperations.EntityListOperation;
+import com.microsoft.windowsazure.services.media.implementation.content.ContentKeyAuthorizationPolicyType;
+import com.microsoft.windowsazure.services.media.models.ContentKeyAuthorizationPolicy;
+import com.microsoft.windowsazure.services.media.models.ContentKeyAuthorizationPolicyInfo;
+
+/**
+ * Tests for the methods and factories of the Asset entity.
+ */
+public class ContentKeyAuthorizationPolicyEntityTest {
+	// Common Arrange
+	private static final String ENTITY_SET = "ContentKeyAuthorizationPolicies";
+	private static final String sampleCKAPId = "nb:ckpid:UUID:e640675d-adf5-4a15-b8c5-021e3ab01a10";
+	private static final String sampleCKAPName = "sampleContentKeyAuthPolicyName";
+	private final String expectedUri = String.format("%s('%s')", ENTITY_SET, URLEncoder.encode(sampleCKAPId, "UTF-8"));
+
+	public ContentKeyAuthorizationPolicyEntityTest() throws Exception {
+	}
+
+	@Test
+	public void ckapCreateReturnsValidPayload() throws ServiceException {
+		// Act
+		ContentKeyAuthorizationPolicyType payload = (ContentKeyAuthorizationPolicyType) ContentKeyAuthorizationPolicy
+				.create(sampleCKAPName).getRequestContents();
+
+		// Assert
+		assertNotNull(payload);
+		assertNull(payload.getId());
+		assertEquals(payload.getName(), sampleCKAPName);
+
+	}
+
+	@Test
+	public void ckapGetReturnsExpectedUri() throws Exception {
+		// Act
+		EntityGetOperation<ContentKeyAuthorizationPolicyInfo> getter = ContentKeyAuthorizationPolicy.get(sampleCKAPId);
+
+		// Assert
+		assertEquals(expectedUri, getter.getUri());
+	}
+
+	@Test
+	public void ckapListReturnsExpectedUri() {
+		// Act
+		EntityListOperation<ContentKeyAuthorizationPolicyInfo> lister = ContentKeyAuthorizationPolicy.list();
+
+		// Assert
+		assertEquals(ENTITY_SET, lister.getUri());
+		assertNotNull(lister.getQueryParameters());
+		assertEquals(0, lister.getQueryParameters().size());
+	}
+
+	@Test
+	public void ckapListCanTakeQueryParameters() {
+		EntityListOperation<ContentKeyAuthorizationPolicyInfo> lister = ContentKeyAuthorizationPolicy.list().setTop(10)
+				.setSkip(2);
+
+		assertEquals("10", lister.getQueryParameters().getFirst("$top"));
+		assertEquals("2", lister.getQueryParameters().getFirst("$skip"));
+		assertEquals(2, lister.getQueryParameters().size());
+	}
+
+	@Test
+	public void ckapListCanTakeQueryParametersChained() {
+		EntityListOperation<ContentKeyAuthorizationPolicyInfo> lister = ContentKeyAuthorizationPolicy.list().setTop(10)
+				.setSkip(2).set("filter", "something");
+
+		assertEquals("10", lister.getQueryParameters().getFirst("$top"));
+		assertEquals("2", lister.getQueryParameters().getFirst("$skip"));
+		assertEquals("something", lister.getQueryParameters().getFirst("filter"));
+		assertEquals(3, lister.getQueryParameters().size());
+	}
+
+	@Test
+	public void ckapDeleteReturnsExpectedUri() throws Exception {
+		EntityDeleteOperation deleter = ContentKeyAuthorizationPolicy.delete(sampleCKAPId);
+
+		assertEquals(expectedUri, deleter.getUri());
+	}
+}
diff --git a/media/src/test/java/com/microsoft/windowsazure/services/media/contentprotection/ContentKeyAuthorizationPolicyInfoTest.java b/media/src/test/java/com/microsoft/windowsazure/services/media/contentprotection/ContentKeyAuthorizationPolicyInfoTest.java
new file mode 100644
index 0000000..93cb32e
--- /dev/null
+++ b/media/src/test/java/com/microsoft/windowsazure/services/media/contentprotection/ContentKeyAuthorizationPolicyInfoTest.java
@@ -0,0 +1,53 @@
+/**
+ * Copyright Microsoft Corporation
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.microsoft.windowsazure.services.media.contentprotection;
+
+import static org.junit.Assert.assertEquals;
+
+import org.junit.Test;
+
+import com.microsoft.windowsazure.services.media.implementation.content.ContentKeyAuthorizationPolicyType;
+import com.microsoft.windowsazure.services.media.models.ContentKeyAuthorizationPolicyInfo;
+
+public class ContentKeyAuthorizationPolicyInfoTest {
+
+	@Test
+	public void testGetSetId() {
+		// Arrange
+		String expectedId = "expectedId";
+		ContentKeyAuthorizationPolicyInfo contentKeyAuthorizationPolicyInfo = new ContentKeyAuthorizationPolicyInfo(
+				null, new ContentKeyAuthorizationPolicyType().setId(expectedId));
+
+		// Act
+		String actualId = contentKeyAuthorizationPolicyInfo.getId();
+
+		// Assert
+		assertEquals(expectedId, actualId);
+	}
+
+	@Test
+	public void testGetSetName() {
+		// Arrange
+		String expectedName = "expectedName";
+		ContentKeyAuthorizationPolicyInfo contentKeyAuthorizationPolicyInfo = new ContentKeyAuthorizationPolicyInfo(
+				null, new ContentKeyAuthorizationPolicyType().setName(expectedName));
+
+		// Act
+		String actualName = contentKeyAuthorizationPolicyInfo.getName();
+
+		// Assert
+		assertEquals(expectedName, actualName);
+	}
+}
diff --git a/media/src/test/java/com/microsoft/windowsazure/services/media/contentprotection/ContentKeyAuthorizationPolicyOptionEntityTest.java b/media/src/test/java/com/microsoft/windowsazure/services/media/contentprotection/ContentKeyAuthorizationPolicyOptionEntityTest.java
new file mode 100644
index 0000000..8f517f4
--- /dev/null
+++ b/media/src/test/java/com/microsoft/windowsazure/services/media/contentprotection/ContentKeyAuthorizationPolicyOptionEntityTest.java
@@ -0,0 +1,109 @@
+/**
+ * Copyright Microsoft Corporation
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.microsoft.windowsazure.services.media.contentprotection;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertNull;
+
+import java.net.URLEncoder;
+import java.util.ArrayList;
+import java.util.List;
+
+import org.junit.Test;
+
+import com.microsoft.windowsazure.exception.ServiceException;
+import com.microsoft.windowsazure.services.media.entityoperations.EntityDeleteOperation;
+import com.microsoft.windowsazure.services.media.entityoperations.EntityGetOperation;
+import com.microsoft.windowsazure.services.media.entityoperations.EntityListOperation;
+import com.microsoft.windowsazure.services.media.implementation.content.ContentKeyAuthorizationPolicyOptionType;
+import com.microsoft.windowsazure.services.media.models.ContentKeyAuthorizationPolicyOption;
+import com.microsoft.windowsazure.services.media.models.ContentKeyAuthorizationPolicyOptionInfo;
+import com.microsoft.windowsazure.services.media.models.ContentKeyAuthorizationPolicyRestriction;
+
+/**
+ * Tests for the methods and factories of the Asset entity.
+ */
+public class ContentKeyAuthorizationPolicyOptionEntityTest {
+	private static final String ENTITY_SET = "ContentKeyAuthorizationPolicyOptions";
+	private static final String sampleCKAPOId = "nb:ckpoid:UUID:c244a5a7-a3d9-4ba0-a707-4336554f09b2";
+	private static final String sampleCKAPOName = "sampleContentKeyAuthPolicyOptName";
+	private static final String sampleCKAPOKDC = "sampleKeyDeliveryConfiguration";
+	private final String expectedUri = String.format("%s('%s')", ENTITY_SET, URLEncoder.encode(sampleCKAPOId, "UTF-8"));
+
+	public ContentKeyAuthorizationPolicyOptionEntityTest() throws Exception {
+	}
+
+	@Test
+	public void ckapoCreateReturnsValidPayload() throws ServiceException {
+		List<ContentKeyAuthorizationPolicyRestriction> restrictions = new ArrayList<ContentKeyAuthorizationPolicyRestriction>();
+		ContentKeyAuthorizationPolicyOptionType payload = (ContentKeyAuthorizationPolicyOptionType) ContentKeyAuthorizationPolicyOption
+				.create(sampleCKAPOName, 2, sampleCKAPOKDC, restrictions).getRequestContents();
+
+		assertNotNull(payload);
+		assertNull(payload.getId());
+		assertEquals(payload.getName(), sampleCKAPOName);
+		assertEquals(payload.getKeyDeliveryType(), 2);
+		assertEquals(payload.getKeyDeliveryConfiguration(), sampleCKAPOKDC);
+		assertNotNull(payload.getRestrictions());
+	}
+
+	@Test
+	public void ckapoGetReturnsExpectedUri() throws Exception {
+		EntityGetOperation<ContentKeyAuthorizationPolicyOptionInfo> getter = ContentKeyAuthorizationPolicyOption
+				.get(sampleCKAPOId);
+
+		assertEquals(expectedUri, getter.getUri());
+	}
+
+	@Test
+	public void ckapoListReturnsExpectedUri() {
+		EntityListOperation<ContentKeyAuthorizationPolicyOptionInfo> lister = ContentKeyAuthorizationPolicyOption
+				.list();
+
+		assertEquals(ENTITY_SET, lister.getUri());
+		assertNotNull(lister.getQueryParameters());
+		assertEquals(0, lister.getQueryParameters().size());
+	}
+
+	@Test
+	public void ckapoListCanTakeQueryParameters() {
+		EntityListOperation<ContentKeyAuthorizationPolicyOptionInfo> lister = ContentKeyAuthorizationPolicyOption.list()
+				.setTop(10).setSkip(2);
+
+		assertEquals("10", lister.getQueryParameters().getFirst("$top"));
+		assertEquals("2", lister.getQueryParameters().getFirst("$skip"));
+		assertEquals(2, lister.getQueryParameters().size());
+	}
+
+	@Test
+	public void ckapoListCanTakeQueryParametersChained() {
+		EntityListOperation<ContentKeyAuthorizationPolicyOptionInfo> lister = ContentKeyAuthorizationPolicyOption.list()
+				.setTop(10).setSkip(2).set("filter", "something");
+
+		assertEquals("10", lister.getQueryParameters().getFirst("$top"));
+		assertEquals("2", lister.getQueryParameters().getFirst("$skip"));
+		assertEquals("something", lister.getQueryParameters().getFirst("filter"));
+		assertEquals(3, lister.getQueryParameters().size());
+	}
+
+	@Test
+	public void ckapoDeleteReturnsExpectedUri() throws Exception {
+		EntityDeleteOperation deleter = ContentKeyAuthorizationPolicyOption.delete(sampleCKAPOId);
+
+		assertEquals(expectedUri, deleter.getUri());
+	}
+}
diff --git a/media/src/test/java/com/microsoft/windowsazure/services/media/contentprotection/ContentKeyAuthorizationPolicyOptionInfoTest.java b/media/src/test/java/com/microsoft/windowsazure/services/media/contentprotection/ContentKeyAuthorizationPolicyOptionInfoTest.java
new file mode 100644
index 0000000..c5128f9
--- /dev/null
+++ b/media/src/test/java/com/microsoft/windowsazure/services/media/contentprotection/ContentKeyAuthorizationPolicyOptionInfoTest.java
@@ -0,0 +1,110 @@
+/**
+ * Copyright Microsoft Corporation
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.microsoft.windowsazure.services.media.contentprotection;
+
+import static org.junit.Assert.assertEquals;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import org.junit.Test;
+
+import com.microsoft.windowsazure.services.media.implementation.content.ContentKeyAuthorizationPolicyOptionType;
+import com.microsoft.windowsazure.services.media.implementation.content.ContentKeyAuthorizationPolicyRestrictionType;
+import com.microsoft.windowsazure.services.media.models.ContentKeyAuthorizationPolicyOptionInfo;
+import com.microsoft.windowsazure.services.media.models.ContentKeyAuthorizationPolicyRestriction;
+
+public class ContentKeyAuthorizationPolicyOptionInfoTest {
+
+	@Test
+	public void testGetSetId() {
+		// Arrange
+		String expectedId = "expectedId";
+		ContentKeyAuthorizationPolicyOptionInfo contentKeyAuthorizationPolicyOptionInfo = new ContentKeyAuthorizationPolicyOptionInfo(
+				null, new ContentKeyAuthorizationPolicyOptionType().setId(expectedId));
+
+		// Act
+		String actualId = contentKeyAuthorizationPolicyOptionInfo.getId();
+
+		// Assert
+		assertEquals(expectedId, actualId);
+	}
+
+	@Test
+	public void testGetSetName() {
+		// Arrange
+		String expectedName = "expectedName";
+		ContentKeyAuthorizationPolicyOptionInfo contentKeyAuthorizationPolicyOptionInfo = new ContentKeyAuthorizationPolicyOptionInfo(
+				null, new ContentKeyAuthorizationPolicyOptionType().setName(expectedName));
+
+		// Act
+		String actualName = contentKeyAuthorizationPolicyOptionInfo.getName();
+
+		// Assert
+		assertEquals(expectedName, actualName);
+	}
+
+	@Test
+	public void testGetSetKeyDeliveryConfiguration() {
+		// Arrange
+		String expectedKeyDeliveryConfiguration = "expectedKeyDeliveryConfiguration";
+		ContentKeyAuthorizationPolicyOptionInfo contentKeyAuthorizationPolicyOptionInfo = new ContentKeyAuthorizationPolicyOptionInfo(
+				null, new ContentKeyAuthorizationPolicyOptionType()
+						.setKeyDeliveryConfiguration(expectedKeyDeliveryConfiguration));
+
+		// Act
+		String actualKeyDeliveryConfiguration = contentKeyAuthorizationPolicyOptionInfo.getKeyDeliveryConfiguration();
+
+		// Assert
+		assertEquals(expectedKeyDeliveryConfiguration, actualKeyDeliveryConfiguration);
+
+	}
+
+	@Test
+	public void testGetSetKeyDeliveryType() {
+		// Arrange
+		int expectedKeyDeliveryType = 2;
+		ContentKeyAuthorizationPolicyOptionInfo contentKeyAuthorizationPolicyOptionInfo = new ContentKeyAuthorizationPolicyOptionInfo(
+				null, new ContentKeyAuthorizationPolicyOptionType().setKeyDeliveryType(expectedKeyDeliveryType));
+
+		// Act
+		int actualKeyDeliveryType = contentKeyAuthorizationPolicyOptionInfo.getKeyDeliveryType();
+
+		// Assert
+		assertEquals(expectedKeyDeliveryType, actualKeyDeliveryType);
+	}
+
+	@Test
+	public void testGetSetRestrictions() {
+		// Arrange
+		String expectedRestrictionName = "expectedRestriction";
+		String expectedRestrictionReq = "<xml></xml>";
+		int expectedRestrictionType = 2;
+		List<ContentKeyAuthorizationPolicyRestrictionType> settedRestrictions = new ArrayList<ContentKeyAuthorizationPolicyRestrictionType>();
+		settedRestrictions.add(new ContentKeyAuthorizationPolicyRestrictionType().setName(expectedRestrictionName)
+				.setKeyRestrictionType(expectedRestrictionType).setRequirements(expectedRestrictionReq));
+		ContentKeyAuthorizationPolicyOptionInfo contentKeyAuthorizationPolicyOptionInfo = new ContentKeyAuthorizationPolicyOptionInfo(
+				null, new ContentKeyAuthorizationPolicyOptionType().setRestrictions(settedRestrictions));
+
+		// Act
+		List<ContentKeyAuthorizationPolicyRestriction> actualRestrictions = contentKeyAuthorizationPolicyOptionInfo
+				.getRestrictions();
+
+		// Assert
+		assertEquals(actualRestrictions.get(0).getName(), expectedRestrictionName);
+		assertEquals(actualRestrictions.get(0).getKeyRestrictionType(), expectedRestrictionType);
+		assertEquals(actualRestrictions.get(0).getRequirements(), expectedRestrictionReq);
+	}
+}
-- 
1.9.5.msysgit.1


From eaf723eed302bdcdcc1754247da940bc7e87833b Mon Sep 17 00:00:00 2001
From: Emanuel Vecchio <vecchioemanuel@gmail.com>
Date: Mon, 20 Jul 2015 18:09:54 -0300
Subject: [PATCH 02/21] Changed version from 2.5 to 2.11

---
 .../services/media/implementation/VersionHeadersFilter.java             | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/media/src/main/java/com/microsoft/windowsazure/services/media/implementation/VersionHeadersFilter.java b/media/src/main/java/com/microsoft/windowsazure/services/media/implementation/VersionHeadersFilter.java
index 4e98863..e9feb88 100644
--- a/media/src/main/java/com/microsoft/windowsazure/services/media/implementation/VersionHeadersFilter.java
+++ b/media/src/main/java/com/microsoft/windowsazure/services/media/implementation/VersionHeadersFilter.java
@@ -40,7 +40,7 @@ public class VersionHeadersFilter extends IdempotentClientFilter {
         MultivaluedMap<String, Object> headers = cr.getHeaders();
         headers.add("DataServiceVersion", "3.0");
         headers.add("MaxDataServiceVersion", "3.0");
-        headers.add("x-ms-version", "2.5");
+        headers.add("x-ms-version", "2.11");
         return getNext().handle(cr);
     }
 }
-- 
1.9.5.msysgit.1


From 54722cf94b8da3dac7cb36a7e5ed2d9920894614 Mon Sep 17 00:00:00 2001
From: Emanuel Vecchio <vecchioemanuel@gmail.com>
Date: Tue, 21 Jul 2015 17:55:09 -0300
Subject: [PATCH 03/21] New Entities and Operations

entities: TokenType, TokenClaim, TokenVerificationKey,
SymmetricTokenVerificationKey, AsymmetricTokenVerificationKey, and
X509CertTokenVerificationKey.

Asset properties: AlternateId and StorageAccountName

Operations:
 - Asset: unlink ContentKeys and link/unlink DeliveryPolicies.
 - ContentKey: update the ContentKeyAuthorizationPolicyId and
getKeyDeliveryUrl.
---
 .../services/media/EncryptionUtils.java            |  48 ++++++++++
 .../media/implementation/content/AssetType.java    |  35 +++++++
 .../implementation/content/ContentKeyRestType.java |  27 ++++++
 .../AsymmetricTokenVerificationKey.java            |  34 +++++++
 .../tokenrestriction/SymmetricVerificationKey.java |  49 ++++++++++
 .../templates/tokenrestriction/TokenClaim.java     |  79 ++++++++++++++++
 .../templates/tokenrestriction/TokenType.java      |  51 +++++++++++
 .../tokenrestriction/TokenVerificationKey.java     |  10 ++
 .../X509CertTokenVerificationKey.java              |  57 ++++++++++++
 .../windowsazure/services/media/models/Asset.java  |  72 ++++++++++++++-
 .../services/media/models/AssetInfo.java           |  27 ++++++
 .../services/media/models/ContentKey.java          | 102 +++++++++++++++++++++
 .../media/models/ContentKeyDeliveryType.java       |  73 +++++++++++++++
 .../services/media/models/ContentKeyInfo.java      |   9 ++
 .../services/media/models/ContentKeyType.java      |   6 +-
 ...ntentKeyAuthorizationPolicyRestrictionTest.java |  56 +++++++++++
 .../SymmetricVerificationKeyTests.java             |  52 +++++++++++
 .../tokenrestriction/TokenClaimTests.java          |  74 +++++++++++++++
 .../templates/tokenrestriction/TokenTypeTests.java |  84 +++++++++++++++++
 .../X509CertTokenVerificationKeyTests.java         | 102 +++++++++++++++++++++
 .../services/media/models/ContentKeyInfoTest.java  |  14 +++
 21 files changed, 1057 insertions(+), 4 deletions(-)
 create mode 100644 media/src/main/java/com/microsoft/windowsazure/services/media/EncryptionUtils.java
 create mode 100644 media/src/main/java/com/microsoft/windowsazure/services/media/implementation/templates/tokenrestriction/AsymmetricTokenVerificationKey.java
 create mode 100644 media/src/main/java/com/microsoft/windowsazure/services/media/implementation/templates/tokenrestriction/SymmetricVerificationKey.java
 create mode 100644 media/src/main/java/com/microsoft/windowsazure/services/media/implementation/templates/tokenrestriction/TokenClaim.java
 create mode 100644 media/src/main/java/com/microsoft/windowsazure/services/media/implementation/templates/tokenrestriction/TokenType.java
 create mode 100644 media/src/main/java/com/microsoft/windowsazure/services/media/implementation/templates/tokenrestriction/TokenVerificationKey.java
 create mode 100644 media/src/main/java/com/microsoft/windowsazure/services/media/implementation/templates/tokenrestriction/X509CertTokenVerificationKey.java
 create mode 100644 media/src/main/java/com/microsoft/windowsazure/services/media/models/ContentKeyDeliveryType.java
 create mode 100644 media/src/test/java/com/microsoft/windowsazure/services/media/contentprotection/ContentKeyAuthorizationPolicyRestrictionTest.java
 create mode 100644 media/src/test/java/com/microsoft/windowsazure/services/media/implementation/templates/tokenrestriction/SymmetricVerificationKeyTests.java
 create mode 100644 media/src/test/java/com/microsoft/windowsazure/services/media/implementation/templates/tokenrestriction/TokenClaimTests.java
 create mode 100644 media/src/test/java/com/microsoft/windowsazure/services/media/implementation/templates/tokenrestriction/TokenTypeTests.java
 create mode 100644 media/src/test/java/com/microsoft/windowsazure/services/media/implementation/templates/tokenrestriction/X509CertTokenVerificationKeyTests.java

diff --git a/media/src/main/java/com/microsoft/windowsazure/services/media/EncryptionUtils.java b/media/src/main/java/com/microsoft/windowsazure/services/media/EncryptionUtils.java
new file mode 100644
index 0000000..2bd0596
--- /dev/null
+++ b/media/src/main/java/com/microsoft/windowsazure/services/media/EncryptionUtils.java
@@ -0,0 +1,48 @@
+package com.microsoft.windowsazure.services.media;
+
+import java.security.NoSuchAlgorithmException;
+import java.security.SecureRandom;
+
+public final class EncryptionUtils {
+
+    public final String keyIdentifierPrefix = "nb:kid:UUID:";
+
+    /// The key size for AEI 128.
+    public final int keySizeInBytesForAes128 = 16;
+
+    /// The key size for AEI 256.
+    public final int keySizeInBytesForAes256 = 32;
+
+    /// The key size for AEI 128 in bits.
+    public final int keySizeInBitsForAes128 = 128;
+
+    /// The key size for AEI 256 in bits.
+    public final int keySizeInBitsForAes256 = 256;
+
+    /// The IV size for AEI Cbc.
+    public final int iVSizeInBytesForAesCbc = 16;
+
+    // Enforce noninstantiability with a private constructor
+    private EncryptionUtils() {
+        // not called
+    }
+
+    /**
+     * Overwrites the supplied byte array with RNG generated data which destroys
+     * the original contents.
+     * 
+     * @param keyToErase
+     *            The content key to erase.
+     */
+    public static void eraseKey(byte[] keyToErase) {
+        if (keyToErase != null) {
+            SecureRandom random;
+            try {
+                random = SecureRandom.getInstance("SHA1PRNG");
+                random.nextBytes(keyToErase);
+            } catch (NoSuchAlgorithmException e) {
+                // never reached
+            }
+        }
+    }
+}
diff --git a/media/src/main/java/com/microsoft/windowsazure/services/media/implementation/content/AssetType.java b/media/src/main/java/com/microsoft/windowsazure/services/media/implementation/content/AssetType.java
index 1b050d1..68ba2fb 100644
--- a/media/src/main/java/com/microsoft/windowsazure/services/media/implementation/content/AssetType.java
+++ b/media/src/main/java/com/microsoft/windowsazure/services/media/implementation/content/AssetType.java
@@ -50,6 +50,12 @@ public class AssetType implements MediaServiceDTO {
     @XmlElement(name = "Options", namespace = Constants.ODATA_DATA_NS)
     private Integer options;
 
+    @XmlElement(name = "Uri", namespace = Constants.ODATA_DATA_NS)
+    private String uri;    
+    
+    @XmlElement(name = "StorageAccountName", namespace = Constants.ODATA_DATA_NS)
+    private String storageAccountName;
+
     /**
      * @return the id
      */
@@ -161,4 +167,33 @@ public class AssetType implements MediaServiceDTO {
         this.options = options;
         return this;
     }
+
+    /**
+     * @return The Name of the storage account that contains the assets blob container.
+     */
+    public String getStorageAccountName() {
+        return storageAccountName;
+    }
+
+    /**
+     * @param storageAccountName 
+     *              Name of the storage account that contains the assets blob container.
+     */
+    public void setStorageAccountName(String storageAccountName) {
+        this.storageAccountName = storageAccountName;
+    }
+
+    /**
+     * @return The URI of the blob storage container of the specified Asset
+     */
+    public String getUri() {
+        return uri;
+    }
+
+    /**
+     * @param The URI of the blob storage container of the specified Asset
+     */
+    public void setUri(String uri) {
+        this.uri = uri;
+    }
 }
diff --git a/media/src/main/java/com/microsoft/windowsazure/services/media/implementation/content/ContentKeyRestType.java b/media/src/main/java/com/microsoft/windowsazure/services/media/implementation/content/ContentKeyRestType.java
index 1bced67..79dc66e 100644
--- a/media/src/main/java/com/microsoft/windowsazure/services/media/implementation/content/ContentKeyRestType.java
+++ b/media/src/main/java/com/microsoft/windowsazure/services/media/implementation/content/ContentKeyRestType.java
@@ -64,6 +64,11 @@ public class ContentKeyRestType implements MediaServiceDTO {
     /** The checksum. */
     @XmlElement(name = "Checksum", namespace = Constants.ODATA_DATA_NS)
     private String checksum;
+    
+    /** The authorization policy id . */
+    @XmlElement(name = "AuthorizationPolicyId", namespace = Constants.ODATA_DATA_NS)
+    private String authorizationPolicyId;
+
 
     /**
      * Gets the id.
@@ -253,4 +258,26 @@ public class ContentKeyRestType implements MediaServiceDTO {
     public String getEncryptedContentKey() {
         return this.encryptedContentKey;
     }
+    
+
+    /**
+     * Sets the authorization policy id.
+     * 
+     * @param authorizationPolicyId
+     *            the authorization policy id
+     * @return the content key rest type
+     */
+    public ContentKeyRestType setAuthorizationPolicyId(String authorizationPolicyId) {
+        this.authorizationPolicyId = authorizationPolicyId;
+        return this;
+    }
+
+    /**
+     * Gets the the authorization policy id.
+     * 
+     * @return the authorization policy id
+     */
+    public String getAuthorizationPolicyId() {
+        return authorizationPolicyId;
+    }
 }
diff --git a/media/src/main/java/com/microsoft/windowsazure/services/media/implementation/templates/tokenrestriction/AsymmetricTokenVerificationKey.java b/media/src/main/java/com/microsoft/windowsazure/services/media/implementation/templates/tokenrestriction/AsymmetricTokenVerificationKey.java
new file mode 100644
index 0000000..e1826ff
--- /dev/null
+++ b/media/src/main/java/com/microsoft/windowsazure/services/media/implementation/templates/tokenrestriction/AsymmetricTokenVerificationKey.java
@@ -0,0 +1,34 @@
+package com.microsoft.windowsazure.services.media.implementation.templates.tokenrestriction;
+
+import javax.xml.bind.annotation.XmlAccessType;
+import javax.xml.bind.annotation.XmlAccessorType;
+import javax.xml.bind.annotation.XmlElement;
+
+/**
+ * Class AsymmetricTokenVerificationKey represents asymmetric keys which are used in token verification scenarios.
+ */
+@XmlAccessorType(XmlAccessType.PUBLIC_MEMBER)
+public abstract class AsymmetricTokenVerificationKey extends TokenVerificationKey {
+
+    /**
+     * the raw body of a key.
+     */
+    private byte[] rawBody;
+
+    /**
+     * Gets the raw body of a key.
+     * @return the rawBody
+     */
+    @XmlElement(name = "RawBody", required = true, nillable = true)
+    public byte[] getRawBody() {
+        return rawBody;
+    }
+
+    /**
+     * Sets the raw body of a key.
+     * @param rawBody the rawBody to set
+     */
+    public void setRawBody(byte[] rawBody) {
+        this.rawBody = rawBody;
+    }
+}
diff --git a/media/src/main/java/com/microsoft/windowsazure/services/media/implementation/templates/tokenrestriction/SymmetricVerificationKey.java b/media/src/main/java/com/microsoft/windowsazure/services/media/implementation/templates/tokenrestriction/SymmetricVerificationKey.java
new file mode 100644
index 0000000..cfe515c
--- /dev/null
+++ b/media/src/main/java/com/microsoft/windowsazure/services/media/implementation/templates/tokenrestriction/SymmetricVerificationKey.java
@@ -0,0 +1,49 @@
+package com.microsoft.windowsazure.services.media.implementation.templates.tokenrestriction;
+
+import javax.xml.bind.annotation.XmlAccessType;
+import javax.xml.bind.annotation.XmlAccessorType;
+import javax.xml.bind.annotation.XmlElement;
+import javax.xml.bind.annotation.XmlType;
+
+import com.microsoft.windowsazure.services.media.EncryptionUtils;
+
+@XmlAccessorType(XmlAccessType.FIELD)
+@XmlType(name = "SymmetricVerificationKey")
+public class SymmetricVerificationKey extends TokenVerificationKey {
+    
+    @XmlElement(name = "KeyValue")
+    private byte[] keyValue;
+   
+    /**
+     * Constructs a SymmetricVerificationKey using a randomly generated key value.
+     * The key value generated is 64 bytes long.
+     */
+    public SymmetricVerificationKey() {
+        keyValue = new byte[64];
+        EncryptionUtils.eraseKey(keyValue);
+    }
+    
+    /**
+     * Constructs a SymmetricVerificationKey using the provided key value.
+     * @param keyValue the provided key value
+     */
+    public SymmetricVerificationKey(byte[] keyValue) {
+        this.keyValue = keyValue;
+    }
+
+    /**
+     * @return the keyValue
+     */
+    public byte[] getKeyValue() {
+        return keyValue;
+    }
+
+    /**
+     * @param keyValue the keyValue to set
+     */
+    public void setKeyValue(byte[] keyValue) {
+        this.keyValue = keyValue;
+    }
+    
+    
+}
diff --git a/media/src/main/java/com/microsoft/windowsazure/services/media/implementation/templates/tokenrestriction/TokenClaim.java b/media/src/main/java/com/microsoft/windowsazure/services/media/implementation/templates/tokenrestriction/TokenClaim.java
new file mode 100644
index 0000000..79a28fd
--- /dev/null
+++ b/media/src/main/java/com/microsoft/windowsazure/services/media/implementation/templates/tokenrestriction/TokenClaim.java
@@ -0,0 +1,79 @@
+package com.microsoft.windowsazure.services.media.implementation.templates.tokenrestriction;
+
+import javax.xml.bind.annotation.XmlAccessType;
+import javax.xml.bind.annotation.XmlAccessorType;
+import javax.xml.bind.annotation.XmlElement;
+import javax.xml.bind.annotation.XmlType;
+
+@XmlAccessorType(XmlAccessType.FIELD)
+@XmlType(name = "TokenClaim")
+public class TokenClaim {
+    
+    private static final String CONTENT_KEY_ID_CLAIM_TYPE = "urn:microsoft:azure:mediaservices:contentkeyidentifier";
+    
+    private static final TokenClaim CONTENT_KEY_ID_CLAIM = new TokenClaim(CONTENT_KEY_ID_CLAIM_TYPE, null);
+
+    @XmlElement(name = "ClaimType", required = true)
+    private String claimType;
+    
+    @XmlElement(name = "ClaimValue", required = true, nillable = true)
+    private String claimValue;
+    
+    public TokenClaim() {
+        
+    }
+     
+    public TokenClaim(String claimType, String claimValue) {
+        if (claimType == null) {
+            throw new NullPointerException("claimType");
+        }
+        setClaimType(claimType);
+        setClaimValue(claimValue);
+    }
+
+    /**
+     * @return the claimType
+     */
+    public String getClaimType() {
+        return claimType;
+    }
+
+    /**
+     * @param claimType the claimType to set
+     * @return this
+     */
+    public TokenClaim setClaimType(String claimType) {
+        this.claimType = claimType;
+        return this;
+    }
+
+    /**
+     * @return the claimValue
+     */
+    public String getClaimValue() {
+        return claimValue;
+    }
+
+    /**
+     * @param claimValue the claimValue to set
+     * @return this
+     */
+    public TokenClaim setClaimValue(String claimValue) {
+        this.claimValue = claimValue;
+        return this;
+    }
+
+    /**
+     * @return the contentKeyIdentifierClaimType
+     */
+    public static String getContentKeyIdentifierClaimType() {
+        return CONTENT_KEY_ID_CLAIM_TYPE;
+    }
+
+    /**
+     * @return the contentkeyidentifierclaim
+     */
+    public static TokenClaim getContentKeyIdentifierClaim() {
+        return CONTENT_KEY_ID_CLAIM;
+    }
+}
diff --git a/media/src/main/java/com/microsoft/windowsazure/services/media/implementation/templates/tokenrestriction/TokenType.java b/media/src/main/java/com/microsoft/windowsazure/services/media/implementation/templates/tokenrestriction/TokenType.java
new file mode 100644
index 0000000..719260b
--- /dev/null
+++ b/media/src/main/java/com/microsoft/windowsazure/services/media/implementation/templates/tokenrestriction/TokenType.java
@@ -0,0 +1,51 @@
+package com.microsoft.windowsazure.services.media.implementation.templates.tokenrestriction;
+
+import java.security.InvalidParameterException;
+
+import javax.xml.bind.annotation.XmlEnum;
+import javax.xml.bind.annotation.XmlEnumValue;
+import javax.xml.bind.annotation.XmlType;
+
+@XmlType
+@XmlEnum
+public enum TokenType {
+    
+    @XmlEnumValue("Undefined") Undefined(0),
+    @XmlEnumValue("SWT") SWT(1),
+    @XmlEnumValue("JWT") JWT(2);
+    
+    private int tokenType;
+    
+    private TokenType(int tokenType) {
+        this.tokenType = tokenType;
+    }
+    
+    /**
+     * Gets the code.
+     * 
+     * @return the code
+     */
+    public int getCode() {
+        return tokenType;
+    }
+    
+    /**
+     * From code.
+     * 
+     * @param code
+     *            the code
+     * @return the content key type
+     */
+    public static TokenType fromCode(int code) {
+        switch (code) {
+        case 0:
+            return TokenType.Undefined;
+        case 1:
+            return TokenType.SWT;
+        case 2:
+            return TokenType.JWT;
+        default:
+            throw new InvalidParameterException("code");
+        }
+    }
+}
diff --git a/media/src/main/java/com/microsoft/windowsazure/services/media/implementation/templates/tokenrestriction/TokenVerificationKey.java b/media/src/main/java/com/microsoft/windowsazure/services/media/implementation/templates/tokenrestriction/TokenVerificationKey.java
new file mode 100644
index 0000000..652e4b3
--- /dev/null
+++ b/media/src/main/java/com/microsoft/windowsazure/services/media/implementation/templates/tokenrestriction/TokenVerificationKey.java
@@ -0,0 +1,10 @@
+package com.microsoft.windowsazure.services.media.implementation.templates.tokenrestriction;
+
+import javax.xml.bind.annotation.XmlSeeAlso;
+import javax.xml.bind.annotation.XmlTransient;
+
+@XmlTransient
+@XmlSeeAlso({SymmetricVerificationKey.class, X509CertTokenVerificationKey.class})
+public abstract class TokenVerificationKey {
+
+}
diff --git a/media/src/main/java/com/microsoft/windowsazure/services/media/implementation/templates/tokenrestriction/X509CertTokenVerificationKey.java b/media/src/main/java/com/microsoft/windowsazure/services/media/implementation/templates/tokenrestriction/X509CertTokenVerificationKey.java
new file mode 100644
index 0000000..b8d57a5
--- /dev/null
+++ b/media/src/main/java/com/microsoft/windowsazure/services/media/implementation/templates/tokenrestriction/X509CertTokenVerificationKey.java
@@ -0,0 +1,57 @@
+package com.microsoft.windowsazure.services.media.implementation.templates.tokenrestriction;
+
+import java.io.ByteArrayInputStream;
+import java.security.cert.CertificateEncodingException;
+import java.security.cert.CertificateException;
+import java.security.cert.CertificateFactory;
+import java.security.cert.X509Certificate;
+
+import javax.xml.bind.annotation.XmlAccessType;
+import javax.xml.bind.annotation.XmlAccessorType;
+import javax.xml.bind.annotation.XmlTransient;
+import javax.xml.bind.annotation.XmlType;
+
+@XmlAccessorType(XmlAccessType.FIELD)
+@XmlType(name = "X509CertTokenVerificationKey")
+public class X509CertTokenVerificationKey extends AsymmetricTokenVerificationKey {
+
+    @XmlTransient
+    private X509Certificate x509Certificate;
+    
+    public X509CertTokenVerificationKey() {
+    }
+
+    public X509CertTokenVerificationKey(X509Certificate x509Certificate) throws CertificateEncodingException {
+        this.setX509Certificate(x509Certificate);
+        super.setRawBody(x509Certificate.getEncoded());
+    }
+
+    /**
+     * @return the x509Certificate
+     */
+    public X509Certificate getX509Certificate() {
+        return x509Certificate;
+    }
+
+    /**
+     * @param x509Certificate the x509Certificate to set
+     */
+    public void setX509Certificate(X509Certificate x509Certificate) {
+        this.x509Certificate = x509Certificate;
+    }
+    
+    @Override
+    public void setRawBody(byte[] rawBody) {
+        super.setRawBody(rawBody);
+        ByteArrayInputStream input = new ByteArrayInputStream(rawBody);
+        try {
+            this.x509Certificate = (X509Certificate)
+                    CertificateFactory.getInstance("X.509").generateCertificate(input);
+        } catch (CertificateException e) {
+            super.setRawBody(null);
+        }
+         
+    }
+    
+    
+}
diff --git a/media/src/main/java/com/microsoft/windowsazure/services/media/models/Asset.java b/media/src/main/java/com/microsoft/windowsazure/services/media/models/Asset.java
index ab493ff..617c95f 100644
--- a/media/src/main/java/com/microsoft/windowsazure/services/media/models/Asset.java
+++ b/media/src/main/java/com/microsoft/windowsazure/services/media/models/Asset.java
@@ -30,6 +30,7 @@ import com.microsoft.windowsazure.services.media.entityoperations.EntityLinkOper
 import com.microsoft.windowsazure.services.media.entityoperations.EntityOperationBase;
 import com.microsoft.windowsazure.services.media.entityoperations.EntityOperationSingleResultBase;
 import com.microsoft.windowsazure.services.media.entityoperations.EntityProxyData;
+import com.microsoft.windowsazure.services.media.entityoperations.EntityUnlinkOperation;
 import com.microsoft.windowsazure.services.media.entityoperations.EntityUpdateOperation;
 import com.microsoft.windowsazure.services.media.implementation.content.AssetType;
 import com.sun.jersey.api.client.GenericType;
@@ -70,7 +71,10 @@ public final class Asset {
         private String name;
 
         /** The alternate id. */
-        private String alternateId;
+        private String alternateId;        
+        
+        /** The Name of the storage account that contains the asset blob container.. */
+        private String storageAccountName;
 
         /** The options. */
         private AssetOption options;
@@ -96,6 +100,7 @@ public final class Asset {
             AssetType assetType = new AssetType();
             assetType.setName(name);
             assetType.setAlternateId(alternateId);
+            assetType.setStorageAccountName(storageAccountName);
             if (options != null) {
                 assetType.setOptions(options.getCode());
             }
@@ -153,6 +158,15 @@ public final class Asset {
             this.state = state;
             return this;
         }
+        
+        /**
+         * Sets Name of the storage account that contains the asset's blob container.
+         * @param storageAccountName Name of the storage account that contains the asset's blob container.
+         */
+        public Creator setStorageAccountName(String storageAccountName) {
+            this.storageAccountName = storageAccountName;
+            return this;
+        }
     }
 
     /**
@@ -189,7 +203,7 @@ public final class Asset {
                 new GenericType<ListResult<AssetInfo>>() {
                 });
     }
-
+De
     /**
      * Create an operation that will list all the assets at the given link.
      * 
@@ -319,7 +333,59 @@ public final class Asset {
         }
         URI contentKeyUri = URI.create(String.format("ContentKeys('%s')",
                 escapedContentKeyId));
-        return new EntityLinkOperation("Assets", assetId, "ContentKeys",
+        return new EntityLinkOperation(ENTITY_SET, assetId, "ContentKeys",
                 contentKeyUri);
     }
+    
+    /**
+     * unlink a content key.
+     * 
+     * @param assetId
+     *            the asset id
+     * @param contentKeyId
+     *            the content key id
+     * @return the entity action operation
+     */
+    public static EntityUnlinkOperation unlinkContentKey(String assetId,
+            String contentKeyId) {
+        return new EntityUnlinkOperation(ENTITY_SET, assetId, "ContentKeys", contentKeyId);
+    }
+    
+    /**
+     * Link delivery policy
+     * 
+     * @param assetId
+     *            the asset id
+     * @param deliveryPolicyId
+     *            the content key id
+     * @return the entity action operation
+     */
+    public static EntityLinkOperation linkDeliveryPolicy(String assetId,
+            String deliveryPolicyId) {
+        String escapedContentKeyId = null;
+        try {
+            escapedContentKeyId = URLEncoder.encode(deliveryPolicyId, "UTF-8");
+        } catch (UnsupportedEncodingException e) {
+            throw new InvalidParameterException("deliveryPolicyId");
+        }
+        URI contentKeyUri = URI.create(String.format("AssetDeliveryPolicies('%s')",
+                escapedContentKeyId));
+        return new EntityLinkOperation(ENTITY_SET, assetId, "DeliveryPolicies",
+                contentKeyUri);
+    }
+    
+    /**
+     * unlink an asset delivery policy
+     * 
+     * @param assetId
+     *            the asset id
+     * @param adpId
+     *            the asset delivery policy id
+     * @return the entity action operation
+     */
+    public static EntityUnlinkOperation unlinkDeliveryPolicy(String assetId,
+            String adpId) {
+        return new EntityUnlinkOperation(ENTITY_SET, assetId, "DeliveryPolicies", adpId);
+    }
+    
 }
diff --git a/media/src/main/java/com/microsoft/windowsazure/services/media/models/AssetInfo.java b/media/src/main/java/com/microsoft/windowsazure/services/media/models/AssetInfo.java
index 6fa05af..daa2e7c 100644
--- a/media/src/main/java/com/microsoft/windowsazure/services/media/models/AssetInfo.java
+++ b/media/src/main/java/com/microsoft/windowsazure/services/media/models/AssetInfo.java
@@ -101,6 +101,24 @@ public class AssetInfo extends ODataEntity<AssetType> {
     public AssetOption getOptions() {
         return AssetOption.fromCode(getContent().getOptions());
     }
+    
+    /**
+     * Get the URI of the blob storage container of the specified Asset.
+     * 
+     * @return the URI of the blob storage container of the specified Asset.
+     */
+    public String getUri() {
+        return getContent().getUri();
+    }
+    
+    /**
+     * Get the Name of the storage account that contains the assets blob container.
+     * 
+     * @return the Name of the storage account that contains the assets blob container.
+     */
+    public String getStorageAccountName() {
+        return getContent().getStorageAccountName();
+    }
 
     /**
      * Get a link to the asset's files
@@ -137,4 +155,13 @@ public class AssetInfo extends ODataEntity<AssetType> {
     public LinkInfo<AssetInfo> getParentAssetsLink() {
         return this.<AssetInfo> getRelationLink("ParentAssets");
     }
+    
+    /**
+     * Get a link to this asset's delivery policies
+     * 
+     * @return the link
+     */
+    public LinkInfo<AssetDeliveryPolicyInfo> getDeliveryPoliciesLink() {
+        return this.<AssetDeliveryPolicyInfo> getRelationLink("DeliveryPolicies");
+    }
 }
diff --git a/media/src/main/java/com/microsoft/windowsazure/services/media/models/ContentKey.java b/media/src/main/java/com/microsoft/windowsazure/services/media/models/ContentKey.java
index c78cdd8..3490fc6 100644
--- a/media/src/main/java/com/microsoft/windowsazure/services/media/models/ContentKey.java
+++ b/media/src/main/java/com/microsoft/windowsazure/services/media/models/ContentKey.java
@@ -20,13 +20,18 @@ import java.io.UnsupportedEncodingException;
 import java.net.URLEncoder;
 import java.security.InvalidParameterException;
 
+import javax.ws.rs.core.MediaType;
 import javax.xml.bind.JAXBContext;
 import javax.xml.bind.JAXBElement;
 import javax.xml.bind.JAXBException;
 import javax.xml.bind.Unmarshaller;
 import javax.xml.transform.stream.StreamSource;
 
+import org.codehaus.jettison.json.JSONException;
+import org.codehaus.jettison.json.JSONObject;
+
 import com.microsoft.windowsazure.core.pipeline.PipelineHelpers;
+import com.microsoft.windowsazure.exception.ServiceException;
 import com.microsoft.windowsazure.services.media.entityoperations.DefaultDeleteOperation;
 import com.microsoft.windowsazure.services.media.entityoperations.DefaultEntityTypeActionOperation;
 import com.microsoft.windowsazure.services.media.entityoperations.DefaultGetOperation;
@@ -34,8 +39,10 @@ import com.microsoft.windowsazure.services.media.entityoperations.DefaultListOpe
 import com.microsoft.windowsazure.services.media.entityoperations.EntityCreateOperation;
 import com.microsoft.windowsazure.services.media.entityoperations.EntityDeleteOperation;
 import com.microsoft.windowsazure.services.media.entityoperations.EntityGetOperation;
+import com.microsoft.windowsazure.services.media.entityoperations.EntityOperationBase;
 import com.microsoft.windowsazure.services.media.entityoperations.EntityOperationSingleResultBase;
 import com.microsoft.windowsazure.services.media.entityoperations.EntityTypeActionOperation;
+import com.microsoft.windowsazure.services.media.entityoperations.EntityUpdateOperation;
 import com.microsoft.windowsazure.services.media.implementation.content.ContentKeyRestType;
 import com.microsoft.windowsazure.services.media.implementation.content.RebindContentKeyType;
 import com.sun.jersey.api.client.ClientResponse;
@@ -323,4 +330,99 @@ public final class ContentKey {
         }
 
     }
+    
+    
+    public static KeyDeliveryUrlGetter getKeyDeliveryUrl(String contentKeyId, ContentKeyDeliveryType contentKeyDeliveryType) {
+        return new KeyDeliveryUrlGetter(contentKeyId, contentKeyDeliveryType);
+    }
+    
+    private static class KeyDeliveryUrlGetter extends
+            EntityOperationSingleResultBase<String> implements
+            EntityCreateOperation<String> {
+        /** The contentKeyId */
+        private final String contentKeyId;
+     
+        /** content Key delivery type */
+        private final ContentKeyDeliveryType contentKeyDeliveryType;
+        
+        public KeyDeliveryUrlGetter(String contentKeyId,
+                ContentKeyDeliveryType contentKeyDeliveryType) {
+            super(ENTITY_SET, String.class);
+            
+            this.contentKeyId = contentKeyId;
+            this.contentKeyDeliveryType = contentKeyDeliveryType;
+        }
+                
+        @Override
+        public String getUri() {
+            String escapedEntityId;
+            try {
+                escapedEntityId = URLEncoder.encode(contentKeyId, "UTF-8");
+            } catch (UnsupportedEncodingException e) {
+                throw new InvalidParameterException(
+                        "UTF-8 encoding is not supported.");
+            }
+            return String.format("%s('%s')/GetKeyDeliveryUrl", ENTITY_SET, escapedEntityId);
+        }
+
+        @Override
+        public Object getRequestContents() throws ServiceException {
+            String document = "{\"keyDeliveryType\": " + contentKeyDeliveryType.getCode() + "}";
+            return document;
+        }
+        
+        @Override
+        public MediaType getContentType() {
+            return MediaType.APPLICATION_JSON_TYPE;
+        }
+        
+        @Override
+        public MediaType getAcceptType() {
+            return MediaType.APPLICATION_JSON_TYPE;
+        }
+
+        @Override
+        public Object processResponse(Object rawResponse) throws ServiceException {
+            try {
+                JSONObject object = new JSONObject(rawResponse.toString());
+                return object.getString("value");
+            } catch (JSONException e) {
+                throw new ServiceException(e);
+            }
+        }        
+    }    
+    
+    /** Updates a ContentKey with an ContentKeyAuthorizationPolicyId
+     * 
+     * @param contentKeyId  The id of the ContentKey to be updated.
+     * @param contentKeyAuthorizationPolicyId The id of the ContentKeyAuthorizationPolicy
+     * @return Entity Operation
+     */
+    public static Updater update(String contentKeyId, String contentKeyAuthorizationPolicyId) {
+        return new Updater(contentKeyId, contentKeyAuthorizationPolicyId);
+    }
+    
+    public static class Updater extends EntityOperationBase implements
+        EntityUpdateOperation {
+        
+        String contentKeyAuthorizationPolicyId;
+        
+        protected Updater(String contentKeyId, String contentKeyAuthorizationPolicyId) {
+            super(new EntityOperationBase.EntityIdUriBuilder(ENTITY_SET,
+                    contentKeyId));            
+            this.contentKeyAuthorizationPolicyId = contentKeyAuthorizationPolicyId;
+        }
+        
+        @Override
+        public MediaType getContentType() {
+            return MediaType.APPLICATION_JSON_TYPE;
+        }
+        
+        @Override
+        public Object getRequestContents() {
+            String document = "{\"AuthorizationPolicyId\":\"" + contentKeyAuthorizationPolicyId + "\"}";
+            return document;
+        }
+
+    }
 }
diff --git a/media/src/main/java/com/microsoft/windowsazure/services/media/models/ContentKeyDeliveryType.java b/media/src/main/java/com/microsoft/windowsazure/services/media/models/ContentKeyDeliveryType.java
new file mode 100644
index 0000000..683466b
--- /dev/null
+++ b/media/src/main/java/com/microsoft/windowsazure/services/media/models/ContentKeyDeliveryType.java
@@ -0,0 +1,73 @@
+/*
+ * Copyright Microsoft Corporation
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.microsoft.windowsazure.services.media.models;
+
+import java.security.InvalidParameterException;
+
+/**
+ * Specifies the AssetDeliveryPolicyType.
+ */
+public enum ContentKeyDeliveryType {
+
+    /** None. */
+    None(0),
+    /** Use PlayReady License acquisition protocol. */
+    PlayReadyLicense(1),
+    /** Use MPEG Baseline HTTP key protocol. */
+    BaselineHttp(2);
+    
+    /** The AssetDeliveryPolicyType code. */
+    private int contentKeyDeliveryType;
+
+    /**
+     * Instantiates a new ContentKeyDeliveryType.
+     * 
+     * @param contentKeyDeliveryType
+     *            the ContentKeyDeliveryType code
+     */
+    private ContentKeyDeliveryType(int contentKeyDeliveryType) {
+        this.contentKeyDeliveryType = contentKeyDeliveryType;
+    }
+
+    /**
+     * Gets the code.
+     * 
+     * @return the code
+     */
+    public int getCode() {
+        return contentKeyDeliveryType;
+    }
+
+    /**
+     * Create an AssetDeliveryPolicyConfigurationKey instance based on the given integer.
+     * 
+     * @param option
+     *            the integer value of option
+     * @return The AssetDeliveryPolicyType
+     */
+    public static ContentKeyDeliveryType fromCode(int option) {
+        switch (option) {
+        case 0:
+            return ContentKeyDeliveryType.None;
+        case 1:
+            return ContentKeyDeliveryType.PlayReadyLicense;
+        case 2:
+            return ContentKeyDeliveryType.BaselineHttp;
+        default:
+            throw new InvalidParameterException("option");
+        }
+    }
+}
diff --git a/media/src/main/java/com/microsoft/windowsazure/services/media/models/ContentKeyInfo.java b/media/src/main/java/com/microsoft/windowsazure/services/media/models/ContentKeyInfo.java
index 33e018d..ec4666e 100644
--- a/media/src/main/java/com/microsoft/windowsazure/services/media/models/ContentKeyInfo.java
+++ b/media/src/main/java/com/microsoft/windowsazure/services/media/models/ContentKeyInfo.java
@@ -111,6 +111,15 @@ public class ContentKeyInfo extends ODataEntity<ContentKeyRestType> {
     }
 
     /**
+     * Gets the authorization policy id.
+     * 
+     * @return the authorization policy id
+     */
+    public String getAuthorizationPolicyId() {
+        return getContent().getAuthorizationPolicyId();
+    }
+
+    /**
      * Gets the content key type.
      * 
      * @return the content key type
diff --git a/media/src/main/java/com/microsoft/windowsazure/services/media/models/ContentKeyType.java b/media/src/main/java/com/microsoft/windowsazure/services/media/models/ContentKeyType.java
index 8cd0f5d..9c801ad 100644
--- a/media/src/main/java/com/microsoft/windowsazure/services/media/models/ContentKeyType.java
+++ b/media/src/main/java/com/microsoft/windowsazure/services/media/models/ContentKeyType.java
@@ -29,7 +29,9 @@ public enum ContentKeyType {
     /** The Storage encryption. */
     StorageEncryption(1),
     /** The Configuration encryption. */
-    ConfigurationEncryption(2);
+    ConfigurationEncryption(2),
+    /** The Envelope encryption. */
+    EnvelopeEncryption(4);
 
     /** The content key type code. */
     private int contentKeyTypeCode;
@@ -68,6 +70,8 @@ public enum ContentKeyType {
             return ContentKeyType.StorageEncryption;
         case 2:
             return ContentKeyType.ConfigurationEncryption;
+        case 4: 
+            return ContentKeyType.EnvelopeEncryption;
         default:
             throw new InvalidParameterException("code");
         }
diff --git a/media/src/test/java/com/microsoft/windowsazure/services/media/contentprotection/ContentKeyAuthorizationPolicyRestrictionTest.java b/media/src/test/java/com/microsoft/windowsazure/services/media/contentprotection/ContentKeyAuthorizationPolicyRestrictionTest.java
new file mode 100644
index 0000000..3c3d3c8
--- /dev/null
+++ b/media/src/test/java/com/microsoft/windowsazure/services/media/contentprotection/ContentKeyAuthorizationPolicyRestrictionTest.java
@@ -0,0 +1,56 @@
+/**
+ * Copyright Microsoft Corporation
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.microsoft.windowsazure.services.media.contentprotection;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertNull;
+
+import java.net.URLEncoder;
+
+import org.junit.Test;
+
+import com.microsoft.windowsazure.exception.ServiceException;
+import com.microsoft.windowsazure.services.media.entityoperations.EntityDeleteOperation;
+import com.microsoft.windowsazure.services.media.entityoperations.EntityGetOperation;
+import com.microsoft.windowsazure.services.media.entityoperations.EntityListOperation;
+import com.microsoft.windowsazure.services.media.implementation.content.ContentKeyAuthorizationPolicyType;
+import com.microsoft.windowsazure.services.media.implementation.templates.tokenrestriction.TokenType;
+import com.microsoft.windowsazure.services.media.models.ContentKeyAuthorizationPolicy;
+import com.microsoft.windowsazure.services.media.models.ContentKeyAuthorizationPolicyInfo;
+import com.microsoft.windowsazure.services.media.models.ContentKeyAuthorizationPolicyRestriction;
+
+/**
+ * Tests for the methods and factories of the Asset entity.
+ */
+public class ContentKeyAuthorizationPolicyRestrictionTest {
+	
+    @Test
+    public void roundTripTest() {
+        // provides full code coverage
+        assertEquals(ContentKeyAuthorizationPolicyRestriction.ContentKeyRestrictionType.Open, ContentKeyAuthorizationPolicyRestriction.ContentKeyRestrictionType.valueOf("Open"));
+        assertEquals(ContentKeyAuthorizationPolicyRestriction.ContentKeyRestrictionType.TokenRestricted, ContentKeyAuthorizationPolicyRestriction.ContentKeyRestrictionType.valueOf("TokenRestricted"));
+        assertEquals(ContentKeyAuthorizationPolicyRestriction.ContentKeyRestrictionType.IPRestricted, ContentKeyAuthorizationPolicyRestriction.ContentKeyRestrictionType.valueOf("IPRestricted"));        
+    }
+    
+    @Test
+    public void getValueOfContentKeyRestrictionTypeTest() {
+        // provides full code coverage
+        assertEquals(ContentKeyAuthorizationPolicyRestriction.ContentKeyRestrictionType.Open.getValue(), 0);
+        assertEquals(ContentKeyAuthorizationPolicyRestriction.ContentKeyRestrictionType.TokenRestricted.getValue(), 1);
+        assertEquals(ContentKeyAuthorizationPolicyRestriction.ContentKeyRestrictionType.IPRestricted.getValue(), 2);        
+    }
+}
diff --git a/media/src/test/java/com/microsoft/windowsazure/services/media/implementation/templates/tokenrestriction/SymmetricVerificationKeyTests.java b/media/src/test/java/com/microsoft/windowsazure/services/media/implementation/templates/tokenrestriction/SymmetricVerificationKeyTests.java
new file mode 100644
index 0000000..4babf0a
--- /dev/null
+++ b/media/src/test/java/com/microsoft/windowsazure/services/media/implementation/templates/tokenrestriction/SymmetricVerificationKeyTests.java
@@ -0,0 +1,52 @@
+package com.microsoft.windowsazure.services.media.implementation.templates.tokenrestriction;
+
+import static org.junit.Assert.*;
+
+import org.junit.Test;
+
+import com.microsoft.windowsazure.services.media.implementation.templates.tokenrestriction.SymmetricVerificationKey;
+
+public class SymmetricVerificationKeyTests {
+    
+    @Test
+    public void NewSymmetricVerificationKeyShouldCreateNewKey() {
+        // Arrange
+        SymmetricVerificationKey key = new SymmetricVerificationKey();
+        
+        // Act
+        byte[] resultKey = key.getKeyValue();
+        
+        // Assert
+        assertNotNull(resultKey);
+    }
+    
+    @Test
+    public void GetterSetterSymmetricVerificationKey() {
+        // Arrange
+        SymmetricVerificationKey key = new SymmetricVerificationKey();
+        byte[] keyValue = key.getKeyValue();
+        
+        // Act
+        SymmetricVerificationKey key2 = new SymmetricVerificationKey();
+        key2.setKeyValue(keyValue);
+        byte[] resultsValue = key2.getKeyValue();
+        
+        // Assert
+        assertArrayEquals(keyValue, resultsValue);
+    }
+    
+    @Test
+    public void KeyInConstructorSymmetricVerificationKeyShouldMatch() {
+        // Arrange
+        SymmetricVerificationKey key = new SymmetricVerificationKey();
+        byte[] keyValue = key.getKeyValue();
+        
+        // Act
+        SymmetricVerificationKey key2 = new SymmetricVerificationKey(keyValue);
+        byte[] resultsValue = key2.getKeyValue();
+        
+        // Assert
+        assertArrayEquals(keyValue, resultsValue);
+    }
+    
+}
diff --git a/media/src/test/java/com/microsoft/windowsazure/services/media/implementation/templates/tokenrestriction/TokenClaimTests.java b/media/src/test/java/com/microsoft/windowsazure/services/media/implementation/templates/tokenrestriction/TokenClaimTests.java
new file mode 100644
index 0000000..57e415a
--- /dev/null
+++ b/media/src/test/java/com/microsoft/windowsazure/services/media/implementation/templates/tokenrestriction/TokenClaimTests.java
@@ -0,0 +1,74 @@
+package com.microsoft.windowsazure.services.media.implementation.templates.tokenrestriction;
+
+import static org.junit.Assert.*;
+
+import java.security.InvalidParameterException;
+import org.junit.Test;
+
+import com.microsoft.windowsazure.services.media.implementation.templates.tokenrestriction.TokenType;
+
+public class TokenClaimTests {
+    
+    @Test
+    public void defaultConstructorTest() {
+        // Arrange and Act
+        TokenClaim value = new TokenClaim();
+        // Asset
+        assertNotNull(value);
+    }
+
+    @Test
+    public void constructorTest() {
+        // Arrange
+        String expectedType = "type";
+        String expectedValue = "value";
+        // Act
+        TokenClaim value = new TokenClaim(expectedType, expectedValue);
+
+        // Assert
+        assertNotNull(value);
+        assertEquals(value.getClaimType(), expectedType);
+        assertEquals(value.getClaimValue(), expectedValue);
+    }
+
+    @Test
+    public void nullInConstructorShouldThrownTest() {
+     // Arrange
+        String providedType = null;
+        String expectedValue = "value";
+        
+        // Act
+        try { 
+            TokenClaim value = new TokenClaim(providedType, expectedValue);
+            fail("Should thrown");
+        } catch (NullPointerException e) {
+            // Assert
+            assertTrue(e.getMessage().contains("claimType"));
+        }
+    }
+    
+    @Test
+    public void staticValuesTest() {
+        // Arrange
+        String expectedTokenClaimType = "urn:microsoft:azure:mediaservices:contentkeyidentifier";
+
+        // Act
+        String results = TokenClaim.getContentKeyIdentifierClaimType();
+
+        // Assert
+        assertEquals(results, expectedTokenClaimType);
+    }
+    
+    @Test
+    public void staticValues2Test() {
+        // Arrange
+        String expectedTokenClaimType = "urn:microsoft:azure:mediaservices:contentkeyidentifier";
+        TokenClaim claim = TokenClaim.getContentKeyIdentifierClaim();
+        
+        // Act
+        String results = claim.getClaimType();
+
+        // Assert
+        assertEquals(results, expectedTokenClaimType);
+    }
+}
diff --git a/media/src/test/java/com/microsoft/windowsazure/services/media/implementation/templates/tokenrestriction/TokenTypeTests.java b/media/src/test/java/com/microsoft/windowsazure/services/media/implementation/templates/tokenrestriction/TokenTypeTests.java
new file mode 100644
index 0000000..08a4758
--- /dev/null
+++ b/media/src/test/java/com/microsoft/windowsazure/services/media/implementation/templates/tokenrestriction/TokenTypeTests.java
@@ -0,0 +1,84 @@
+package com.microsoft.windowsazure.services.media.implementation.templates.tokenrestriction;
+
+import static org.junit.Assert.*;
+
+import java.security.InvalidParameterException;
+import org.junit.Test;
+
+import com.microsoft.windowsazure.services.media.implementation.templates.tokenrestriction.TokenType;
+
+public class TokenTypeTests {
+
+    @Test
+    public void valueOfUndefinedTokenTypeTests() {
+        // provides full code coverage
+        assertEquals(TokenType.Undefined, TokenType.valueOf("Undefined"));
+        assertEquals(TokenType.SWT, TokenType.valueOf("SWT"));
+        assertEquals(TokenType.JWT, TokenType.valueOf("JWT"));
+    }
+
+    @Test
+    public void fromCodeUndefinedTokenTypeTests() {
+        // Arrange
+        TokenType expectedTokenType = TokenType.Undefined;
+
+        // Act
+        TokenType tokenTypeResult = TokenType.fromCode(0);
+
+        // Assert
+        assertEquals(tokenTypeResult, expectedTokenType);
+    }
+
+    @Test
+    public void fromCodeSWTTokenTypeTests() {
+        // Arrange
+        TokenType expectedTokenType = TokenType.SWT;
+
+        // Act
+        TokenType tokenTypeResult = TokenType.fromCode(1);
+
+        // Assert
+        assertEquals(tokenTypeResult, expectedTokenType);
+    }
+
+    @Test
+    public void fromCodeJWTTokenTypeTests() {
+        // Arrange
+        TokenType expectedTokenType = TokenType.JWT;
+
+        // Act
+        TokenType tokenTypeResult = TokenType.fromCode(2);
+
+        // Assert
+        assertEquals(tokenTypeResult, expectedTokenType);
+    }
+
+    @Test
+    public void fromCodeInvalidTokenTypeTests() {
+        // Arrange
+        int invalidCode = 666;
+        String expectedMessage = "code";
+        // Act
+        try {
+            @SuppressWarnings("unused")
+            TokenType tokenTypeResult = TokenType.fromCode(invalidCode);
+            fail("Should throw");
+        } catch (InvalidParameterException e) {
+            // Assert
+            assertEquals(e.getMessage(), expectedMessage);
+        }
+    }
+
+    @Test
+    public void getCodeJWTTokenTypeTests() {
+        // Arrange
+        int expectedCode = 2;
+
+        // Act
+        TokenType tokenTypeResult = TokenType.JWT;
+        int resultCode = tokenTypeResult.getCode();
+
+        // Assert
+        assertEquals(resultCode, expectedCode);
+    }
+}
diff --git a/media/src/test/java/com/microsoft/windowsazure/services/media/implementation/templates/tokenrestriction/X509CertTokenVerificationKeyTests.java b/media/src/test/java/com/microsoft/windowsazure/services/media/implementation/templates/tokenrestriction/X509CertTokenVerificationKeyTests.java
new file mode 100644
index 0000000..91e3d6a
--- /dev/null
+++ b/media/src/test/java/com/microsoft/windowsazure/services/media/implementation/templates/tokenrestriction/X509CertTokenVerificationKeyTests.java
@@ -0,0 +1,102 @@
+package com.microsoft.windowsazure.services.media.implementation.templates.tokenrestriction;
+
+import static org.junit.Assert.*;
+
+import java.io.BufferedInputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.net.URL;
+import java.security.cert.CertificateException;
+import java.security.cert.CertificateFactory;
+import java.security.cert.X509Certificate;
+
+import org.junit.Test;
+
+import com.microsoft.windowsazure.services.media.implementation.templates.tokenrestriction.X509CertTokenVerificationKey;
+
+public class X509CertTokenVerificationKeyTests {
+    
+    private final URL certFileName = getClass().getResource("/certificate/server.crt");
+    
+    @Test
+    public void EmptyX509Certificate() {
+        // Arrange
+        X509CertTokenVerificationKey certKey = new X509CertTokenVerificationKey();
+        
+        // Act
+        X509Certificate cert = certKey.getX509Certificate();
+        
+        // Assert
+        assertNull(cert);
+    }
+
+    @Test
+    public void X509CertificateInConstructorShouldExists() throws CertificateException, IOException {
+        // Arrange
+        InputStream certFile = certFileName.openStream();
+        BufferedInputStream certInStream = new BufferedInputStream(certFile);
+        X509Certificate cert = (X509Certificate)
+                CertificateFactory.getInstance("X.509").generateCertificate(certInStream);
+        
+        // Act
+        X509CertTokenVerificationKey certKey = new X509CertTokenVerificationKey(cert);
+        X509Certificate resultCert = certKey.getX509Certificate();
+        
+        // Assert
+        assertNotNull(resultCert);
+        assertEquals(cert, resultCert);
+    }
+    
+    @Test
+    public void GetterSetterX509Certificate() throws CertificateException, IOException {
+        // Arrange
+        InputStream certFile = certFileName.openStream();
+        BufferedInputStream certInStream = new BufferedInputStream(certFile);
+        X509Certificate cert = (X509Certificate)
+                CertificateFactory.getInstance("X.509").generateCertificate(certInStream);
+        
+        // Act
+        X509CertTokenVerificationKey certKey = new X509CertTokenVerificationKey();
+        certKey.setX509Certificate(cert);
+        X509Certificate resultCert = certKey.getX509Certificate();
+        
+        // Assert
+        assertNotNull(resultCert);
+        assertEquals(cert, resultCert);
+    }
+    
+    @Test
+    public void RawBodyOfX509CertificateShouldMatch() throws CertificateException, IOException {
+        // Arrange
+        InputStream certFile = certFileName.openStream();
+        BufferedInputStream certInStream = new BufferedInputStream(certFile);
+        X509Certificate cert = (X509Certificate)
+                CertificateFactory.getInstance("X.509").generateCertificate(certInStream);
+        X509CertTokenVerificationKey certKey = new X509CertTokenVerificationKey(cert);
+        
+        // Act        
+        byte[] rawBody = certKey.getRawBody();
+        X509CertTokenVerificationKey secondCertKey = new X509CertTokenVerificationKey();
+        secondCertKey.setRawBody(rawBody);
+        X509Certificate resultCert = secondCertKey.getX509Certificate();
+        
+        // Assert
+        assertNotNull(resultCert);
+        assertEquals(cert, resultCert);
+    }
+    
+    @Test
+    public void InvalidRawBodyOfX509CertificateShouldNullRawBody() throws CertificateException, IOException {
+        // Arrange
+        X509CertTokenVerificationKey certKey = new X509CertTokenVerificationKey();
+        
+        // Act
+        certKey.setRawBody("invalid rawbody".getBytes());
+        byte[] resultRawBody = certKey.getRawBody();
+        
+        // Assert
+        assertNull(resultRawBody);
+    }
+    
+    
+}
diff --git a/media/src/test/java/com/microsoft/windowsazure/services/media/models/ContentKeyInfoTest.java b/media/src/test/java/com/microsoft/windowsazure/services/media/models/ContentKeyInfoTest.java
index d75cedd..bf609b3 100644
--- a/media/src/test/java/com/microsoft/windowsazure/services/media/models/ContentKeyInfoTest.java
+++ b/media/src/test/java/com/microsoft/windowsazure/services/media/models/ContentKeyInfoTest.java
@@ -160,5 +160,19 @@ public class ContentKeyInfoTest {
         assertEquals(expectedCheckSum, actualCheckSum);
 
     }
+    
+    @Test
+    public void testGetSetAuthorizationPolicyId() {
+        // Arrange
+        String expectedAuthorizationPolicyId = "testAuthorizationPolicyId";
+        ContentKeyInfo contentKeyInfo = new ContentKeyInfo(null,
+                new ContentKeyRestType().setAuthorizationPolicyId(expectedAuthorizationPolicyId));
+
+        // Act
+        String actualAuthorizationPolicyId = contentKeyInfo.getAuthorizationPolicyId();
+
+        // Assert
+        assertEquals(expectedAuthorizationPolicyId, actualAuthorizationPolicyId);
+    }
 
 }
-- 
1.9.5.msysgit.1


From 6f95223ac2c5e0e6141da039bcae2b9754902e3f Mon Sep 17 00:00:00 2001
From: Emanuel Vecchio <vecchioemanuel@gmail.com>
Date: Wed, 22 Jul 2015 09:46:29 -0300
Subject: [PATCH 04/21] Garbage removed from Asset.java.

---
 .../java/com/microsoft/windowsazure/services/media/models/Asset.java    | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/media/src/main/java/com/microsoft/windowsazure/services/media/models/Asset.java b/media/src/main/java/com/microsoft/windowsazure/services/media/models/Asset.java
index 617c95f..362e2e7 100644
--- a/media/src/main/java/com/microsoft/windowsazure/services/media/models/Asset.java
+++ b/media/src/main/java/com/microsoft/windowsazure/services/media/models/Asset.java
@@ -203,7 +203,7 @@ public final class Asset {
                 new GenericType<ListResult<AssetInfo>>() {
                 });
     }
-De
+
     /**
      * Create an operation that will list all the assets at the given link.
      * 
-- 
1.9.5.msysgit.1


From d4c39c1f15f96f89d55168df6680e770731ee8f1 Mon Sep 17 00:00:00 2001
From: Emanuel Vecchio <vecchioemanuel@gmail.com>
Date: Wed, 22 Jul 2015 17:45:14 -0300
Subject: [PATCH 05/21] Added support for the following new entities:

TokenRestrictionTemplate, UnknownOutputPassingOption,
ExplicitAnalogTelevisionRestriction, AgcAndColorStripeRestriction,
ScmsRestriction, PlayReadyContentKey , ContentEncryptionKeyFromHeader,
ContentEncryptionKeyFromKeyIdentifier and PlayReadyLicenseType.

Additionally, we added the TokenRestrictionTemplateSerializer helper
class which includes GenerateTestToken method to issue a test token for
both SWT and JWT formats.

Also we've fixed the checkstyle.xml due breaking changes in current
version.
---
 media/pom.xml                                      |  23 ++-
 .../AgcAndColorStripeRestriction.java              |  30 +++
 .../ContentEncryptionKeyFromHeader.java            |  11 ++
 .../ContentEncryptionKeyFromKeyIdentifier.java     |  45 +++++
 .../templates/playreadylicense/ErrorMessages.java  |  41 ++++
 .../ExplicitAnalogTelevisionRestriction.java       |  51 +++++
 .../playreadylicense/PlayReadyContentKey.java      |  10 +
 .../playreadylicense/PlayReadyLicenseType.java     |  48 +++++
 .../playreadylicense/ScmsRestriction.java          |  36 ++++
 .../UnknownOutputPassingOption.java                |  51 +++++
 .../templates/playreadylicense/package-info.java   |   7 +
 .../tokenrestriction/TokenRestrictionTemplate.java | 149 ++++++++++++++
 .../TokenRestrictionTemplateSerializer.java        | 200 +++++++++++++++++++
 .../templates/tokenrestriction/package-info.java   |   7 +
 .../services/media/models/ContentKey.java          |   2 +-
 .../AgcAndColorStripeRestrictionTests.java         |  44 +++++
 .../ExplicitAnalogTelevisionRestrictionTests.java  |  64 ++++++
 .../playreadylicense/PlayReadyContentKeyTests.java |  71 +++++++
 .../PlayReadyLicenseTypeTests.java                 |  71 +++++++
 .../playreadylicense/ScmsRestrictionTests.java     |  43 ++++
 .../UnknownOutputPassingOptionTests.java           |  86 ++++++++
 .../TokenRestrictionTemplateSerializerTests.java   | 188 ++++++++++++++++++
 .../schemas/PlayReadyLicenseResponseTemplate.xsd   | 220 +++++++++++++++++++++
 .../resources/schemas/TokenRestrictionTemplate.xsd |  46 +++++
 parent/src/config/checkstyle.xml                   |   6 +-
 25 files changed, 1543 insertions(+), 7 deletions(-)
 create mode 100644 media/src/main/java/com/microsoft/windowsazure/services/media/implementation/templates/playreadylicense/AgcAndColorStripeRestriction.java
 create mode 100644 media/src/main/java/com/microsoft/windowsazure/services/media/implementation/templates/playreadylicense/ContentEncryptionKeyFromHeader.java
 create mode 100644 media/src/main/java/com/microsoft/windowsazure/services/media/implementation/templates/playreadylicense/ContentEncryptionKeyFromKeyIdentifier.java
 create mode 100644 media/src/main/java/com/microsoft/windowsazure/services/media/implementation/templates/playreadylicense/ErrorMessages.java
 create mode 100644 media/src/main/java/com/microsoft/windowsazure/services/media/implementation/templates/playreadylicense/ExplicitAnalogTelevisionRestriction.java
 create mode 100644 media/src/main/java/com/microsoft/windowsazure/services/media/implementation/templates/playreadylicense/PlayReadyContentKey.java
 create mode 100644 media/src/main/java/com/microsoft/windowsazure/services/media/implementation/templates/playreadylicense/PlayReadyLicenseType.java
 create mode 100644 media/src/main/java/com/microsoft/windowsazure/services/media/implementation/templates/playreadylicense/ScmsRestriction.java
 create mode 100644 media/src/main/java/com/microsoft/windowsazure/services/media/implementation/templates/playreadylicense/UnknownOutputPassingOption.java
 create mode 100644 media/src/main/java/com/microsoft/windowsazure/services/media/implementation/templates/playreadylicense/package-info.java
 create mode 100644 media/src/main/java/com/microsoft/windowsazure/services/media/implementation/templates/tokenrestriction/TokenRestrictionTemplate.java
 create mode 100644 media/src/main/java/com/microsoft/windowsazure/services/media/implementation/templates/tokenrestriction/TokenRestrictionTemplateSerializer.java
 create mode 100644 media/src/main/java/com/microsoft/windowsazure/services/media/implementation/templates/tokenrestriction/package-info.java
 create mode 100644 media/src/test/java/com/microsoft/windowsazure/services/media/implementation/templates/playreadylicense/AgcAndColorStripeRestrictionTests.java
 create mode 100644 media/src/test/java/com/microsoft/windowsazure/services/media/implementation/templates/playreadylicense/ExplicitAnalogTelevisionRestrictionTests.java
 create mode 100644 media/src/test/java/com/microsoft/windowsazure/services/media/implementation/templates/playreadylicense/PlayReadyContentKeyTests.java
 create mode 100644 media/src/test/java/com/microsoft/windowsazure/services/media/implementation/templates/playreadylicense/PlayReadyLicenseTypeTests.java
 create mode 100644 media/src/test/java/com/microsoft/windowsazure/services/media/implementation/templates/playreadylicense/ScmsRestrictionTests.java
 create mode 100644 media/src/test/java/com/microsoft/windowsazure/services/media/implementation/templates/playreadylicense/UnknownOutputPassingOptionTests.java
 create mode 100644 media/src/test/java/com/microsoft/windowsazure/services/media/implementation/templates/tokenrestriction/TokenRestrictionTemplateSerializerTests.java
 create mode 100644 media/src/test/resources/schemas/PlayReadyLicenseResponseTemplate.xsd
 create mode 100644 media/src/test/resources/schemas/TokenRestrictionTemplate.xsd

diff --git a/media/pom.xml b/media/pom.xml
index a1df6eb..e4bf830 100644
--- a/media/pom.xml
+++ b/media/pom.xml
@@ -45,6 +45,8 @@
   <properties>
     <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
     <legal><![CDATA[[INFO] Any downloads listed may be third party software.  Microsoft grants you no rights for third party software.]]></legal>
+    <jjwt.version>0.5.1</jjwt.version>
+    <jackson.version>2.6.0</jackson.version>
   </properties>
 
   <developers>
@@ -88,8 +90,27 @@
     <dependency>
       <groupId>commons-logging</groupId>
       <artifactId>commons-logging</artifactId>
+    </dependency>    
+    <dependency>
+	  <groupId>com.fasterxml.jackson.core</groupId>
+	  <artifactId>jackson-databind</artifactId>
+	  <version>${jackson.version}</version>
+	</dependency>
+	<dependency>
+      <groupId>com.fasterxml.jackson.core</groupId>
+      <artifactId>jackson-annotations</artifactId>
+     <version>${jackson.version}</version>
+    </dependency>
+    <dependency>
+      <groupId>com.fasterxml.jackson.core</groupId>
+      <artifactId>jackson-core</artifactId>
+      <version>${jackson.version}</version>
+    </dependency>
+    <dependency>
+      <groupId>io.jsonwebtoken</groupId>
+      <artifactId>jjwt</artifactId>
+      <version>${jjwt.version}</version>
     </dependency>
-
     <!-- Test dependencies -->
     <dependency>
       <groupId>org.hamcrest</groupId>
diff --git a/media/src/main/java/com/microsoft/windowsazure/services/media/implementation/templates/playreadylicense/AgcAndColorStripeRestriction.java b/media/src/main/java/com/microsoft/windowsazure/services/media/implementation/templates/playreadylicense/AgcAndColorStripeRestriction.java
new file mode 100644
index 0000000..e0e5825
--- /dev/null
+++ b/media/src/main/java/com/microsoft/windowsazure/services/media/implementation/templates/playreadylicense/AgcAndColorStripeRestriction.java
@@ -0,0 +1,30 @@
+package com.microsoft.windowsazure.services.media.implementation.templates.playreadylicense;
+
+import javax.xml.bind.annotation.XmlAccessType;
+import javax.xml.bind.annotation.XmlAccessorType;
+import javax.xml.bind.annotation.XmlElement;
+import javax.xml.bind.annotation.XmlType;
+
+@XmlAccessorType(XmlAccessType.FIELD)
+@XmlType(name = "AgcAndColorStripeRestriction")
+public class AgcAndColorStripeRestriction {
+
+    @XmlElement(name = "ConfigurationData")
+    private byte configurationData;
+    
+    @SuppressWarnings("unused")
+    private AgcAndColorStripeRestriction() {        
+    }
+
+    public AgcAndColorStripeRestriction(byte configurationData) {
+        ScmsRestriction.verifyTwoBitConfigurationData(configurationData);
+        this.configurationData = configurationData;
+    }
+
+    /**
+     * @return the configurationData
+     */
+    public byte getConfigurationData() {
+        return configurationData;
+    }    
+}
diff --git a/media/src/main/java/com/microsoft/windowsazure/services/media/implementation/templates/playreadylicense/ContentEncryptionKeyFromHeader.java b/media/src/main/java/com/microsoft/windowsazure/services/media/implementation/templates/playreadylicense/ContentEncryptionKeyFromHeader.java
new file mode 100644
index 0000000..018bd0a
--- /dev/null
+++ b/media/src/main/java/com/microsoft/windowsazure/services/media/implementation/templates/playreadylicense/ContentEncryptionKeyFromHeader.java
@@ -0,0 +1,11 @@
+package com.microsoft.windowsazure.services.media.implementation.templates.playreadylicense;
+
+import javax.xml.bind.annotation.XmlAccessType;
+import javax.xml.bind.annotation.XmlAccessorType;
+import javax.xml.bind.annotation.XmlType;
+
+@XmlAccessorType(XmlAccessType.FIELD)
+@XmlType(name = "ContentEncryptionKeyFromHeader")
+public class ContentEncryptionKeyFromHeader extends PlayReadyContentKey {
+
+}
diff --git a/media/src/main/java/com/microsoft/windowsazure/services/media/implementation/templates/playreadylicense/ContentEncryptionKeyFromKeyIdentifier.java b/media/src/main/java/com/microsoft/windowsazure/services/media/implementation/templates/playreadylicense/ContentEncryptionKeyFromKeyIdentifier.java
new file mode 100644
index 0000000..0c19e88
--- /dev/null
+++ b/media/src/main/java/com/microsoft/windowsazure/services/media/implementation/templates/playreadylicense/ContentEncryptionKeyFromKeyIdentifier.java
@@ -0,0 +1,45 @@
+package com.microsoft.windowsazure.services.media.implementation.templates.playreadylicense;
+
+import java.security.InvalidParameterException;
+import java.util.UUID;
+
+import javax.xml.bind.annotation.XmlAccessType;
+import javax.xml.bind.annotation.XmlAccessorType;
+import javax.xml.bind.annotation.XmlElement;
+import javax.xml.bind.annotation.XmlType;
+
+@XmlAccessorType(XmlAccessType.FIELD)
+@XmlType(name = "ContentEncryptionKeyFromKeyIdentifier")
+public class ContentEncryptionKeyFromKeyIdentifier extends PlayReadyContentKey {
+
+    @XmlElement(name = "KeyIdentifier")
+    private UUID keyIdentifier;
+    
+    public ContentEncryptionKeyFromKeyIdentifier() {
+        
+    }
+
+    public ContentEncryptionKeyFromKeyIdentifier(UUID keyIdentifier) {
+        if (keyIdentifier.equals(new UUID(0L, 0L))) {
+            throw new InvalidParameterException("keyIdentifier");
+        }
+
+        this.keyIdentifier = keyIdentifier;
+    }
+
+    /**
+     * @return the keyIdentifier
+     */
+    public UUID getKeyIdentifier() {
+        return keyIdentifier;
+    }
+
+    /**
+     * @param keyIdentifier
+     *            the keyIdentifier to set
+     */
+    public void setKeyIdentifier(UUID keyIdentifier) {
+        this.keyIdentifier = keyIdentifier;
+    }
+
+}
diff --git a/media/src/main/java/com/microsoft/windowsazure/services/media/implementation/templates/playreadylicense/ErrorMessages.java b/media/src/main/java/com/microsoft/windowsazure/services/media/implementation/templates/playreadylicense/ErrorMessages.java
new file mode 100644
index 0000000..55ab416
--- /dev/null
+++ b/media/src/main/java/com/microsoft/windowsazure/services/media/implementation/templates/playreadylicense/ErrorMessages.java
@@ -0,0 +1,41 @@
+package com.microsoft.windowsazure.services.media.implementation.templates.playreadylicense;
+
+public final class ErrorMessages {
+
+    public static final String UNCOMPRESSED_DIGITAL_AUDIO_OPL_VALUE_ERROR 
+        = "The value can only be set to null, 100, 150, 200, 250, or 300.";
+    public static final String UNCOMPRESSED_DIGITAL_VIDEO_OPL_VALUE_ERROR 
+        = "The value can only be set to null, 100, 250, 270, or 300.";
+    public static final String BEGIN_DATE_AND_RELATIVE_BEGIN_DATE_CANNOTBE_SET_SIMULTANEOUSLY_ERROR 
+        = "Set BeginDate or RelativeBeginDate but not both";    
+    public static final String EXPIRATION_DATE_AND_RELATIVE_EXPIRATION_DATE_CANNOTBE_SET_SIMULTANEOUSLY_ERROR
+        = "Set ExpirationDate or RelativeExpirationDate but not both";    
+    public static final String PLAY_READY_PLAY_RIGHT_REQUIRED 
+        = "Each PlayReadyLicenseTemplate in the PlayReadyLicenseResponseTemplate must have a PlayReadyPlayRight";    
+    public static final String PLAY_READY_CONTENT_KEY_REQUIRED 
+        = "Each PlayReadyLicenseTemplate in the PlayReadyLicenseResponseTemplate must have either a ContentEncryptionKeyFromHeader or a ContentEncryptionKeyFromKeyIdentifier";
+    public static final String INVALID_TWO_BIT_CONFIGURATION_DATA 
+        = "ConfigurationData must be 0, 1, 2, or 3";
+    public static final String GRACE_PERIOD_CANNOT_BE_SET_ON_NON_PERSISTENT_LICENSE 
+        = "GracePeriod cannot be set on Non Persistent licenses.";
+    public static final String FIRST_PLAY_EXPIRATION_CANNOT_BE_SET_ON_NON_PERSISTENT_LICENSE 
+        = "FirstPlayExpiration cannot be set on the PlayRight of a Non Persistent license.";
+    public static final String EXPIRATION_CANNOT_BE_SET_ON_NON_PERSISTENT_LICENSE 
+        = "ExpirationDate cannot be set on Non Persistent licenses.";
+    public static final String DIGITAL_VIDEO_ONLY_MUTUALLY_EXCLUSIVE_WITH_PASSING_TO_UNKNOWN_OUTPUT_ERROR 
+        = "PlayReady does not allow passing to unknown outputs if the DigitalVideoOnlyContentRestriction is enabled.";
+    public static final String COMPRESSED_DIGITAL_VIDEO_OPL_VALUE_ERROR 
+        = "The value can only be set to null, 400, or 500.";
+    public static final String COMPRESSED_DIGITAL_AUDIO_OPL_VALUE_ERROR 
+        = "The value can only be set to null, 100, 150, 200, 250, or 300.";
+    public static final String BEGIN_DATE_CANNOT_BE_SET_ON_NON_PERSISTENT_LICENSE 
+        = "BeginDate cannot be set on Non Persistent licenses.";
+    public static final String AT_LEAST_ONE_LICENSE_TEMPLATE_REQUIRED 
+        = "A PlayReadyLicenseResponseTemplate must have at least one PlayReadyLicenseTemplate";
+    public static final String ANALOG_VIDEO_OPL_VALUE_ERROR 
+        = "The value can only be set to null, 100, 150, or 200.";
+
+    private ErrorMessages() {
+    }
+
+}
diff --git a/media/src/main/java/com/microsoft/windowsazure/services/media/implementation/templates/playreadylicense/ExplicitAnalogTelevisionRestriction.java b/media/src/main/java/com/microsoft/windowsazure/services/media/implementation/templates/playreadylicense/ExplicitAnalogTelevisionRestriction.java
new file mode 100644
index 0000000..5abff7f
--- /dev/null
+++ b/media/src/main/java/com/microsoft/windowsazure/services/media/implementation/templates/playreadylicense/ExplicitAnalogTelevisionRestriction.java
@@ -0,0 +1,51 @@
+package com.microsoft.windowsazure.services.media.implementation.templates.playreadylicense;
+
+import javax.xml.bind.annotation.XmlAccessType;
+import javax.xml.bind.annotation.XmlAccessorType;
+import javax.xml.bind.annotation.XmlElement;
+import javax.xml.bind.annotation.XmlType;
+
+@XmlAccessorType(XmlAccessType.FIELD)
+@XmlType(name = "ExplicitAnalogTelevisionRestriction")
+public class ExplicitAnalogTelevisionRestriction {
+
+    @XmlElement(name = "BestEffort")
+    private boolean bestEffort;
+
+    @XmlElement(name = "ConfigurationData")
+    private byte configurationData;
+    
+    @SuppressWarnings("unused")
+    private ExplicitAnalogTelevisionRestriction() {
+    }
+
+    public ExplicitAnalogTelevisionRestriction(boolean bestEffort, byte configurationData) {
+        ScmsRestriction.verifyTwoBitConfigurationData(configurationData);
+        this.bestEffort = bestEffort;
+        this.configurationData = configurationData;
+    }
+
+    /**
+     * @return the bestEffort
+     */
+    public boolean isBestEffort() {
+        return bestEffort;
+    }
+
+    /**
+     * @param bestEffort
+     *            the bestEffort to set
+     * @return this
+     */
+    public ExplicitAnalogTelevisionRestriction setBestEffort(boolean bestEffort) {
+        this.bestEffort = bestEffort;
+        return this;
+    }
+
+    /**
+     * @return the configurationData
+     */
+    public byte getConfigurationData() {
+        return configurationData;
+    }   
+}
diff --git a/media/src/main/java/com/microsoft/windowsazure/services/media/implementation/templates/playreadylicense/PlayReadyContentKey.java b/media/src/main/java/com/microsoft/windowsazure/services/media/implementation/templates/playreadylicense/PlayReadyContentKey.java
new file mode 100644
index 0000000..cc045b4
--- /dev/null
+++ b/media/src/main/java/com/microsoft/windowsazure/services/media/implementation/templates/playreadylicense/PlayReadyContentKey.java
@@ -0,0 +1,10 @@
+package com.microsoft.windowsazure.services.media.implementation.templates.playreadylicense;
+
+import javax.xml.bind.annotation.XmlSeeAlso;
+import javax.xml.bind.annotation.XmlTransient;
+
+@XmlTransient
+@XmlSeeAlso({ContentEncryptionKeyFromHeader.class, ContentEncryptionKeyFromKeyIdentifier.class})
+public abstract class PlayReadyContentKey {
+
+}
diff --git a/media/src/main/java/com/microsoft/windowsazure/services/media/implementation/templates/playreadylicense/PlayReadyLicenseType.java b/media/src/main/java/com/microsoft/windowsazure/services/media/implementation/templates/playreadylicense/PlayReadyLicenseType.java
new file mode 100644
index 0000000..668e4cc
--- /dev/null
+++ b/media/src/main/java/com/microsoft/windowsazure/services/media/implementation/templates/playreadylicense/PlayReadyLicenseType.java
@@ -0,0 +1,48 @@
+package com.microsoft.windowsazure.services.media.implementation.templates.playreadylicense;
+
+import java.security.InvalidParameterException;
+
+import javax.xml.bind.annotation.XmlEnum;
+import javax.xml.bind.annotation.XmlEnumValue;
+import javax.xml.bind.annotation.XmlType;
+
+@XmlType
+@XmlEnum
+public enum PlayReadyLicenseType {
+    
+    @XmlEnumValue("Nonpersistent") Nonpersistent(0),
+    @XmlEnumValue("Persistent") Persistent(1);
+    
+    private int playReadyLicenseType;
+    
+    private PlayReadyLicenseType(int playReadyLicenseType) {
+        this.playReadyLicenseType = playReadyLicenseType;
+    }
+    
+    /**
+     * Gets the code.
+     * 
+     * @return the code
+     */
+    public int getCode() {
+        return playReadyLicenseType;
+    }
+    
+    /**
+     * From code.
+     * 
+     * @param code
+     *            the code
+     * @return the content key type
+     */
+    public static PlayReadyLicenseType fromCode(int code) {
+        switch (code) {
+        case 0:
+            return PlayReadyLicenseType.Nonpersistent;
+        case 1:
+            return PlayReadyLicenseType.Persistent;
+        default:
+            throw new InvalidParameterException("code");
+        }
+    }
+}
diff --git a/media/src/main/java/com/microsoft/windowsazure/services/media/implementation/templates/playreadylicense/ScmsRestriction.java b/media/src/main/java/com/microsoft/windowsazure/services/media/implementation/templates/playreadylicense/ScmsRestriction.java
new file mode 100644
index 0000000..9293c48
--- /dev/null
+++ b/media/src/main/java/com/microsoft/windowsazure/services/media/implementation/templates/playreadylicense/ScmsRestriction.java
@@ -0,0 +1,36 @@
+package com.microsoft.windowsazure.services.media.implementation.templates.playreadylicense;
+
+import javax.xml.bind.annotation.XmlAccessType;
+import javax.xml.bind.annotation.XmlAccessorType;
+import javax.xml.bind.annotation.XmlElement;
+import javax.xml.bind.annotation.XmlType;
+
+@XmlAccessorType(XmlAccessType.FIELD)
+@XmlType(name = "ScmsRestriction")
+public class ScmsRestriction {
+
+    @XmlElement(name = "ConfigurationData")
+    private byte configurationData;
+    
+    @SuppressWarnings("unused")
+    private ScmsRestriction() {
+    }
+
+    public ScmsRestriction(byte configurationData) {
+        verifyTwoBitConfigurationData(configurationData);
+        this.configurationData = configurationData;
+    }
+
+    /**
+     * @return the configurationData
+     */
+    public byte getConfigurationData() {
+        return configurationData;
+    }
+    
+    public static void verifyTwoBitConfigurationData(byte configurationData) {
+       if ((configurationData & 0x3) != configurationData) {
+           throw new IllegalArgumentException(ErrorMessages.INVALID_TWO_BIT_CONFIGURATION_DATA);
+       }
+    }
+}
diff --git a/media/src/main/java/com/microsoft/windowsazure/services/media/implementation/templates/playreadylicense/UnknownOutputPassingOption.java b/media/src/main/java/com/microsoft/windowsazure/services/media/implementation/templates/playreadylicense/UnknownOutputPassingOption.java
new file mode 100644
index 0000000..2077cf1
--- /dev/null
+++ b/media/src/main/java/com/microsoft/windowsazure/services/media/implementation/templates/playreadylicense/UnknownOutputPassingOption.java
@@ -0,0 +1,51 @@
+package com.microsoft.windowsazure.services.media.implementation.templates.playreadylicense;
+
+import java.security.InvalidParameterException;
+
+import javax.xml.bind.annotation.XmlEnum;
+import javax.xml.bind.annotation.XmlEnumValue;
+import javax.xml.bind.annotation.XmlType;
+
+@XmlType
+@XmlEnum
+public enum UnknownOutputPassingOption {
+    
+    @XmlEnumValue("NotAllowed") NotAllowed(0),
+    @XmlEnumValue("Allowed") Allowed(1),
+    @XmlEnumValue("AllowedWithVideoConstriction") AllowedWithVideoConstriction(2);
+    
+    private int unknownOutputPassingOption;
+    
+    private UnknownOutputPassingOption(int unknownOutputPassingOption) {
+        this.unknownOutputPassingOption = unknownOutputPassingOption;
+    }
+    
+    /**
+     * Gets the code.
+     * 
+     * @return the code
+     */
+    public int getCode() {
+        return unknownOutputPassingOption;
+    }
+    
+    /**
+     * From code.
+     * 
+     * @param code
+     *            the code
+     * @return the content key type
+     */
+    public static UnknownOutputPassingOption fromCode(int code) {
+        switch (code) {
+        case 0:
+            return UnknownOutputPassingOption.NotAllowed;
+        case 1:
+            return UnknownOutputPassingOption.Allowed;
+        case 2:
+            return UnknownOutputPassingOption.AllowedWithVideoConstriction;
+        default:
+            throw new InvalidParameterException("code");
+        }
+    }
+}
diff --git a/media/src/main/java/com/microsoft/windowsazure/services/media/implementation/templates/playreadylicense/package-info.java b/media/src/main/java/com/microsoft/windowsazure/services/media/implementation/templates/playreadylicense/package-info.java
new file mode 100644
index 0000000..3d15462
--- /dev/null
+++ b/media/src/main/java/com/microsoft/windowsazure/services/media/implementation/templates/playreadylicense/package-info.java
@@ -0,0 +1,7 @@
+@XmlSchema(
+    namespace = "http://schemas.microsoft.com/Azure/MediaServices/KeyDelivery/PlayReadyTemplate/v1",
+    elementFormDefault = XmlNsForm.QUALIFIED)
+package com.microsoft.windowsazure.services.media.implementation.templates.playreadylicense;
+
+import javax.xml.bind.annotation.XmlNsForm;
+import javax.xml.bind.annotation.XmlSchema;
\ No newline at end of file
diff --git a/media/src/main/java/com/microsoft/windowsazure/services/media/implementation/templates/tokenrestriction/TokenRestrictionTemplate.java b/media/src/main/java/com/microsoft/windowsazure/services/media/implementation/templates/tokenrestriction/TokenRestrictionTemplate.java
new file mode 100644
index 0000000..fdc9b05
--- /dev/null
+++ b/media/src/main/java/com/microsoft/windowsazure/services/media/implementation/templates/tokenrestriction/TokenRestrictionTemplate.java
@@ -0,0 +1,149 @@
+package com.microsoft.windowsazure.services.media.implementation.templates.tokenrestriction;
+
+import java.net.URI;
+import java.util.ArrayList;
+import java.util.List;
+
+import javax.xml.bind.annotation.XmlAccessType;
+import javax.xml.bind.annotation.XmlAccessorType;
+import javax.xml.bind.annotation.XmlElement;
+import javax.xml.bind.annotation.XmlElementWrapper;
+import javax.xml.bind.annotation.XmlRootElement;
+
+
+@XmlRootElement(name = "TokenRestrictionTemplate")
+@XmlAccessorType(XmlAccessType.FIELD)
+public class TokenRestrictionTemplate {
+    
+    @XmlElementWrapper(name = "AlternateVerificationKeys")
+    @XmlElement(name = "TokenVerificationKey")
+    private List<TokenVerificationKey> alternateVerificationKeys;
+    
+    @XmlElement(name = "Audience", required = true)
+    private URI audience;
+    
+    @XmlElement(name = "Issuer", required = true)
+    private URI issuer;
+    
+    @XmlElement(name = "PrimaryVerificationKey")
+    private TokenVerificationKey primaryVerificationKey;
+    
+    @XmlElementWrapper(name = "RequiredClaims")
+    @XmlElement(name = "TokenClaim")
+    private List<TokenClaim> requiredClaims;
+    
+    @XmlElement(name = "TokenType")
+    private TokenType tokenType;
+    
+    @SuppressWarnings("unused")
+    private TokenRestrictionTemplate() {
+        this.setTokenType(TokenType.SWT);
+        initCollections();
+    }
+    
+    public TokenRestrictionTemplate(TokenType tokenType) {
+        this.setTokenType(tokenType);
+        initCollections();
+    }
+    
+    private void initCollections() {
+        setRequiredClaims(new ArrayList<TokenClaim>());
+        setAlternateVerificationKeys(new ArrayList<TokenVerificationKey>());
+    }
+    
+    /**
+     * @return the audience
+     */
+    public URI getAudience() {
+        return audience;
+    }
+
+    /**
+     * @param audience the audience to set
+     * @return this
+     */
+    public TokenRestrictionTemplate setAudience(URI audience) {
+        this.audience = audience;
+        return this;
+    }
+
+    /**
+     * @return the issuer
+     */
+    public URI getIssuer() {
+        return issuer;
+    }
+
+    /**
+     * @param issuer the issuer to set
+     * @return this
+     */
+    public TokenRestrictionTemplate setIssuer(URI issuer) {
+        this.issuer = issuer;
+        return this;
+    }
+
+    /**
+     * @return the tokenType
+     */
+    public TokenType getTokenType() {
+        return tokenType;
+    }
+
+    /**
+     * @param tokenType the tokenType to set
+     * @return this
+     */
+    public TokenRestrictionTemplate setTokenType(TokenType tokenType) {
+        this.tokenType = tokenType;
+        return this;
+    }
+
+    /**
+     * @return the primaryVerificationKey
+     */
+    public TokenVerificationKey getPrimaryVerificationKey() {
+        return primaryVerificationKey;
+    }
+
+    /**
+     * @param primaryVerificationKey the primaryVerificationKey to set
+     * @return this
+     */
+    public TokenRestrictionTemplate setPrimaryVerificationKey(TokenVerificationKey primaryVerificationKey) {
+        this.primaryVerificationKey = primaryVerificationKey;
+        return this;
+    }
+
+    /**
+     * @return the requiredClaims
+     */
+    public List<TokenClaim> getRequiredClaims() {
+        return requiredClaims;
+    }
+
+    /**
+     * @param requiredClaims the requiredClaims to set
+     * @return this
+     */
+    public TokenRestrictionTemplate setRequiredClaims(List<TokenClaim> requiredClaims) {
+        this.requiredClaims = requiredClaims;
+        return this;
+    }
+
+    /**
+     * @return the alternateVerificationKeys
+     */
+    public List<TokenVerificationKey> getAlternateVerificationKeys() {
+        return alternateVerificationKeys;
+    }
+
+    /**
+     * @param alternateVerificationKeys the alternateVerificationKeys to set
+     * @return this
+     */
+    public TokenRestrictionTemplate setAlternateVerificationKeys(List<TokenVerificationKey> alternateVerificationKeys) {
+        this.alternateVerificationKeys = alternateVerificationKeys;
+        return this;
+    }
+}
diff --git a/media/src/main/java/com/microsoft/windowsazure/services/media/implementation/templates/tokenrestriction/TokenRestrictionTemplateSerializer.java b/media/src/main/java/com/microsoft/windowsazure/services/media/implementation/templates/tokenrestriction/TokenRestrictionTemplateSerializer.java
new file mode 100644
index 0000000..0234156
--- /dev/null
+++ b/media/src/main/java/com/microsoft/windowsazure/services/media/implementation/templates/tokenrestriction/TokenRestrictionTemplateSerializer.java
@@ -0,0 +1,200 @@
+package com.microsoft.windowsazure.services.media.implementation.templates.tokenrestriction;
+
+import java.io.File;
+import java.io.StringReader;
+import java.io.StringWriter;
+import java.net.URLEncoder;
+import java.security.InvalidKeyException;
+import java.security.NoSuchAlgorithmException;
+import java.util.Calendar;
+import java.util.Date;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.UUID;
+
+import javax.crypto.Mac;
+import javax.crypto.spec.SecretKeySpec;
+import javax.xml.XMLConstants;
+import javax.xml.bind.JAXBContext;
+import javax.xml.bind.JAXBException;
+import javax.xml.bind.Marshaller;
+import javax.xml.bind.Unmarshaller;
+import javax.xml.validation.Schema;
+import javax.xml.validation.SchemaFactory;
+
+import org.xml.sax.SAXException;
+
+import com.microsoft.windowsazure.core.utils.Base64;
+import com.sun.xml.bind.marshaller.NamespacePrefixMapper;
+
+import io.jsonwebtoken.Jwts;
+import io.jsonwebtoken.SignatureAlgorithm;
+
+public final class TokenRestrictionTemplateSerializer {
+
+    private TokenRestrictionTemplateSerializer() {
+
+    }
+
+    public static String serialize(TokenRestrictionTemplate template) throws JAXBException {
+        StringWriter writer = new StringWriter();
+        JAXBContext context = JAXBContext.newInstance(TokenRestrictionTemplate.class);
+        Marshaller m = context.createMarshaller();
+        m.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, true);
+        m.setProperty("com.sun.xml.bind.namespacePrefixMapper", new NamespacePrefixMapper() {
+            @Override
+            public String[] getPreDeclaredNamespaceUris() {
+                return new String[] { 
+                        XMLConstants.W3C_XML_SCHEMA_INSTANCE_NS_URI 
+                     };
+            }
+
+            @Override
+            public String getPreferredPrefix(String namespaceUri, String suggestion, boolean requirePrefix) {
+                if (namespaceUri.equals(XMLConstants.W3C_XML_SCHEMA_INSTANCE_NS_URI)) {
+                    return "i";
+                }
+                return suggestion;
+            }
+        });
+        m.marshal(template, writer);
+        return writer.toString();
+    }
+
+    public static TokenRestrictionTemplate deserialize(String xml) throws JAXBException {
+        try {
+            return deserialize(xml, null);
+        } catch (SAXException e) {
+            // never reached.
+            return null;
+        }
+    }
+
+    public static TokenRestrictionTemplate deserialize(String xml, String validationSchemaFileName)
+            throws JAXBException, SAXException {
+        JAXBContext context = JAXBContext.newInstance(TokenRestrictionTemplate.class);
+        Unmarshaller u = context.createUnmarshaller();
+        if (validationSchemaFileName != null) {
+            SchemaFactory factory = SchemaFactory.newInstance("http://www.w3.org/2001/XMLSchema");
+            Schema schema = factory.newSchema(new File(validationSchemaFileName));
+            u.setSchema(schema);
+        }
+        return (TokenRestrictionTemplate) u.unmarshal(new StringReader(xml));
+    }
+
+    private static String generateTokenExpiry(Date expiry) {
+        return Long.toString(expiry.getTime() / 1000L);
+    }
+
+    @SuppressWarnings("deprecation")
+    private static String urlEncode(String toEncode) {
+        StringBuilder encoded = new StringBuilder(URLEncoder.encode(toEncode));
+        // This code provides uppercase url encoding in order to
+        // get generateTestToken test working.
+        for (int i = 0; i < encoded.length() - 2; i++) {
+            if (encoded.charAt(i) == '%') {
+                encoded.setCharAt(i + 1, Character.toLowerCase(encoded.charAt(i + 1)));
+                encoded.setCharAt(i + 2, Character.toLowerCase(encoded.charAt(i + 2)));
+            }
+        }
+        return encoded.toString();
+    }
+
+    public static String generateTestToken(TokenRestrictionTemplate tokenTemplate, TokenVerificationKey signingKeyToUse,
+            UUID keyIdForContentKeyIdentifierClaim, Date tokenExpiration, Date notBefore) {    
+        
+        if (tokenTemplate == null) {
+            throw new NullPointerException("tokenTemplate");
+        }
+
+        if (signingKeyToUse == null) {
+            signingKeyToUse = tokenTemplate.getPrimaryVerificationKey();
+        }
+
+        if (tokenExpiration == null) {
+            Calendar cal = Calendar.getInstance();
+            cal.setTime(new Date());
+            cal.add(Calendar.MINUTE, 10);
+            tokenExpiration = cal.getTime();
+        }
+        
+        if (notBefore == null) {
+            Calendar cal = Calendar.getInstance();
+            cal.setTime(new Date());
+            cal.add(Calendar.MINUTE, -5);
+            notBefore = cal.getTime();
+        }
+        
+        if (tokenTemplate.getTokenType().equals(TokenType.SWT)) {
+            return generateTestTokenSWT(tokenTemplate, signingKeyToUse, keyIdForContentKeyIdentifierClaim, tokenExpiration);
+        } else {
+            return generateTestTokenJWT(tokenTemplate, signingKeyToUse, keyIdForContentKeyIdentifierClaim, tokenExpiration, notBefore);
+        }
+    }
+
+    public static String generateTestTokenJWT(TokenRestrictionTemplate tokenTemplate, TokenVerificationKey signingKeyToUse,
+        UUID keyIdForContentKeyIdentifierClaim, Date tokenExpiration, Date notBefore) {
+    
+        SymmetricVerificationKey signingKey = (SymmetricVerificationKey) signingKeyToUse;
+        SecretKeySpec secretKey = new SecretKeySpec(signingKey.getKeyValue(), "HmacSHA256");
+        
+        // Mapping Claims.
+        Map<String, Object> claims = new HashMap<String, Object>();
+        for (TokenClaim claim : tokenTemplate.getRequiredClaims()) {
+            String claimValue = claim.getClaimValue();
+            if (claimValue == null && claim.getClaimType().equals(TokenClaim.getContentKeyIdentifierClaimType())) {
+                claimValue = keyIdForContentKeyIdentifierClaim.toString();
+            }
+            claims.put(claim.getClaimType(), claimValue);    
+        }
+
+        return Jwts.builder()
+                .setHeaderParam("typ", "JWT")
+                .setClaims(claims)
+                .setIssuer(tokenTemplate.getIssuer().toString())
+                .setAudience(tokenTemplate.getAudience().toString())
+                .setIssuedAt(notBefore)
+                .setExpiration(tokenExpiration)
+                .signWith(SignatureAlgorithm.HS256, secretKey)
+                .compact();
+    }
+    
+    public static String generateTestTokenSWT(TokenRestrictionTemplate tokenTemplate, TokenVerificationKey signingKeyToUse,
+            UUID keyIdForContentKeyIdentifierClaim, Date tokenExpiration) {
+        
+        StringBuilder builder = new StringBuilder();
+
+        for (TokenClaim claim : tokenTemplate.getRequiredClaims()) {
+            String claimValue = claim.getClaimValue();
+            if (claim.getClaimType().equals(TokenClaim.getContentKeyIdentifierClaimType())) {
+                claimValue = keyIdForContentKeyIdentifierClaim.toString();
+            }
+
+            builder.append(String.format("%s=%s&", urlEncode(claim.getClaimType()), urlEncode(claimValue)));
+        }
+
+        builder.append(String.format("Audience=%s&", urlEncode(tokenTemplate.getAudience().toString())));
+        builder.append(String.format("ExpiresOn=%s&", generateTokenExpiry(tokenExpiration)));
+        builder.append(String.format("Issuer=%s", urlEncode(tokenTemplate.getIssuer().toString())));
+
+        SymmetricVerificationKey signingKey = (SymmetricVerificationKey) signingKeyToUse;
+        SecretKeySpec secretKey = new SecretKeySpec(signingKey.getKeyValue(), "HmacSHA256");
+        Mac mac;
+        try {
+            mac = Mac.getInstance("HmacSHA256");
+            mac.init(secretKey);
+        } catch (NoSuchAlgorithmException e) {
+            throw new RuntimeException(e);
+        } catch (InvalidKeyException e) {
+            throw new RuntimeException(e);
+        }
+        byte[] unsignedTokenAsBytes = builder.toString().getBytes();
+        byte[] signatureBytes = mac.doFinal(unsignedTokenAsBytes);
+        String encoded = new String(Base64.encode(signatureBytes));
+
+        builder.append(String.format("&HMACSHA256=%s", urlEncode(encoded)));
+
+        return builder.toString();
+    }
+
+}
diff --git a/media/src/main/java/com/microsoft/windowsazure/services/media/implementation/templates/tokenrestriction/package-info.java b/media/src/main/java/com/microsoft/windowsazure/services/media/implementation/templates/tokenrestriction/package-info.java
new file mode 100644
index 0000000..2732ecf
--- /dev/null
+++ b/media/src/main/java/com/microsoft/windowsazure/services/media/implementation/templates/tokenrestriction/package-info.java
@@ -0,0 +1,7 @@
+@XmlSchema(
+    namespace = "http://schemas.microsoft.com/Azure/MediaServices/KeyDelivery/TokenRestrictionTemplate/v1",
+    elementFormDefault = XmlNsForm.QUALIFIED)
+package com.microsoft.windowsazure.services.media.implementation.templates.tokenrestriction;
+
+import javax.xml.bind.annotation.XmlNsForm;
+import javax.xml.bind.annotation.XmlSchema;
\ No newline at end of file
diff --git a/media/src/main/java/com/microsoft/windowsazure/services/media/models/ContentKey.java b/media/src/main/java/com/microsoft/windowsazure/services/media/models/ContentKey.java
index 3490fc6..7b8ba42 100644
--- a/media/src/main/java/com/microsoft/windowsazure/services/media/models/ContentKey.java
+++ b/media/src/main/java/com/microsoft/windowsazure/services/media/models/ContentKey.java
@@ -405,7 +405,7 @@ public final class ContentKey {
     public static class Updater extends EntityOperationBase implements
         EntityUpdateOperation {
         
-        String contentKeyAuthorizationPolicyId;
+        private String contentKeyAuthorizationPolicyId;
         
         protected Updater(String contentKeyId, String contentKeyAuthorizationPolicyId) {
             super(new EntityOperationBase.EntityIdUriBuilder(ENTITY_SET,
diff --git a/media/src/test/java/com/microsoft/windowsazure/services/media/implementation/templates/playreadylicense/AgcAndColorStripeRestrictionTests.java b/media/src/test/java/com/microsoft/windowsazure/services/media/implementation/templates/playreadylicense/AgcAndColorStripeRestrictionTests.java
new file mode 100644
index 0000000..279e761
--- /dev/null
+++ b/media/src/test/java/com/microsoft/windowsazure/services/media/implementation/templates/playreadylicense/AgcAndColorStripeRestrictionTests.java
@@ -0,0 +1,44 @@
+package com.microsoft.windowsazure.services.media.implementation.templates.playreadylicense;
+
+import static org.junit.Assert.*;
+
+import java.security.InvalidParameterException;
+import org.junit.Test;
+
+import com.microsoft.windowsazure.services.media.implementation.templates.playreadylicense.AgcAndColorStripeRestriction;
+import com.microsoft.windowsazure.services.media.implementation.templates.playreadylicense.ErrorMessages;
+
+public class AgcAndColorStripeRestrictionTests {
+
+    @Test
+    public void NewAgcAndColorStripeRestrictionTests() {
+        // Arrange
+        byte expectedConfigurationData = 2;
+
+        // Act
+        AgcAndColorStripeRestriction agcAndColorStripeRestriction = new AgcAndColorStripeRestriction(
+                expectedConfigurationData);
+        byte resultConfigurationData = agcAndColorStripeRestriction.getConfigurationData();
+
+        // Assert
+        assertEquals(expectedConfigurationData, resultConfigurationData);
+    }
+
+    @Test
+    public void BadConfigurationDataAgcAndColorStripeRestrictionShouldThrown() {
+        // Arrange
+        byte expectedConfigurationData = 4;
+
+        // Act
+        try {
+            @SuppressWarnings("unused")
+            AgcAndColorStripeRestriction agcAndColorStripeRestriction = new AgcAndColorStripeRestriction(
+                    expectedConfigurationData);
+            fail("Should Thrown");
+
+        } catch (IllegalArgumentException e) {
+            // Assert
+            assertEquals(e.getMessage(), ErrorMessages.INVALID_TWO_BIT_CONFIGURATION_DATA);
+        }
+    }
+}
diff --git a/media/src/test/java/com/microsoft/windowsazure/services/media/implementation/templates/playreadylicense/ExplicitAnalogTelevisionRestrictionTests.java b/media/src/test/java/com/microsoft/windowsazure/services/media/implementation/templates/playreadylicense/ExplicitAnalogTelevisionRestrictionTests.java
new file mode 100644
index 0000000..1f24ffc
--- /dev/null
+++ b/media/src/test/java/com/microsoft/windowsazure/services/media/implementation/templates/playreadylicense/ExplicitAnalogTelevisionRestrictionTests.java
@@ -0,0 +1,64 @@
+package com.microsoft.windowsazure.services.media.implementation.templates.playreadylicense;
+
+import static org.junit.Assert.*;
+
+import org.junit.Test;
+
+import com.microsoft.windowsazure.services.media.implementation.templates.playreadylicense.ErrorMessages;
+import com.microsoft.windowsazure.services.media.implementation.templates.playreadylicense.ExplicitAnalogTelevisionRestriction;
+
+public class ExplicitAnalogTelevisionRestrictionTests {
+
+    @Test
+    public void NewExplicitAnalogTelevisionRestrictionTest() {
+        // Arrange
+        boolean expectedBestEffort = true;
+        byte expectedConfigurationData = 2;
+
+        // Act
+        ExplicitAnalogTelevisionRestriction explicitAnalogTelevisionRestriction = new ExplicitAnalogTelevisionRestriction(
+                expectedBestEffort, expectedConfigurationData);
+        boolean resultBestEffort = explicitAnalogTelevisionRestriction.isBestEffort();
+        byte resultConfigurationData = explicitAnalogTelevisionRestriction.getConfigurationData();
+
+        // Assert
+        assertEquals(expectedBestEffort, resultBestEffort);
+        assertEquals(expectedConfigurationData, resultConfigurationData);
+    }
+
+    @Test
+    public void GetterSetterExplicitAnalogTelevisionRestrictionTest() {
+        // Arrange
+        boolean expectedBestEffort = true;
+        byte expectedConfigurationData = 2;
+
+        // Act
+        ExplicitAnalogTelevisionRestriction explicitAnalogTelevisionRestriction = new ExplicitAnalogTelevisionRestriction(
+                false, expectedConfigurationData);
+        explicitAnalogTelevisionRestriction.setBestEffort(expectedBestEffort);
+        boolean resultBestEffort = explicitAnalogTelevisionRestriction.isBestEffort();
+        byte resultConfigurationData = explicitAnalogTelevisionRestriction.getConfigurationData();
+
+        // Assert
+        assertEquals(expectedBestEffort, resultBestEffort);
+        assertEquals(expectedConfigurationData, resultConfigurationData);
+    }
+
+    @Test
+    public void BadConfigurationDataExplicitAnalogTelevisionRestrictionShouldThrown() {
+        // Arrange
+        byte expectedConfigurationData = 4;
+
+        // Act
+        try {
+            @SuppressWarnings("unused")
+            ExplicitAnalogTelevisionRestriction explicitAnalogTelevisionRestriction = new ExplicitAnalogTelevisionRestriction(
+                    false, expectedConfigurationData);
+            fail("Should Thrown");
+
+            // Assert
+        } catch (IllegalArgumentException e) {
+            assertEquals(e.getMessage(), ErrorMessages.INVALID_TWO_BIT_CONFIGURATION_DATA);
+        }
+    }
+}
diff --git a/media/src/test/java/com/microsoft/windowsazure/services/media/implementation/templates/playreadylicense/PlayReadyContentKeyTests.java b/media/src/test/java/com/microsoft/windowsazure/services/media/implementation/templates/playreadylicense/PlayReadyContentKeyTests.java
new file mode 100644
index 0000000..487be07
--- /dev/null
+++ b/media/src/test/java/com/microsoft/windowsazure/services/media/implementation/templates/playreadylicense/PlayReadyContentKeyTests.java
@@ -0,0 +1,71 @@
+package com.microsoft.windowsazure.services.media.implementation.templates.playreadylicense;
+
+import static org.junit.Assert.*;
+
+import java.security.InvalidParameterException;
+import java.util.UUID;
+
+import org.junit.Test;
+
+import com.microsoft.windowsazure.services.media.implementation.templates.playreadylicense.ContentEncryptionKeyFromHeader;
+import com.microsoft.windowsazure.services.media.implementation.templates.playreadylicense.ContentEncryptionKeyFromKeyIdentifier;
+
+public class PlayReadyContentKeyTests {
+    
+    @Test
+    public void InvalidUUIDContentEncryptionKeyFromKeyIdentifierTest() {
+        // Arrange
+        UUID invalidUUID = new UUID(0L, 0L);
+        
+        // Act
+        try {
+            @SuppressWarnings("unused")
+            ContentEncryptionKeyFromKeyIdentifier contentEncryptionKeyFromKeyIdentifier =
+                    new ContentEncryptionKeyFromKeyIdentifier(invalidUUID);
+            fail("Should Thrown");
+        } catch (InvalidParameterException e) {
+            assertEquals(e.getMessage(), "keyIdentifier");
+        }
+    }
+    
+    @Test
+    public void ValidUUIDContentEncryptionKeyFromKeyIdentifierTest() {
+        // Arrange
+        UUID validUUID = UUID.randomUUID();
+        
+        // Act
+        ContentEncryptionKeyFromKeyIdentifier contentEncryptionKeyFromKeyIdentifier =
+                new ContentEncryptionKeyFromKeyIdentifier(validUUID);
+        UUID resultUUID = contentEncryptionKeyFromKeyIdentifier.getKeyIdentifier();
+
+        // Assert
+        assertEquals(resultUUID, validUUID);
+    }
+    
+    @Test
+    public void GetterSetterUUIDContentEncryptionKeyFromKeyIdentifierTest() {
+        // Arrange
+        UUID expectedUUID = UUID.randomUUID();
+        
+        // Act
+        ContentEncryptionKeyFromKeyIdentifier contentEncryptionKeyFromKeyIdentifier =
+                new ContentEncryptionKeyFromKeyIdentifier(UUID.randomUUID());
+        
+        contentEncryptionKeyFromKeyIdentifier.setKeyIdentifier(expectedUUID);
+        UUID resultUUID = contentEncryptionKeyFromKeyIdentifier.getKeyIdentifier();
+
+        // Assert
+        assertEquals(resultUUID, expectedUUID);
+    }
+    
+    @Test
+    public void NewContentEncryptionKeyFromHeaderTest() {
+        // Arrange
+        // Act
+        ContentEncryptionKeyFromHeader contentEncryptionKeyFromHeader =
+                new ContentEncryptionKeyFromHeader();
+        // Assert
+        assertNotNull(contentEncryptionKeyFromHeader);
+    }
+
+}
diff --git a/media/src/test/java/com/microsoft/windowsazure/services/media/implementation/templates/playreadylicense/PlayReadyLicenseTypeTests.java b/media/src/test/java/com/microsoft/windowsazure/services/media/implementation/templates/playreadylicense/PlayReadyLicenseTypeTests.java
new file mode 100644
index 0000000..aedc1be
--- /dev/null
+++ b/media/src/test/java/com/microsoft/windowsazure/services/media/implementation/templates/playreadylicense/PlayReadyLicenseTypeTests.java
@@ -0,0 +1,71 @@
+package com.microsoft.windowsazure.services.media.implementation.templates.playreadylicense;
+
+import static org.junit.Assert.*;
+
+import java.security.InvalidParameterException;
+import org.junit.Test;
+
+import com.microsoft.windowsazure.services.media.implementation.templates.playreadylicense.PlayReadyLicenseType;
+
+public class PlayReadyLicenseTypeTests {
+
+    @Test
+    public void valueOfPlayReadyLicenseTypeTestsTests() {
+        // provides full code coverage
+        assertEquals(PlayReadyLicenseType.Nonpersistent, PlayReadyLicenseType.valueOf("Nonpersistent"));
+        assertEquals(PlayReadyLicenseType.Persistent, PlayReadyLicenseType.valueOf("Persistent"));
+    }
+
+    @Test
+    public void fromCodeNonpersistentPlayReadyLicenseTypeTest() {
+        // Arrange
+        PlayReadyLicenseType expectedPlayReadyLicenseType = PlayReadyLicenseType.Nonpersistent;
+
+        // Act
+        PlayReadyLicenseType playReadyLicenseType = PlayReadyLicenseType.fromCode(0);
+
+        // Assert
+        assertEquals(playReadyLicenseType, expectedPlayReadyLicenseType);
+    }
+
+    @Test
+    public void fromCodePersistentPlayReadyLicenseTypeTest() {
+        // Arrange
+        PlayReadyLicenseType expectedPlayReadyLicenseType = PlayReadyLicenseType.Persistent;
+
+        // Act
+        PlayReadyLicenseType playReadyLicenseType = PlayReadyLicenseType.fromCode(1);
+
+        // Assert
+        assertEquals(playReadyLicenseType, expectedPlayReadyLicenseType);
+    }
+
+    @Test
+    public void fromCodeInvalidTokenTypeTests() {
+        // Arrange
+        int invalidCode = 666;
+        String expectedMessage = "code";
+        // Act
+        try {
+            @SuppressWarnings("unused")
+            PlayReadyLicenseType tokenPlayReadyLicenseType = PlayReadyLicenseType.fromCode(invalidCode);
+            fail("Should throw");
+        } catch (InvalidParameterException e) {
+            // Assert
+            assertEquals(e.getMessage(), expectedMessage);
+        }
+    }
+
+    @Test
+    public void getCodePersistentPlayReadyLicenseTypeTests() {
+        // Arrange
+        int expectedCode = 1;
+
+        // Act
+        PlayReadyLicenseType tokenTypeResult = PlayReadyLicenseType.Persistent;
+        int resultCode = tokenTypeResult.getCode();
+
+        // Assert
+        assertEquals(resultCode, expectedCode);
+    }
+}
diff --git a/media/src/test/java/com/microsoft/windowsazure/services/media/implementation/templates/playreadylicense/ScmsRestrictionTests.java b/media/src/test/java/com/microsoft/windowsazure/services/media/implementation/templates/playreadylicense/ScmsRestrictionTests.java
new file mode 100644
index 0000000..66a407b
--- /dev/null
+++ b/media/src/test/java/com/microsoft/windowsazure/services/media/implementation/templates/playreadylicense/ScmsRestrictionTests.java
@@ -0,0 +1,43 @@
+package com.microsoft.windowsazure.services.media.implementation.templates.playreadylicense;
+
+import static org.junit.Assert.*;
+
+import org.junit.Test;
+
+import com.microsoft.windowsazure.services.media.implementation.templates.playreadylicense.ErrorMessages;
+import com.microsoft.windowsazure.services.media.implementation.templates.playreadylicense.ScmsRestriction;
+
+public class ScmsRestrictionTests {
+
+    @Test
+    public void NewScmsRestrictionTests() {
+        // Arrange
+        byte expectedConfigurationData = 2;
+
+        // Act
+        ScmsRestriction scmsRestriction = new ScmsRestriction(
+                expectedConfigurationData);
+        byte resultConfigurationData = scmsRestriction.getConfigurationData();
+
+        // Assert
+        assertEquals(expectedConfigurationData, resultConfigurationData);
+    }
+
+    @Test
+    public void BadConfigurationDataScmsRestrictionShouldThrown() {
+        // Arrange
+        byte expectedConfigurationData = 4;
+
+        // Act
+        try {
+            @SuppressWarnings("unused")
+            ScmsRestriction scmsRestriction = new ScmsRestriction(
+                    expectedConfigurationData);
+            fail("Should Thrown");
+
+        } catch (IllegalArgumentException e) {
+            // Assert
+            assertEquals(e.getMessage(), ErrorMessages.INVALID_TWO_BIT_CONFIGURATION_DATA);
+        }
+    }
+}
diff --git a/media/src/test/java/com/microsoft/windowsazure/services/media/implementation/templates/playreadylicense/UnknownOutputPassingOptionTests.java b/media/src/test/java/com/microsoft/windowsazure/services/media/implementation/templates/playreadylicense/UnknownOutputPassingOptionTests.java
new file mode 100644
index 0000000..b333128
--- /dev/null
+++ b/media/src/test/java/com/microsoft/windowsazure/services/media/implementation/templates/playreadylicense/UnknownOutputPassingOptionTests.java
@@ -0,0 +1,86 @@
+package com.microsoft.windowsazure.services.media.implementation.templates.playreadylicense;
+
+import static org.junit.Assert.*;
+
+import java.security.InvalidParameterException;
+import org.junit.Test;
+
+import com.microsoft.windowsazure.services.media.implementation.templates.playreadylicense.UnknownOutputPassingOption;
+
+public class UnknownOutputPassingOptionTests {
+
+    @Test
+    public void valueOfPlayReadyLicenseTypeTestsTests() {
+        // provides full code coverage
+        assertEquals(UnknownOutputPassingOption.NotAllowed, UnknownOutputPassingOption.valueOf("NotAllowed"));
+        assertEquals(UnknownOutputPassingOption.Allowed, UnknownOutputPassingOption.valueOf("Allowed"));
+        assertEquals(UnknownOutputPassingOption.AllowedWithVideoConstriction,
+                UnknownOutputPassingOption.valueOf("AllowedWithVideoConstriction"));
+    }
+
+    @Test
+    public void fromCodeNotAllowedUnknownOutputPassingOption() {
+        // Arrange
+        UnknownOutputPassingOption expectedUnknownOutputPassingOption = UnknownOutputPassingOption.NotAllowed;
+
+        // Act
+        UnknownOutputPassingOption unknownOutputPassingOptionResult = UnknownOutputPassingOption.fromCode(0);
+
+        // Assert
+        assertEquals(expectedUnknownOutputPassingOption, unknownOutputPassingOptionResult);
+    }
+
+    @Test
+    public void fromCodeAllowedUnknownOutputPassingOptionTests() {
+        // Arrange
+        UnknownOutputPassingOption expectedUnknownOutputPassingOption = UnknownOutputPassingOption.Allowed;
+
+        // Act
+        UnknownOutputPassingOption unknownOutputPassingOptionResult = UnknownOutputPassingOption.fromCode(1);
+
+        // Assert
+        assertEquals(expectedUnknownOutputPassingOption, unknownOutputPassingOptionResult);
+    }
+
+    @Test
+    public void fromCodeAllowedWithVideoConstrictionUnknownOutputPassingOptionTests() {
+        // Arrange
+        UnknownOutputPassingOption expectedUnknownOutputPassingOption = UnknownOutputPassingOption.AllowedWithVideoConstriction;
+
+        // Act
+        UnknownOutputPassingOption unknownOutputPassingOptionResult = UnknownOutputPassingOption.fromCode(2);
+
+        // Assert
+        assertEquals(expectedUnknownOutputPassingOption, unknownOutputPassingOptionResult);
+    }
+
+    @Test
+    public void fromCodeInvalidUnknownOutputPassingOptionTests() {
+        // Arrange
+        int invalidCode = 666;
+        String expectedMessage = "code";
+        // Act
+        try {
+            @SuppressWarnings("unused")
+            UnknownOutputPassingOption unknownOutputPassingOptionResult = UnknownOutputPassingOption
+                    .fromCode(invalidCode);
+            fail("Should throw");
+        } catch (InvalidParameterException e) {
+            // Assert
+            assertEquals(e.getMessage(), expectedMessage);
+        }
+    }
+
+    @Test
+    public void getCodeJWTTokenTypeTests() {
+        // Arrange
+        int expectedCode = 2;
+
+        // Act
+        UnknownOutputPassingOption unknownOutputPassingOptionResult = UnknownOutputPassingOption.AllowedWithVideoConstriction;
+        int resultCode = unknownOutputPassingOptionResult.getCode();
+
+        // Assert
+        assertEquals(resultCode, expectedCode);
+    }
+}
diff --git a/media/src/test/java/com/microsoft/windowsazure/services/media/implementation/templates/tokenrestriction/TokenRestrictionTemplateSerializerTests.java b/media/src/test/java/com/microsoft/windowsazure/services/media/implementation/templates/tokenrestriction/TokenRestrictionTemplateSerializerTests.java
new file mode 100644
index 0000000..eab925c
--- /dev/null
+++ b/media/src/test/java/com/microsoft/windowsazure/services/media/implementation/templates/tokenrestriction/TokenRestrictionTemplateSerializerTests.java
@@ -0,0 +1,188 @@
+package com.microsoft.windowsazure.services.media.implementation.templates.tokenrestriction;
+
+import static org.junit.Assert.*;
+
+import java.net.URI;
+import java.net.URISyntaxException;
+import java.text.SimpleDateFormat;
+import java.util.Date;
+import java.util.Locale;
+import java.util.TimeZone;
+import java.util.UUID;
+
+import javax.xml.bind.JAXBException;
+
+import org.junit.Ignore;
+import org.junit.Test;
+import org.xml.sax.SAXException;
+
+import com.microsoft.windowsazure.services.media.implementation.templates.tokenrestriction.SymmetricVerificationKey;
+import com.microsoft.windowsazure.services.media.implementation.templates.tokenrestriction.TokenClaim;
+import com.microsoft.windowsazure.services.media.implementation.templates.tokenrestriction.TokenRestrictionTemplate;
+import com.microsoft.windowsazure.services.media.implementation.templates.tokenrestriction.TokenRestrictionTemplateSerializer;
+import com.microsoft.windowsazure.services.media.implementation.templates.tokenrestriction.TokenType;
+
+public class TokenRestrictionTemplateSerializerTests {
+
+    private final String schemaFile = TokenRestrictionTemplateSerializerTests.class.getClassLoader().getResource("")
+            .getPath() + "schemas/TokenRestrictionTemplate.xsd";
+    private final String _sampleIssuer = "http://sampleIssuerUrl";
+    private final String _sampleAudience = "http://sampleAudience";
+
+    @Test
+    public void RoundTripTest() throws JAXBException, URISyntaxException {
+        TokenRestrictionTemplate template = new TokenRestrictionTemplate(TokenType.SWT);
+
+        template.setPrimaryVerificationKey(new SymmetricVerificationKey());
+        template.getAlternateVerificationKeys().add(new SymmetricVerificationKey());
+        template.setAudience(new URI(_sampleAudience));
+        template.setIssuer(new URI(_sampleIssuer));
+        template.getRequiredClaims().add(TokenClaim.getContentKeyIdentifierClaim());
+        template.getRequiredClaims().add(new TokenClaim("Rental", "true"));
+
+        String serializedTemplate = TokenRestrictionTemplateSerializer.serialize(template);
+        assertTrue(serializedTemplate != null && serializedTemplate.length() > 0);
+
+        TokenRestrictionTemplate template2 = TokenRestrictionTemplateSerializer.deserialize(serializedTemplate);
+        assertNotNull(template2);
+        assertEquals(template.getIssuer(), template2.getIssuer());
+        assertEquals(template.getAudience(), template2.getAudience());
+        assertEquals(template.getTokenType(), TokenType.SWT);
+        SymmetricVerificationKey fromTemplate = (SymmetricVerificationKey) template.getPrimaryVerificationKey();
+        SymmetricVerificationKey fromTemplate2 = (SymmetricVerificationKey) template2.getPrimaryVerificationKey();
+
+        assertArrayEquals(fromTemplate.getKeyValue(), fromTemplate2.getKeyValue());
+    }
+
+    @Test
+    public void KnownGoodInputForSwtOnlyScheme() throws JAXBException {
+        String tokenTemplate = "<TokenRestrictionTemplate xmlns:i=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns=\"http://schemas.microsoft.com/Azure/MediaServices/KeyDelivery/TokenRestrictionTemplate/v1\"><AlternateVerificationKeys><TokenVerificationKey i:type=\"SymmetricVerificationKey\"><KeyValue>GG07fDPZ+HMD2vcoknMqYjEJMb7LSq8zUmdCYMvRCevnQK//ilbhODO/FydMrHiwZGmI6XywvOOU7SSzRPlI3Q==</KeyValue></TokenVerificationKey></AlternateVerificationKeys><Audience>http://sampleaudience/</Audience><Issuer>http://sampleissuerurl/</Issuer><PrimaryVerificationKey i:type=\"SymmetricVerificationKey\"><KeyValue>2OvxltHKwILn5PCRD8H+63sK98LBs1yF+ZdZbwzmToWYm29pLyqIMuCvMRGpLOv5DYh3NmpzWMAciu4ncW8VTg==</KeyValue></PrimaryVerificationKey><RequiredClaims><TokenClaim><ClaimType>urn:microsoft:azure:mediaservices:contentkeyidentifier</ClaimType><ClaimValue i:nil=\"true\" /></TokenClaim><TokenClaim><ClaimType>urn:myservice:claims:rental</ClaimType><ClaimValue>true</ClaimValue></TokenClaim></RequiredClaims></TokenRestrictionTemplate>";
+
+        TokenRestrictionTemplate template = TokenRestrictionTemplateSerializer.deserialize(tokenTemplate);
+        assertNotNull(template);
+        assertEquals(TokenType.SWT, template.getTokenType());
+    }
+
+    @Test
+    public void KnownGoodInputForJWT() throws JAXBException {
+        String tokenTemplate = "<TokenRestrictionTemplate xmlns:i=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns=\"http://schemas.microsoft.com/Azure/MediaServices/KeyDelivery/TokenRestrictionTemplate/v1\"><AlternateVerificationKeys /><Audience>http://sampleissuerurl/</Audience><Issuer>http://sampleaudience/</Issuer><PrimaryVerificationKey i:type=\"X509CertTokenVerificationKey\"><RawBody>MIIDAzCCAeugAwIBAgIQ2cl0q8oGkaFG+ZTZYsilhDANBgkqhkiG9w0BAQ0FADARMQ8wDQYDVQQDEwZDQVJvb3QwHhcNMTQxMjAxMTg0NzI5WhcNMzkxMjMxMjM1OTU5WjARMQ8wDQYDVQQDEwZDQVJvb3QwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQDjgMbtZcLtKNdJXHSGQ7l6xJBtNCVhjF4+BLZq+D2RmubKTAnGXhNGY4FO2LrPjfkWumdnv5DOlFuwHy2qrsZu1TFZxxQzU9/Yp3VAD1Afk7ShUOxniPpIO9vfkUH+FEX1Taq4ncR/TkiwnIZLy+bBa0DlF2MsPGC62KbiN4xJqvSIuecxQvcN8MZ78NDejtj1/XHF7VBmVjWi5B79GpTvY9ap39BU8nM0Q8vWb9DwmpWLz8j7hm25f+8laHIE6U8CpeeD/OrZT8ncCD0hbhR3ZGGoFqJbyv2CLPVGeaIhIxBH41zgrBYR53NjkRLTB4IEUCgeTGvSzweqlb+4totdAgMBAAGjVzBVMA8GA1UdEwEB/wQFMAMBAf8wQgYDVR0BBDswOYAQSHiCUWtQlUe79thqsTDbbqETMBExDzANBgNVBAMTBkNBUm9vdIIQ2cl0q8oGkaFG+ZTZYsilhDANBgkqhkiG9w0BAQ0FAAOCAQEABa/2D+Rxo6tp63sDFRViikNkDa5GFZscQLn4Rm35NmUt35Wc/AugLaTJ7iP5zJTYIBUI9DDhHbgFqmYpW0p14NebJlBzrRFIaoHBOsHhy4VYrxIB8Q/OvSGPgbI2c39ni/odyTYKVtJacxPrIt+MqeiFMjJ19cJSOkKT2AFoPMa/L0++znMcEObSAHYMy1U51J1njpQvNJ+MQiR8y2gvmMbGEcMgicIJxbLB2imqJWCQkFUlsrxwuuzSvNaLkdd/HyhsR1JXc+kOREO8gWjhT6MAdgGKC9+neamR7sqwJHPNfcLYTDFOhi6cJH10z74mU1Xa5uLsX+aZp2YYHUFw4Q==</RawBody></PrimaryVerificationKey><RequiredClaims /><TokenType>JWT</TokenType></TokenRestrictionTemplate>";
+        TokenRestrictionTemplate template = TokenRestrictionTemplateSerializer.deserialize(tokenTemplate);
+        assertNotNull(template);
+        assertEquals(TokenType.JWT, template.getTokenType());
+    }
+
+    @Test
+    public void KnownGoodInputForSWT() throws JAXBException {
+        String tokenTemplate = "<TokenRestrictionTemplate xmlns:i=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns=\"http://schemas.microsoft.com/Azure/MediaServices/KeyDelivery/TokenRestrictionTemplate/v1\"><AlternateVerificationKeys /><Audience>http://sampleissuerurl/</Audience><Issuer>http://sampleaudience/</Issuer><PrimaryVerificationKey i:type=\"SymmetricVerificationKey\"><KeyValue>2OvxltHKwILn5PCRD8H+63sK98LBs1yF+ZdZbwzmToWYm29pLyqIMuCvMRGpLOv5DYh3NmpzWMAciu4ncW8VTg==</KeyValue></PrimaryVerificationKey><RequiredClaims><TokenClaim><ClaimType>urn:microsoft:azure:mediaservices:contentkeyidentifier</ClaimType><ClaimValue i:nil=\"true\" /></TokenClaim><TokenClaim><ClaimType>urn:myservice:claims:rental</ClaimType><ClaimValue>true</ClaimValue></TokenClaim></RequiredClaims><TokenType>SWT</TokenType></TokenRestrictionTemplate>";
+        TokenRestrictionTemplate template = TokenRestrictionTemplateSerializer.deserialize(tokenTemplate);
+        assertNotNull(template);
+        assertEquals(TokenType.SWT, template.getTokenType());
+    }
+
+    @Test
+    public void InputMissingIssuerShouldThrow() {
+        String tokenTemplate = "<TokenRestrictionTemplate xmlns:i=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns=\"http://schemas.microsoft.com/Azure/MediaServices/KeyDelivery/TokenRestrictionTemplate/v1\"><AlternateVerificationKeys><TokenVerificationKey i:type=\"SymmetricVerificationKey\"><KeyValue>GG07fDPZ+HMD2vcoknMqYjEJMb7LSq8zUmdCYMvRCevnQK//ilbhODO/FydMrHiwZGmI6XywvOOU7SSzRPlI3Q==</KeyValue></TokenVerificationKey></AlternateVerificationKeys><Audience>http://sampleaudience/</Audience><PrimaryVerificationKey i:type=\"SymmetricVerificationKey\"><KeyValue>2OvxltHKwILn5PCRD8H+63sK98LBs1yF+ZdZbwzmToWYm29pLyqIMuCvMRGpLOv5DYh3NmpzWMAciu4ncW8VTg==</KeyValue></PrimaryVerificationKey><RequiredClaims><TokenClaim><ClaimType>urn:microsoft:azure:mediaservices:contentkeyidentifier</ClaimType><ClaimValue i:nil=\"true\" /></TokenClaim><TokenClaim><ClaimType>urn:myservice:claims:rental</ClaimType><ClaimValue>true</ClaimValue></TokenClaim></RequiredClaims></TokenRestrictionTemplate>";
+
+        try {
+            @SuppressWarnings("unused")
+            TokenRestrictionTemplate template = TokenRestrictionTemplateSerializer.deserialize(tokenTemplate,
+                    schemaFile);
+            fail("Should throw");
+        } catch (JAXBException e) {
+            assertTrue(e.getLinkedException().getMessage().contains("Issuer"));
+        } catch (SAXException e) {
+            fail("Invalid Schema");
+        }
+    }
+
+    @Test
+    public void InputMissingAudienceShouldThrow() {
+        String tokenTemplate = "<TokenRestrictionTemplate xmlns:i=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns=\"http://schemas.microsoft.com/Azure/MediaServices/KeyDelivery/TokenRestrictionTemplate/v1\"><AlternateVerificationKeys><TokenVerificationKey i:type=\"SymmetricVerificationKey\"><KeyValue>GG07fDPZ+HMD2vcoknMqYjEJMb7LSq8zUmdCYMvRCevnQK//ilbhODO/FydMrHiwZGmI6XywvOOU7SSzRPlI3Q==</KeyValue></TokenVerificationKey></AlternateVerificationKeys><Issuer>http://sampleissuerurl/</Issuer><PrimaryVerificationKey i:type=\"SymmetricVerificationKey\"><KeyValue>2OvxltHKwILn5PCRD8H+63sK98LBs1yF+ZdZbwzmToWYm29pLyqIMuCvMRGpLOv5DYh3NmpzWMAciu4ncW8VTg==</KeyValue></PrimaryVerificationKey><RequiredClaims><TokenClaim><ClaimType>urn:microsoft:azure:mediaservices:contentkeyidentifier</ClaimType><ClaimValue i:nil=\"true\" /></TokenClaim><TokenClaim><ClaimType>urn:myservice:claims:rental</ClaimType><ClaimValue>true</ClaimValue></TokenClaim></RequiredClaims></TokenRestrictionTemplate>";
+
+        try {
+            @SuppressWarnings("unused")
+            TokenRestrictionTemplate template = TokenRestrictionTemplateSerializer.deserialize(tokenTemplate,
+                    schemaFile);
+            fail("Should throw");
+        } catch (JAXBException e) {
+            assertTrue(e.getLinkedException().getMessage().contains("Audience"));
+        } catch (SAXException e) {
+            fail("Invalid Schema");
+        }
+    }
+
+    @Test
+    public void InputMissingPrimaryKeyShouldThrow() {
+        String tokenTemplate = "<TokenRestrictionTemplate xmlns:i=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns=\"http://schemas.microsoft.com/Azure/MediaServices/KeyDelivery/TokenRestrictionTemplate/v1\"><AlternateVerificationKeys><TokenVerificationKey i:type=\"SymmetricVerificationKey\"><KeyValue>GG07fDPZ+HMD2vcoknMqYjEJMb7LSq8zUmdCYMvRCevnQK//ilbhODO/FydMrHiwZGmI6XywvOOU7SSzRPlI3Q==</KeyValue></TokenVerificationKey></AlternateVerificationKeys><Audience>http://sampleaudience/</Audience><Issuer>http://sampleissuerurl/</Issuer><RequiredClaims><TokenClaim><ClaimType>urn:microsoft:azure:mediaservices:contentkeyidentifier</ClaimType><ClaimValue i:nil=\"true\" /></TokenClaim><TokenClaim><ClaimType>urn:myservice:claims:rental</ClaimType><ClaimValue>true</ClaimValue></TokenClaim></RequiredClaims></TokenRestrictionTemplate>";
+
+        try {
+            @SuppressWarnings("unused")
+            TokenRestrictionTemplate template = TokenRestrictionTemplateSerializer.deserialize(tokenTemplate,
+                    schemaFile);
+            fail("Should throw");
+        } catch (JAXBException e) {
+            assertTrue(e.getLinkedException().getMessage().contains("PrimaryVerificationKey"));
+        } catch (SAXException e) {
+            fail("Invalid Schema");
+        }
+    }
+
+    @Test
+    public void InputMissingRequiredClaimsOkay() throws JAXBException {
+        String tokenTemplate = "<TokenRestrictionTemplate xmlns:i=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns=\"http://schemas.microsoft.com/Azure/MediaServices/KeyDelivery/TokenRestrictionTemplate/v1\"><AlternateVerificationKeys><TokenVerificationKey i:type=\"SymmetricVerificationKey\"><KeyValue>GG07fDPZ+HMD2vcoknMqYjEJMb7LSq8zUmdCYMvRCevnQK//ilbhODO/FydMrHiwZGmI6XywvOOU7SSzRPlI3Q==</KeyValue></TokenVerificationKey></AlternateVerificationKeys><Audience>http://sampleaudience/</Audience><Issuer>http://sampleissuerurl/</Issuer><PrimaryVerificationKey i:type=\"SymmetricVerificationKey\"><KeyValue>2OvxltHKwILn5PCRD8H+63sK98LBs1yF+ZdZbwzmToWYm29pLyqIMuCvMRGpLOv5DYh3NmpzWMAciu4ncW8VTg==</KeyValue></PrimaryVerificationKey></TokenRestrictionTemplate>";
+
+        TokenRestrictionTemplate template = TokenRestrictionTemplateSerializer.deserialize(tokenTemplate);
+        assertNotNull(template);
+        assertEquals(template.getTokenType(), TokenType.SWT);
+    }
+
+    @Test
+    public void knownGoodGenerateTestTokenSWT() throws Exception {
+        // Arrange
+        String expectedToken = "urn%3amicrosoft%3aazure%3amediaservices%3acontentkeyidentifier=24734598-f050-4cbb-8b98-2dad6eaa260a&Audience=http%3a%2f%2faudience.com&ExpiresOn=1451606400&Issuer=http%3a%2f%2fissuer.com&HMACSHA256=2XrNjMo1EIZflJOovHxt9dekEhb2DhqG9fU5MjQy9vI%3d";
+        byte[] knownSymetricKey = "64bytes6RNhi8EsxcYsdYQ9zpFuNR1Ks9milykbxYWGILaK0LKzd5dCtYonsr456".getBytes();
+        UUID knownGuid = UUID.fromString("24734598-f050-4cbb-8b98-2dad6eaa260a");
+        SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd", Locale.ENGLISH);
+        sdf.setTimeZone(TimeZone.getTimeZone("UTC"));
+        Date knownExpireOn = sdf.parse("2016-01-01");
+        String knownAudience = "http://audience.com";
+        String knownIssuer = "http://issuer.com";
+        TokenRestrictionTemplate template = new TokenRestrictionTemplate(TokenType.SWT);
+        template.setPrimaryVerificationKey(new SymmetricVerificationKey(knownSymetricKey));
+        template.setAudience(new URI(knownAudience));
+        template.setIssuer(new URI(knownIssuer));
+        template.getRequiredClaims().add(TokenClaim.getContentKeyIdentifierClaim());
+
+        // Act
+        String resultsToken = TokenRestrictionTemplateSerializer.generateTestToken(template,
+                template.getPrimaryVerificationKey(), knownGuid, knownExpireOn, null);
+
+        // Assert
+        assertEquals(expectedToken, resultsToken);
+    }
+    
+    @Test
+    public void knownGoodGenerateTestTokenJWT() throws Exception {
+        // Arrange
+        String expectedToken = "eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJleHAiOjE0NTE2MDY0MDAsInVybjptaWNyb3NvZnQ6YXp1cmU6bWVkaWFzZXJ2aWNlczpjb250ZW50a2V5aWRlbnRpZmllciI6IjA5MTQ0MzVkLTE1MDAtODBjNC02YzJiLWYxZTUyZmRhNDdhZSIsImF1ZCI6InVybjpjb250b3NvIiwiaXNzIjoiaHR0cHM6Ly90c3QuY29udG9zby5jb20iLCJpYXQiOjE0MjAwNzA0MDB9.fmjUhGJzWJpnFWnPqTpbisYTs62TJaKM1tAeAweRsSI";
+        byte[] knownSymetricKey = "64bytes6RNhi8EsxcYsdYQ9zpFuNR1Ks9milykbxYWGILaK0LKzd5dCtYonsr456".getBytes();
+        String strUuid = "0914435d-1500-80c4-6c2b-f1e52fda47ae";
+        SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd", Locale.ENGLISH);
+        sdf.setTimeZone(TimeZone.getTimeZone("UTC"));
+        Date notBefore = sdf.parse("2015-01-01");
+        Date expires = sdf.parse("2016-01-01");
+        String knownAudience = "urn:contoso";
+        String knownIssuer = "https://tst.contoso.com";
+        TokenRestrictionTemplate template = new TokenRestrictionTemplate(TokenType.JWT);
+        template.setPrimaryVerificationKey(new SymmetricVerificationKey(knownSymetricKey));
+        template.setAudience(new URI(knownAudience));
+        template.setIssuer(new URI(knownIssuer));
+        template.getRequiredClaims().add(new TokenClaim(TokenClaim.getContentKeyIdentifierClaimType(), strUuid));
+
+        // Act
+        String resultsToken = TokenRestrictionTemplateSerializer.generateTestToken(template, null, null, expires, notBefore);
+
+        // Assert
+        assertEquals(expectedToken, resultsToken);
+    }
+}
diff --git a/media/src/test/resources/schemas/PlayReadyLicenseResponseTemplate.xsd b/media/src/test/resources/schemas/PlayReadyLicenseResponseTemplate.xsd
new file mode 100644
index 0000000..3893715
--- /dev/null
+++ b/media/src/test/resources/schemas/PlayReadyLicenseResponseTemplate.xsd
@@ -0,0 +1,220 @@
+<?xml version="1.0" encoding="utf-8"?>
+<xs:schema xmlns:tns="http://schemas.microsoft.com/Azure/MediaServices/KeyDelivery/PlayReadyTemplate/v1" xmlns:ser="http://schemas.microsoft.com/2003/10/Serialization/" elementFormDefault="qualified" targetNamespace="http://schemas.microsoft.com/Azure/MediaServices/KeyDelivery/PlayReadyTemplate/v1" xmlns:xs="http://www.w3.org/2001/XMLSchema">
+  <xs:import namespace="http://schemas.microsoft.com/2003/10/Serialization/" />
+  <xs:complexType name="AgcAndColorStripeRestriction">
+    <xs:sequence>
+      <xs:element minOccurs="0" name="ConfigurationData" type="xs:unsignedByte" />
+    </xs:sequence>
+  </xs:complexType>
+  <xs:element name="AgcAndColorStripeRestriction" nillable="true" type="tns:AgcAndColorStripeRestriction" />
+  <xs:simpleType name="ContentType">
+    <xs:restriction base="xs:string">
+      <xs:enumeration value="Unspecified" />
+      <xs:enumeration value="UltravioletDownload" />
+      <xs:enumeration value="UltravioletStreaming" />
+    </xs:restriction>
+  </xs:simpleType>
+  <xs:element name="ContentType" nillable="true" type="tns:ContentType" />
+  <xs:complexType name="ExplicitAnalogTelevisionRestriction">
+    <xs:sequence>
+      <xs:element minOccurs="0" name="BestEffort" type="xs:boolean" />
+      <xs:element minOccurs="0" name="ConfigurationData" type="xs:unsignedByte" />
+    </xs:sequence>
+  </xs:complexType>
+  <xs:element name="ExplicitAnalogTelevisionRestriction" nillable="true" type="tns:ExplicitAnalogTelevisionRestriction" />
+  <xs:complexType name="PlayReadyContentKey">
+    <xs:sequence />
+  </xs:complexType>
+  <xs:element name="PlayReadyContentKey" nillable="true" type="tns:PlayReadyContentKey" />
+  <xs:complexType name="ContentEncryptionKeyFromHeader">
+    <xs:complexContent mixed="false">
+      <xs:extension base="tns:PlayReadyContentKey">
+        <xs:sequence />
+      </xs:extension>
+    </xs:complexContent>
+  </xs:complexType>
+  <xs:element name="ContentEncryptionKeyFromHeader" nillable="true" type="tns:ContentEncryptionKeyFromHeader" />
+  <xs:complexType name="ContentEncryptionKeyFromKeyIdentifier">
+    <xs:complexContent mixed="false">
+      <xs:extension base="tns:PlayReadyContentKey">
+        <xs:sequence>
+          <xs:element minOccurs="0" name="KeyIdentifier" type="ser:guid" />
+        </xs:sequence>
+      </xs:extension>
+    </xs:complexContent>
+  </xs:complexType>
+  <xs:element name="ContentEncryptionKeyFromKeyIdentifier" nillable="true" type="tns:ContentEncryptionKeyFromKeyIdentifier" />
+  <xs:complexType name="PlayReadyLicenseResponseTemplate">
+    <xs:sequence>
+      <xs:element name="LicenseTemplates" nillable="true" type="tns:ArrayOfPlayReadyLicenseTemplate" />
+      <xs:element minOccurs="0" name="ResponseCustomData" nillable="true" type="xs:string">
+        <xs:annotation>
+          <xs:appinfo>
+            <DefaultValue EmitDefaultValue="false" xmlns="http://schemas.microsoft.com/2003/10/Serialization/" />
+          </xs:appinfo>
+        </xs:annotation>
+      </xs:element>
+    </xs:sequence>
+  </xs:complexType>
+  <xs:element name="PlayReadyLicenseResponseTemplate" nillable="true" type="tns:PlayReadyLicenseResponseTemplate" />
+  <xs:complexType name="ArrayOfPlayReadyLicenseTemplate">
+    <xs:sequence>
+      <xs:element minOccurs="0" maxOccurs="unbounded" name="PlayReadyLicenseTemplate" nillable="true" type="tns:PlayReadyLicenseTemplate" />
+    </xs:sequence>
+  </xs:complexType>
+  <xs:element name="ArrayOfPlayReadyLicenseTemplate" nillable="true" type="tns:ArrayOfPlayReadyLicenseTemplate" />
+  <xs:complexType name="PlayReadyLicenseTemplate">
+    <xs:sequence>
+      <xs:element minOccurs="0" name="AllowTestDevices" type="xs:boolean" />
+      <xs:element minOccurs="0" name="BeginDate" nillable="true" type="xs:dateTime">
+        <xs:annotation>
+          <xs:appinfo>
+            <DefaultValue EmitDefaultValue="false" xmlns="http://schemas.microsoft.com/2003/10/Serialization/" />
+          </xs:appinfo>
+        </xs:annotation>
+      </xs:element>
+      <xs:element name="ContentKey" nillable="true" type="tns:PlayReadyContentKey" />
+      <xs:element minOccurs="0" name="ContentType" type="tns:ContentType">
+        <xs:annotation>
+          <xs:appinfo>
+            <DefaultValue EmitDefaultValue="false" xmlns="http://schemas.microsoft.com/2003/10/Serialization/" />
+          </xs:appinfo>
+        </xs:annotation>
+      </xs:element>
+      <xs:element minOccurs="0" name="ExpirationDate" nillable="true" type="xs:dateTime">
+        <xs:annotation>
+          <xs:appinfo>
+            <DefaultValue EmitDefaultValue="false" xmlns="http://schemas.microsoft.com/2003/10/Serialization/" />
+          </xs:appinfo>
+        </xs:annotation>
+      </xs:element>
+      <xs:element minOccurs="0" name="GracePeriod" nillable="true" type="ser:duration">
+        <xs:annotation>
+          <xs:appinfo>
+            <DefaultValue EmitDefaultValue="false" xmlns="http://schemas.microsoft.com/2003/10/Serialization/" />
+          </xs:appinfo>
+        </xs:annotation>
+      </xs:element>
+      <xs:element minOccurs="0" name="LicenseType" type="tns:PlayReadyLicenseType" />
+      <xs:element minOccurs="0" name="PlayRight" nillable="true" type="tns:PlayReadyPlayRight" />
+    </xs:sequence>
+  </xs:complexType>
+  <xs:element name="PlayReadyLicenseTemplate" nillable="true" type="tns:PlayReadyLicenseTemplate" />
+  <xs:simpleType name="PlayReadyLicenseType">
+    <xs:restriction base="xs:string">
+      <xs:enumeration value="Nonpersistent" />
+      <xs:enumeration value="Persistent" />
+    </xs:restriction>
+  </xs:simpleType>
+  <xs:element name="PlayReadyLicenseType" nillable="true" type="tns:PlayReadyLicenseType" />
+  <xs:complexType name="PlayReadyPlayRight">
+    <xs:sequence>
+      <xs:element minOccurs="0" name="AgcAndColorStripeRestriction" nillable="true" type="tns:AgcAndColorStripeRestriction">
+        <xs:annotation>
+          <xs:appinfo>
+            <DefaultValue EmitDefaultValue="false" xmlns="http://schemas.microsoft.com/2003/10/Serialization/" />
+          </xs:appinfo>
+        </xs:annotation>
+      </xs:element>
+      <xs:element minOccurs="0" name="AllowPassingVideoContentToUnknownOutput" type="tns:UnknownOutputPassingOption">
+        <xs:annotation>
+          <xs:appinfo>
+            <DefaultValue EmitDefaultValue="false" xmlns="http://schemas.microsoft.com/2003/10/Serialization/" />
+          </xs:appinfo>
+        </xs:annotation>
+      </xs:element>
+      <xs:element minOccurs="0" name="AnalogVideoOpl" nillable="true" type="xs:int">
+        <xs:annotation>
+          <xs:appinfo>
+            <DefaultValue EmitDefaultValue="false" xmlns="http://schemas.microsoft.com/2003/10/Serialization/" />
+          </xs:appinfo>
+        </xs:annotation>
+      </xs:element>
+      <xs:element minOccurs="0" name="CompressedDigitalAudioOpl" nillable="true" type="xs:int">
+        <xs:annotation>
+          <xs:appinfo>
+            <DefaultValue EmitDefaultValue="false" xmlns="http://schemas.microsoft.com/2003/10/Serialization/" />
+          </xs:appinfo>
+        </xs:annotation>
+      </xs:element>
+      <xs:element minOccurs="0" name="CompressedDigitalVideoOpl" nillable="true" type="xs:int">
+        <xs:annotation>
+          <xs:appinfo>
+            <DefaultValue EmitDefaultValue="false" xmlns="http://schemas.microsoft.com/2003/10/Serialization/" />
+          </xs:appinfo>
+        </xs:annotation>
+      </xs:element>
+      <xs:element minOccurs="0" name="DigitalVideoOnlyContentRestriction" type="xs:boolean">
+        <xs:annotation>
+          <xs:appinfo>
+            <DefaultValue EmitDefaultValue="false" xmlns="http://schemas.microsoft.com/2003/10/Serialization/" />
+          </xs:appinfo>
+        </xs:annotation>
+      </xs:element>
+      <xs:element minOccurs="0" name="ExplicitAnalogTelevisionOutputRestriction" nillable="true" type="tns:ExplicitAnalogTelevisionRestriction">
+        <xs:annotation>
+          <xs:appinfo>
+            <DefaultValue EmitDefaultValue="false" xmlns="http://schemas.microsoft.com/2003/10/Serialization/" />
+          </xs:appinfo>
+        </xs:annotation>
+      </xs:element>
+      <xs:element minOccurs="0" name="FirstPlayExpiration" nillable="true" type="ser:duration">
+        <xs:annotation>
+          <xs:appinfo>
+            <DefaultValue EmitDefaultValue="false" xmlns="http://schemas.microsoft.com/2003/10/Serialization/" />
+          </xs:appinfo>
+        </xs:annotation>
+      </xs:element>
+      <xs:element minOccurs="0" name="ImageConstraintForAnalogComponentVideoRestriction" type="xs:boolean">
+        <xs:annotation>
+          <xs:appinfo>
+            <DefaultValue EmitDefaultValue="false" xmlns="http://schemas.microsoft.com/2003/10/Serialization/" />
+          </xs:appinfo>
+        </xs:annotation>
+      </xs:element>
+      <xs:element minOccurs="0" name="ImageConstraintForAnalogComputerMonitorRestriction" type="xs:boolean">
+        <xs:annotation>
+          <xs:appinfo>
+            <DefaultValue EmitDefaultValue="false" xmlns="http://schemas.microsoft.com/2003/10/Serialization/" />
+          </xs:appinfo>
+        </xs:annotation>
+      </xs:element>
+      <xs:element minOccurs="0" name="ScmsRestriction" nillable="true" type="tns:ScmsRestriction">
+        <xs:annotation>
+          <xs:appinfo>
+            <DefaultValue EmitDefaultValue="false" xmlns="http://schemas.microsoft.com/2003/10/Serialization/" />
+          </xs:appinfo>
+        </xs:annotation>
+      </xs:element>
+      <xs:element minOccurs="0" name="UncompressedDigitalAudioOpl" nillable="true" type="xs:int">
+        <xs:annotation>
+          <xs:appinfo>
+            <DefaultValue EmitDefaultValue="false" xmlns="http://schemas.microsoft.com/2003/10/Serialization/" />
+          </xs:appinfo>
+        </xs:annotation>
+      </xs:element>
+      <xs:element minOccurs="0" name="UncompressedDigitalVideoOpl" nillable="true" type="xs:int">
+        <xs:annotation>
+          <xs:appinfo>
+            <DefaultValue EmitDefaultValue="false" xmlns="http://schemas.microsoft.com/2003/10/Serialization/" />
+          </xs:appinfo>
+        </xs:annotation>
+      </xs:element>
+    </xs:sequence>
+  </xs:complexType>
+  <xs:element name="PlayReadyPlayRight" nillable="true" type="tns:PlayReadyPlayRight" />
+  <xs:simpleType name="UnknownOutputPassingOption">
+    <xs:restriction base="xs:string">
+      <xs:enumeration value="NotAllowed" />
+      <xs:enumeration value="Allowed" />
+      <xs:enumeration value="AllowedWithVideoConstriction" />
+    </xs:restriction>
+  </xs:simpleType>
+  <xs:element name="UnknownOutputPassingOption" nillable="true" type="tns:UnknownOutputPassingOption" />
+  <xs:complexType name="ScmsRestriction">
+    <xs:sequence>
+      <xs:element minOccurs="0" name="ConfigurationData" type="xs:unsignedByte" />
+    </xs:sequence>
+  </xs:complexType>
+  <xs:element name="ScmsRestriction" nillable="true" type="tns:ScmsRestriction" />
+</xs:schema>
\ No newline at end of file
diff --git a/media/src/test/resources/schemas/TokenRestrictionTemplate.xsd b/media/src/test/resources/schemas/TokenRestrictionTemplate.xsd
new file mode 100644
index 0000000..06d7659
--- /dev/null
+++ b/media/src/test/resources/schemas/TokenRestrictionTemplate.xsd
@@ -0,0 +1,46 @@
+<?xml version="1.0" encoding="utf-8"?>
+<xs:schema xmlns:tns="http://schemas.microsoft.com/Azure/MediaServices/KeyDelivery/TokenRestrictionTemplate/v1" elementFormDefault="qualified" targetNamespace="http://schemas.microsoft.com/Azure/MediaServices/KeyDelivery/TokenRestrictionTemplate/v1" xmlns:xs="http://www.w3.org/2001/XMLSchema">
+  <xs:complexType name="TokenClaim">
+    <xs:sequence>
+      <xs:element name="ClaimType" nillable="true" type="xs:string" />
+      <xs:element minOccurs="0" name="ClaimValue" nillable="true" type="xs:string" />
+    </xs:sequence>
+  </xs:complexType>
+  <xs:element name="TokenClaim" nillable="true" type="tns:TokenClaim" />
+  <xs:complexType name="TokenRestrictionTemplate">
+    <xs:sequence>
+      <xs:element minOccurs="0" name="AlternateVerificationKeys" nillable="true" type="tns:ArrayOfTokenVerificationKey" />
+      <xs:element name="Audience" nillable="true" type="xs:anyURI" />
+      <xs:element name="Issuer" nillable="true" type="xs:anyURI" />
+      <xs:element name="PrimaryVerificationKey" nillable="true" type="tns:TokenVerificationKey" />
+      <xs:element minOccurs="0" name="RequiredClaims" nillable="true" type="tns:ArrayOfTokenClaim" />
+    </xs:sequence>
+  </xs:complexType>
+  <xs:element name="TokenRestrictionTemplate" nillable="true" type="tns:TokenRestrictionTemplate" />
+  <xs:complexType name="ArrayOfTokenVerificationKey">
+    <xs:sequence>
+      <xs:element minOccurs="0" maxOccurs="unbounded" name="TokenVerificationKey" nillable="true" type="tns:TokenVerificationKey" />
+    </xs:sequence>
+  </xs:complexType>
+  <xs:element name="ArrayOfTokenVerificationKey" nillable="true" type="tns:ArrayOfTokenVerificationKey" />
+  <xs:complexType name="TokenVerificationKey">
+    <xs:sequence />
+  </xs:complexType>
+  <xs:element name="TokenVerificationKey" nillable="true" type="tns:TokenVerificationKey" />
+  <xs:complexType name="ArrayOfTokenClaim">
+    <xs:sequence>
+      <xs:element minOccurs="0" maxOccurs="unbounded" name="TokenClaim" nillable="true" type="tns:TokenClaim" />
+    </xs:sequence>
+  </xs:complexType>
+  <xs:element name="ArrayOfTokenClaim" nillable="true" type="tns:ArrayOfTokenClaim" />
+  <xs:complexType name="SymmetricVerificationKey">
+    <xs:complexContent mixed="false">
+      <xs:extension base="tns:TokenVerificationKey">
+        <xs:sequence>
+          <xs:element name="KeyValue" nillable="true" type="xs:base64Binary" />
+        </xs:sequence>
+      </xs:extension>
+    </xs:complexContent>
+  </xs:complexType>
+  <xs:element name="SymmetricVerificationKey" nillable="true" type="tns:SymmetricVerificationKey" />
+</xs:schema>
\ No newline at end of file
diff --git a/parent/src/config/checkstyle.xml b/parent/src/config/checkstyle.xml
index face53f..45d166c 100644
--- a/parent/src/config/checkstyle.xml
+++ b/parent/src/config/checkstyle.xml
@@ -219,11 +219,7 @@
         <!-- Added ignore. Code is generated so magic numbers are not a largish issue. -->
         <!-- <module name="MagicNumber" /> -->
         <module name="MissingSwitchDefault"/>
-        <module name="RedundantThrows">
-            <property name="allowUnchecked" value="true"/>
-            <property name="allowSubclasses" value="true"/>
-            <property name="suppressLoadErrors" value="true"/>
-        </module>
+        
         <!-- <module name="SimplifyBooleanExpression"/> -->
         <!-- <module name="SimplifyBooleanReturn"/> -->
 
-- 
1.9.5.msysgit.1


From 47a4cbbae0a072428247ddd2f13fd3a5c5610b53 Mon Sep 17 00:00:00 2001
From: Emanuel Vecchio <vecchioemanuel@gmail.com>
Date: Thu, 23 Jul 2015 15:50:10 -0300
Subject: [PATCH 06/21] New entities:

PlayReadyPlayRight, PlayReadyLicenseTemplate,
PlayReadyLicenseResponseTemplate. Also we added the
MediaServicesLicenseTemplateSerializer helper class.
---
 .../services/media/EncryptionUtils.java            |  71 ++-
 .../MediaServicesLicenseTemplateSerializer.java    | 177 +++++++
 .../playreadylicense/PlayReadyContentKey.java      |   2 +-
 .../PlayReadyLicenseResponseTemplate.java          |  80 +++
 .../playreadylicense/PlayReadyLicenseTemplate.java | 214 ++++++++
 .../playreadylicense/PlayReadyPlayRight.java       | 277 +++++++++++
 .../tokenrestriction/TokenVerificationKey.java     |   2 +-
 .../services/media/IntegrationTestBase.java        |   4 +-
 ...ediaServicesLicenseTemplateSerializerTests.java | 542 +++++++++++++++++++++
 .../playreadylicense/PlayReadyPlayRightTest.java   |  31 ++
 .../services/scenarios/MediaServiceValidation.java |   4 +-
 11 files changed, 1381 insertions(+), 23 deletions(-)
 create mode 100644 media/src/main/java/com/microsoft/windowsazure/services/media/implementation/templates/playreadylicense/MediaServicesLicenseTemplateSerializer.java
 create mode 100644 media/src/main/java/com/microsoft/windowsazure/services/media/implementation/templates/playreadylicense/PlayReadyLicenseResponseTemplate.java
 create mode 100644 media/src/main/java/com/microsoft/windowsazure/services/media/implementation/templates/playreadylicense/PlayReadyLicenseTemplate.java
 create mode 100644 media/src/main/java/com/microsoft/windowsazure/services/media/implementation/templates/playreadylicense/PlayReadyPlayRight.java
 create mode 100644 media/src/test/java/com/microsoft/windowsazure/services/media/implementation/templates/playreadylicense/MediaServicesLicenseTemplateSerializerTests.java
 create mode 100644 media/src/test/java/com/microsoft/windowsazure/services/media/implementation/templates/playreadylicense/PlayReadyPlayRightTest.java

diff --git a/media/src/main/java/com/microsoft/windowsazure/services/media/EncryptionUtils.java b/media/src/main/java/com/microsoft/windowsazure/services/media/EncryptionUtils.java
index 2bd0596..a188426 100644
--- a/media/src/main/java/com/microsoft/windowsazure/services/media/EncryptionUtils.java
+++ b/media/src/main/java/com/microsoft/windowsazure/services/media/EncryptionUtils.java
@@ -1,32 +1,50 @@
 package com.microsoft.windowsazure.services.media;
 
+import java.security.Key;
+import java.security.MessageDigest;
 import java.security.NoSuchAlgorithmException;
 import java.security.SecureRandom;
+import java.security.cert.CertificateEncodingException;
+import java.security.cert.X509Certificate;
+import java.util.UUID;
 
-public final class EncryptionUtils {
-
-    public final String keyIdentifierPrefix = "nb:kid:UUID:";
-
-    /// The key size for AEI 128.
-    public final int keySizeInBytesForAes128 = 16;
-
-    /// The key size for AEI 256.
-    public final int keySizeInBytesForAes256 = 32;
-
-    /// The key size for AEI 128 in bits.
-    public final int keySizeInBitsForAes128 = 128;
+import javax.crypto.Cipher;
+import javax.crypto.spec.SecretKeySpec;
 
-    /// The key size for AEI 256 in bits.
-    public final int keySizeInBitsForAes256 = 256;
+import com.microsoft.windowsazure.core.utils.Base64;
 
-    /// The IV size for AEI Cbc.
-    public final int iVSizeInBytesForAesCbc = 16;
+public final class EncryptionUtils {
 
     // Enforce noninstantiability with a private constructor
     private EncryptionUtils() {
         // not called
     }
 
+    public static byte[] encryptSymmetricKeyData(X509Certificate certificate, byte[] contentKey) {
+        try {
+            Cipher cipher = Cipher.getInstance("RSA/ECB/OAEPWithSHA-1AndMGF1Padding");
+            Key publicKey = certificate.getPublicKey();
+            cipher.init(Cipher.ENCRYPT_MODE, publicKey, new SecureRandom());
+            return cipher.doFinal(contentKey);
+        } catch (Exception e) {
+            throw new RuntimeException(e);
+        }
+    }
+
+    public static String calculateChecksum(byte[] contentKey, UUID contentKeyIdUuid) {
+        try {
+            Cipher cipher = Cipher.getInstance("AES/ECB/PKCS5Padding");
+            SecretKeySpec secretKeySpec = new SecretKeySpec(contentKey, "AES");
+            cipher.init(Cipher.ENCRYPT_MODE, secretKeySpec);
+            byte[] encryptionResult = cipher.doFinal(contentKeyIdUuid.toString().getBytes("UTF8"));
+            byte[] checksumByteArray = new byte[8];
+            System.arraycopy(encryptionResult, 0, checksumByteArray, 0, 8);
+            return Base64.encode(checksumByteArray);
+        } catch (Exception e) {
+            throw new RuntimeException(e);
+        }
+    }
+
     /**
      * Overwrites the supplied byte array with RNG generated data which destroys
      * the original contents.
@@ -45,4 +63,23 @@ public final class EncryptionUtils {
             }
         }
     }
-}
+
+    public static String getThumbPrint(X509Certificate cert)
+            throws NoSuchAlgorithmException, CertificateEncodingException {
+        MessageDigest md = MessageDigest.getInstance("SHA-1");
+        byte[] der = cert.getEncoded();
+        md.update(der);
+        byte[] digest = md.digest();
+        return hexify(digest);
+    }
+
+    public static String hexify(byte[] bytes) {
+        char[] hexDigits = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'};
+        StringBuffer buf = new StringBuffer(bytes.length * 2);
+        for (int i = 0; i < bytes.length; ++i) {
+            buf.append(hexDigits[(bytes[i] & 0xf0) >> 4]);
+            buf.append(hexDigits[bytes[i] & 0x0f]);
+        }
+        return buf.toString();
+    }
+}
\ No newline at end of file
diff --git a/media/src/main/java/com/microsoft/windowsazure/services/media/implementation/templates/playreadylicense/MediaServicesLicenseTemplateSerializer.java b/media/src/main/java/com/microsoft/windowsazure/services/media/implementation/templates/playreadylicense/MediaServicesLicenseTemplateSerializer.java
new file mode 100644
index 0000000..65b1568
--- /dev/null
+++ b/media/src/main/java/com/microsoft/windowsazure/services/media/implementation/templates/playreadylicense/MediaServicesLicenseTemplateSerializer.java
@@ -0,0 +1,177 @@
+package com.microsoft.windowsazure.services.media.implementation.templates.playreadylicense;
+
+import java.io.File;
+import java.io.StringReader;
+import java.io.StringWriter;
+
+import javax.xml.XMLConstants;
+import javax.xml.bind.JAXBContext;
+import javax.xml.bind.JAXBException;
+import javax.xml.bind.Marshaller;
+import javax.xml.bind.Unmarshaller;
+import javax.xml.validation.Schema;
+import javax.xml.validation.SchemaFactory;
+
+import org.xml.sax.SAXException;
+
+import com.sun.xml.bind.marshaller.NamespacePrefixMapper;
+
+public final class MediaServicesLicenseTemplateSerializer {
+
+    private MediaServicesLicenseTemplateSerializer() {
+
+    }
+
+    public static String serialize(PlayReadyLicenseResponseTemplate template) throws JAXBException {
+
+        validateLicenseResponseTemplate(template);
+
+        StringWriter writer = new StringWriter();
+        JAXBContext context = JAXBContext.newInstance(PlayReadyLicenseResponseTemplate.class);
+        Marshaller m = context.createMarshaller();
+        m.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, true);
+        m.setProperty("com.sun.xml.bind.namespacePrefixMapper", new NamespacePrefixMapper() {
+            @Override
+            public String[] getPreDeclaredNamespaceUris() {
+                return new String[] { 
+                        XMLConstants.W3C_XML_SCHEMA_INSTANCE_NS_URI 
+                        };
+            }
+
+            @Override
+            public String getPreferredPrefix(String namespaceUri, String suggestion, boolean requirePrefix) {
+                if (namespaceUri.equals(XMLConstants.W3C_XML_SCHEMA_INSTANCE_NS_URI)) {
+                    return "i";
+                }
+                return suggestion;
+            }
+        });
+        m.marshal(template, writer);
+        return writer.toString();
+    }
+
+    public static PlayReadyLicenseResponseTemplate deserialize(String xml) throws JAXBException {
+        try {
+            return deserialize(xml, null);
+        } catch (SAXException e) {
+            // never reached.
+            return null;
+        }
+    }
+
+    public static PlayReadyLicenseResponseTemplate deserialize(String xml, String validationSchemaFileName)
+            throws JAXBException, SAXException {
+        JAXBContext context = JAXBContext.newInstance(PlayReadyLicenseResponseTemplate.class);
+        Unmarshaller u = context.createUnmarshaller();
+        if (validationSchemaFileName != null) {
+            SchemaFactory factory = SchemaFactory.newInstance("http://www.w3.org/2001/XMLSchema");
+            Schema schema = factory.newSchema(new File(validationSchemaFileName));
+            u.setSchema(schema);
+        }
+        PlayReadyLicenseResponseTemplate template = (PlayReadyLicenseResponseTemplate) u
+                .unmarshal(new StringReader(xml));
+
+        validateLicenseResponseTemplate(template);
+
+        return template;
+    }
+
+    private static void validateLicenseResponseTemplate(PlayReadyLicenseResponseTemplate templateToValidate) {
+        // Validate the PlayReadyLicenseResponseTemplate has at least one
+        // license
+        if (templateToValidate.getLicenseTemplates().size() <= 0) {
+            throw new IllegalArgumentException(ErrorMessages.AT_LEAST_ONE_LICENSE_TEMPLATE_REQUIRED);
+        }
+
+        for (PlayReadyLicenseTemplate template : templateToValidate.getLicenseTemplates()) {
+            // This is actually enforced in the DataContract with the IsRequired
+            // attribute
+            // so this check should never fail.
+            if (template.getContentKey() == null) {
+                throw new IllegalArgumentException(ErrorMessages.PLAY_READY_CONTENT_KEY_REQUIRED);
+            }
+
+            // A PlayReady license must have at least one Right in it. Today we
+            // only
+            // support the PlayRight so it is required. In the future we might
+            // support
+            // other types of rights (CopyRight, perhaps an extensible Right,
+            // whatever)
+            // so we enforce this in code and not in the DataContract itself.
+            if (template.getPlayRight() == null) {
+                throw new IllegalArgumentException(ErrorMessages.PLAY_READY_PLAY_RIGHT_REQUIRED);
+            }
+
+            //
+            // Per the PlayReady Compliance rules (section 3.8 - Output Control
+            // for Unknown Outputs), passing content to
+            // unknown output is prohibited if the
+            // DigitalVideoOnlyContentRestriction is enabled.
+            //
+            if (template.getPlayRight().isDigitalVideoOnlyContentRestriction()) {
+                if ((template.getPlayRight()
+                        .getAllowPassingVideoContentToUnknownOutput() == UnknownOutputPassingOption.Allowed)
+                        || (template.getPlayRight()
+                                .getAllowPassingVideoContentToUnknownOutput() == UnknownOutputPassingOption.AllowedWithVideoConstriction)) {
+                    throw new IllegalArgumentException(
+                            ErrorMessages.DIGITAL_VIDEO_ONLY_MUTUALLY_EXCLUSIVE_WITH_PASSING_TO_UNKNOWN_OUTPUT_ERROR);
+                }
+            }
+
+            if (template.getLicenseType() == PlayReadyLicenseType.Nonpersistent) {
+                //
+                // The PlayReady Rights Manager SDK will return an error if you
+                // try to specify a license
+                // that is non-persistent and has a first play expiration set.
+                // The event log message related
+                // to the error will say "LicenseGenerationFailure:
+                // FirstPlayExpiration can not be set on Non
+                // Persistent license PlayRight."
+                //
+                if (template.getPlayRight().getFirstPlayExpiration() != null) {
+                    throw new IllegalArgumentException(
+                            ErrorMessages.FIRST_PLAY_EXPIRATION_CANNOT_BE_SET_ON_NON_PERSISTENT_LICENSE);
+                }
+
+                //
+                // The PlayReady Rights Manager SDK will return an error if you
+                // try to specify a license
+                // that is non-persistent and has a GracePeriod set.
+                //
+                if (template.getGracePeriod() != null) {
+                    throw new IllegalArgumentException(
+                            ErrorMessages.GRACE_PERIOD_CANNOT_BE_SET_ON_NON_PERSISTENT_LICENSE);
+                }
+
+                //
+                // The PlayReady Rights Manager SDK will return an error if you
+                // try to specify a license
+                // that is non-persistent and has a GracePeriod set. The event
+                // log message related
+                // to the error will say "LicenseGenerationFailure: BeginDate or
+                // ExpirationDate should not be set
+                // on Non Persistent licenses"
+                //
+                if (template.getBeginDate() != null) {
+                    throw new IllegalArgumentException(
+                            ErrorMessages.BEGIN_DATE_CANNOT_BE_SET_ON_NON_PERSISTENT_LICENSE);
+                }
+
+                //
+                // The PlayReady Rights Manager SDK will return an error if you
+                // try to specify a license
+                // that is non-persistent and has a GracePeriod set. The event
+                // log message related
+                // to the error will say "LicenseGenerationFailure: BeginDate or
+                // ExpirationDate should not be set
+                // on Non Persistent licenses"
+                //
+                if (template.getExpirationDate() != null) {
+                    throw new IllegalArgumentException(
+                            ErrorMessages.EXPIRATION_CANNOT_BE_SET_ON_NON_PERSISTENT_LICENSE);
+                }
+            }
+        }
+
+    }
+}
diff --git a/media/src/main/java/com/microsoft/windowsazure/services/media/implementation/templates/playreadylicense/PlayReadyContentKey.java b/media/src/main/java/com/microsoft/windowsazure/services/media/implementation/templates/playreadylicense/PlayReadyContentKey.java
index cc045b4..93e99cf 100644
--- a/media/src/main/java/com/microsoft/windowsazure/services/media/implementation/templates/playreadylicense/PlayReadyContentKey.java
+++ b/media/src/main/java/com/microsoft/windowsazure/services/media/implementation/templates/playreadylicense/PlayReadyContentKey.java
@@ -4,7 +4,7 @@ import javax.xml.bind.annotation.XmlSeeAlso;
 import javax.xml.bind.annotation.XmlTransient;
 
 @XmlTransient
-@XmlSeeAlso({ContentEncryptionKeyFromHeader.class, ContentEncryptionKeyFromKeyIdentifier.class})
+@XmlSeeAlso({ ContentEncryptionKeyFromHeader.class, ContentEncryptionKeyFromKeyIdentifier.class })
 public abstract class PlayReadyContentKey {
 
 }
diff --git a/media/src/main/java/com/microsoft/windowsazure/services/media/implementation/templates/playreadylicense/PlayReadyLicenseResponseTemplate.java b/media/src/main/java/com/microsoft/windowsazure/services/media/implementation/templates/playreadylicense/PlayReadyLicenseResponseTemplate.java
new file mode 100644
index 0000000..2be14c9
--- /dev/null
+++ b/media/src/main/java/com/microsoft/windowsazure/services/media/implementation/templates/playreadylicense/PlayReadyLicenseResponseTemplate.java
@@ -0,0 +1,80 @@
+package com.microsoft.windowsazure.services.media.implementation.templates.playreadylicense;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import javax.xml.bind.Element;
+import javax.xml.bind.annotation.XmlAccessType;
+import javax.xml.bind.annotation.XmlAccessorType;
+import javax.xml.bind.annotation.XmlAnyElement;
+import javax.xml.bind.annotation.XmlElement;
+import javax.xml.bind.annotation.XmlElementWrapper;
+import javax.xml.bind.annotation.XmlRootElement;
+
+@XmlRootElement(name = "PlayReadyLicenseResponseTemplate")
+@XmlAccessorType(XmlAccessType.FIELD)
+public class PlayReadyLicenseResponseTemplate {
+    
+    @XmlElementWrapper(name = "LicenseTemplates")
+    @XmlElement(name = "PlayReadyLicenseTemplate")
+    private List<PlayReadyLicenseTemplate> licenseTemplates;
+    
+    @XmlElement(name = "ResponseCustomData")
+    private String responseCustomData;
+    
+    // mimics IExtensibleDataObject
+    @XmlAnyElement
+    private List<Element> extensionData;
+    
+    public PlayReadyLicenseResponseTemplate() {
+        internalConstruct();
+    }
+
+    private void internalConstruct() {
+        setLicenseTemplates(new ArrayList<PlayReadyLicenseTemplate>());
+        setExtensionData(new ArrayList<Element>());
+    }
+
+    /**
+     * @return the licenseTemplates
+     */
+    public List<PlayReadyLicenseTemplate> getLicenseTemplates() {
+        return licenseTemplates;
+    }
+
+    /**
+     * @param licenseTemplates the licenseTemplates to set
+     */
+    private void setLicenseTemplates(List<PlayReadyLicenseTemplate> licenseTemplates) {
+        this.licenseTemplates = licenseTemplates;
+    }
+    
+    /**
+     * @return the responseCustomData
+     */
+    public String getResponseCustomData() {
+        return responseCustomData;
+    }
+
+    /**
+     * @param responseCustomData the responseCustomData to set
+     */
+    public void setResponseCustomData(String responseCustomData) {
+        this.responseCustomData = responseCustomData;
+    }
+
+    /**
+     * @return the extensionData
+     */
+    public List<Element> getExtensionData() {
+        return extensionData;
+    }
+
+    /**
+     * @param extensionData the extensionData to set
+     */
+    public void setExtensionData(List<Element> extensionData) {
+        this.extensionData = extensionData;
+    }
+    
+}
diff --git a/media/src/main/java/com/microsoft/windowsazure/services/media/implementation/templates/playreadylicense/PlayReadyLicenseTemplate.java b/media/src/main/java/com/microsoft/windowsazure/services/media/implementation/templates/playreadylicense/PlayReadyLicenseTemplate.java
new file mode 100644
index 0000000..75c25d4
--- /dev/null
+++ b/media/src/main/java/com/microsoft/windowsazure/services/media/implementation/templates/playreadylicense/PlayReadyLicenseTemplate.java
@@ -0,0 +1,214 @@
+package com.microsoft.windowsazure.services.media.implementation.templates.playreadylicense;
+
+import java.util.Date;
+import java.util.List;
+
+import javax.xml.bind.Element;
+import javax.xml.bind.annotation.XmlAccessType;
+import javax.xml.bind.annotation.XmlAccessorType;
+import javax.xml.bind.annotation.XmlAnyElement;
+import javax.xml.bind.annotation.XmlElement;
+import javax.xml.bind.annotation.XmlType;
+import javax.xml.datatype.Duration;
+
+@XmlAccessorType(XmlAccessType.FIELD)
+@XmlType(name = "PlayReadyLicenseTemplate")
+public class PlayReadyLicenseTemplate {
+    
+    @XmlElement(name = "AllowTestDevices")
+    private boolean allowTestDevices;
+    
+    @XmlElement(name = "BeginDate")
+    private Date beginDate;
+    
+    @XmlElement(name = "ContentKey")
+    private PlayReadyContentKey contentKey;
+    
+    @XmlElement(name = "ExpirationDate")
+    private Date expirationDate;
+    
+    @XmlElement(name = "GracePeriod")
+    private Duration gracePeriod;
+    
+    @XmlElement(name = "LicenseType")
+    private PlayReadyLicenseType licenseType; 
+    
+    @XmlElement(name = "PlayRight")
+    private PlayReadyPlayRight playRight;    
+    
+    @XmlElement(name = "RelativeBeginDate")
+    private Duration relativeBeginDate;
+    
+    @XmlElement(name = "RelativeExpirationDate")
+    private Duration relativeExpirationDate;
+    
+    // mimics IExtensibleDataObject
+    @XmlAnyElement
+    private List<Element> extensionData;
+
+
+    /**
+     * @return the allowTestDevices
+     */
+    public boolean isAllowTestDevices() {
+        return allowTestDevices;
+    }
+
+    /**
+     * @param allowTestDevices the allowTestDevices to set
+     */
+    public void setAllowTestDevices(boolean allowTestDevices) {
+        this.allowTestDevices = allowTestDevices;
+    }
+
+    /**
+     * @return the beginDate
+     */
+    public Date getBeginDate() {
+        return beginDate;
+    }
+
+    /**
+     * @param beginDate the beginDate to set
+     */
+    public void setBeginDate(Date beginDate) {
+        //
+        //  License template should not have both BeginDate and RelativeBeginDate set.
+        //  Only one of these two values should be set.
+        if (relativeBeginDate != null) {            
+            throw new IllegalArgumentException(ErrorMessages.BEGIN_DATE_AND_RELATIVE_BEGIN_DATE_CANNOTBE_SET_SIMULTANEOUSLY_ERROR);
+        }
+        this.beginDate = beginDate;
+    }
+
+    /**
+     * @return the expirationDate
+     */
+    public Date getExpirationDate() {
+       return expirationDate;
+    }
+
+    /**
+     * @param expirationDate the expirationDate to set
+     */
+    public void setExpirationDate(Date expirationDate) {
+        //
+        //  License template should not have both ExpirationDate and RelativeExpirationDate set.
+        //  Only one of these two values should be set.
+        if (relativeExpirationDate != null) {
+            throw new IllegalArgumentException("Set ExpirationDate or RelativeExpirationDate but not both");
+        }
+        this.expirationDate = expirationDate;
+    }
+
+    /**
+     * @return the relativeBeginDate
+     */
+    public Duration getRelativeBeginDate() {
+        return relativeBeginDate;
+    }
+
+    /**
+     * @param relativeBeginDate the relativeBeginDate to set
+     */
+    public void setRelativeBeginDate(Duration relativeBeginDate) {
+        //
+        //  License template should not have both BeginDate and RelativeBeginDate set.
+        //  Only one of these two values should be set.
+        if (beginDate != null) {
+            throw new IllegalArgumentException("Set BeginDate or RelativeBeginDate but not both");
+        }
+        this.relativeBeginDate = relativeBeginDate;
+    }
+
+    /**
+     * @return the relativeExpirationDate
+     */
+    public Duration getRelativeExpirationDate() {
+        return relativeExpirationDate;
+    }
+
+    /**
+     * @param relativeExpirationDate the relativeExpirationDate to set
+     */
+    public void setRelativeExpirationDate(Duration relativeExpirationDate) {
+        //
+        //  License template should not have both ExpirationDate and RelativeExpirationDate set.
+        //  Only one of these two values should be set.
+        if (expirationDate != null) {
+            throw new IllegalArgumentException("Set ExpirationDate or RelativeExpirationDate but not both");
+        }
+        this.relativeExpirationDate = relativeExpirationDate;
+    }
+
+    /**
+     * @return the gracePeriod
+     */
+    public Duration getGracePeriod() {
+        return gracePeriod;
+    }
+
+    /**
+     * @param gracePeriod the gracePeriod to set
+     */
+    public void setGracePeriod(Duration gracePeriod) {
+        this.gracePeriod = gracePeriod;
+    }
+
+    /**
+     * @return the playRight
+     */
+    public PlayReadyPlayRight getPlayRight() {
+        return playRight;
+    }
+
+    /**
+     * @param playRight the playRight to set
+     */
+    public void setPlayRight(PlayReadyPlayRight playRight) {
+        this.playRight = playRight;
+    }
+
+    /**
+     * @return the licenseType
+     */
+    public PlayReadyLicenseType getLicenseType() {
+        return licenseType;
+    }
+
+    /**
+     * @param licenseType the licenseType to set
+     */
+    public void setLicenseType(PlayReadyLicenseType licenseType) {
+        this.licenseType = licenseType;
+    }
+
+    /**
+     * @return the contentKey
+     */
+    public PlayReadyContentKey getContentKey() {
+        return contentKey;
+    }
+
+    /**
+     * @param contentKey the contentKey to set
+     */
+    public void setContentKey(PlayReadyContentKey contentKey) {
+        this.contentKey = contentKey;
+    }
+
+    /**
+     * @return the extensionData
+     */
+    public List<Element> getExtensionData() {
+        return extensionData;
+    }
+
+    /**
+     * @param extensionData the extensionData to set
+     */
+    public void setExtensionData(List<Element> extensionData) {
+        this.extensionData = extensionData;
+    }
+
+}
diff --git a/media/src/main/java/com/microsoft/windowsazure/services/media/implementation/templates/playreadylicense/PlayReadyPlayRight.java b/media/src/main/java/com/microsoft/windowsazure/services/media/implementation/templates/playreadylicense/PlayReadyPlayRight.java
new file mode 100644
index 0000000..1fc0553
--- /dev/null
+++ b/media/src/main/java/com/microsoft/windowsazure/services/media/implementation/templates/playreadylicense/PlayReadyPlayRight.java
@@ -0,0 +1,277 @@
+package com.microsoft.windowsazure.services.media.implementation.templates.playreadylicense;
+
+import java.util.List;
+
+import javax.xml.bind.Element;
+import javax.xml.bind.annotation.XmlAccessType;
+import javax.xml.bind.annotation.XmlAccessorType;
+import javax.xml.bind.annotation.XmlAnyElement;
+import javax.xml.bind.annotation.XmlElement;
+import javax.xml.bind.annotation.XmlType;
+import javax.xml.datatype.Duration;
+
+@XmlAccessorType(XmlAccessType.FIELD)
+@XmlType(name = "PlayRight")
+public class PlayReadyPlayRight {
+    
+    @XmlElement(name = "AgcAndColorStripeRestriction")
+    private AgcAndColorStripeRestriction agcAndColorStripeRestriction;
+    
+    @XmlElement(name = "AllowPassingVideoContentToUnknownOutput")
+    private UnknownOutputPassingOption allowPassingVideoContentToUnknownOutput;
+    
+    @XmlElement(name = "AnalogVideoOpl")
+    private Integer analogVideoOpl;
+    
+    @XmlElement(name = "CompressedDigitalAudioOpl")
+    private Integer compressedDigitalAudioOpl;
+    
+    @XmlElement(name = "CompressedDigitalVideoOpl")
+    private Integer compressedDigitalVideoOpl;
+    
+    @XmlElement(name = "DigitalVideoOnlyContentRestriction")
+    private boolean digitalVideoOnlyContentRestriction;
+    
+    @XmlElement(name = "ExplicitAnalogTelevisionOutputRestriction")
+    private ExplicitAnalogTelevisionRestriction explicitAnalogTelevisionOutputRestriction;
+    
+    @XmlElement(name = "FirstPlayExpiration")
+    private Duration firstPlayExpiration;
+  
+    @XmlElement(name = "ImageConstraintForAnalogComponentVideoRestriction")
+    private boolean imageConstraintForAnalogComponentVideoRestriction;
+    
+    @XmlElement(name = "ImageConstraintForAnalogComputerMonitorRestriction")
+    private boolean imageConstraintForAnalogComputerMonitorRestriction;    
+    
+    @XmlElement(name = "ScmsRestriction")
+    private ScmsRestriction scmsRestriction;    
+    
+    @XmlElement(name = "UncompressedDigitalAudioOpl")
+    private Integer uncompressedDigitalAudioOpl;
+    
+    @XmlElement(name = "UncompressedDigitalVideoOpl")
+    private Integer uncompressedDigitalVideoOpl;
+    
+    // mimics IExtensibleDataObject
+    @XmlAnyElement
+    private List<Element> extensionData;
+
+    /**
+     * @return the firstPlayExpiration
+     */
+    public Duration getFirstPlayExpiration() {
+        return firstPlayExpiration;
+    }
+
+    /**
+     * @param firstPlayExpiration the firstPlayExpiration to set
+     */
+    public void setFirstPlayExpiration(Duration firstPlayExpiration) {
+        this.firstPlayExpiration = firstPlayExpiration;
+    }
+
+    /**
+     * @return the scmsRestriction
+     */
+    public ScmsRestriction getScmsRestriction() {
+        return scmsRestriction;
+    }
+
+    /**
+     * @param scmsRestriction the scmsRestriction to set
+     */
+    public void setScmsRestriction(ScmsRestriction scmsRestriction) {
+        this.scmsRestriction = scmsRestriction;
+    }
+
+    /**
+     * @return the agcAndColorStripeRestriction
+     */
+    public AgcAndColorStripeRestriction getAgcAndColorStripeRestriction() {
+        return agcAndColorStripeRestriction;
+    }
+
+    /**
+     * @param agcAndColorStripeRestriction the agcAndColorStripeRestriction to set
+     */
+    public void setAgcAndColorStripeRestriction(AgcAndColorStripeRestriction agcAndColorStripeRestriction) {
+        this.agcAndColorStripeRestriction = agcAndColorStripeRestriction;
+    }
+
+    /**
+     * @return the explicitAnalogTelevisionOutputRestriction
+     */
+    public ExplicitAnalogTelevisionRestriction getExplicitAnalogTelevisionOutputRestriction() {
+        return explicitAnalogTelevisionOutputRestriction;
+    }
+
+    /**
+     * @param explicitAnalogTelevisionOutputRestriction the explicitAnalogTelevisionOutputRestriction to set
+     */
+    public void setExplicitAnalogTelevisionOutputRestriction(ExplicitAnalogTelevisionRestriction explicitAnalogTelevisionOutputRestriction) {
+        this.explicitAnalogTelevisionOutputRestriction = explicitAnalogTelevisionOutputRestriction;
+    }
+
+    /**
+     * @return the digitalVideoOnlyContentRestriction
+     */
+    public boolean isDigitalVideoOnlyContentRestriction() {
+        return digitalVideoOnlyContentRestriction;
+    }
+
+    /**
+     * @param digitalVideoOnlyContentRestriction the digitalVideoOnlyContentRestriction to set
+     */
+    public void setDigitalVideoOnlyContentRestriction(boolean digitalVideoOnlyContentRestriction) {
+        this.digitalVideoOnlyContentRestriction = digitalVideoOnlyContentRestriction;
+    }
+
+    /**
+     * @return the imageConstraintForAnalogComponentVideoRestriction
+     */
+    public boolean isImageConstraintForAnalogComponentVideoRestriction() {
+        return imageConstraintForAnalogComponentVideoRestriction;
+    }
+
+    /**
+     * @param imageConstraintForAnalogComponentVideoRestriction the imageConstraintForAnalogComponentVideoRestriction to set
+     */
+    public void setImageConstraintForAnalogComponentVideoRestriction(
+            boolean imageConstraintForAnalogComponentVideoRestriction) {
+        this.imageConstraintForAnalogComponentVideoRestriction = imageConstraintForAnalogComponentVideoRestriction;
+    }
+
+    /**
+     * @return the allowPassingVideoContentToUnknownOutput
+     */
+    public UnknownOutputPassingOption getAllowPassingVideoContentToUnknownOutput() {
+        return allowPassingVideoContentToUnknownOutput;
+    }
+
+    /**
+     * @param allowPassingVideoContentToUnknownOutput the allowPassingVideoContentToUnknownOutput to set
+     */
+    public void setAllowPassingVideoContentToUnknownOutput(UnknownOutputPassingOption allowPassingVideoContentToUnknownOutput) {
+        this.allowPassingVideoContentToUnknownOutput = allowPassingVideoContentToUnknownOutput;
+    }
+
+    /**
+     * @return the uncompressedDigitalVideoOpl
+     */
+    public Integer getUncompressedDigitalVideoOpl() {
+        return uncompressedDigitalVideoOpl;
+    }
+
+    /**
+     * @param uncompressedDigitalVideoOpl the uncompressedDigitalVideoOpl to set
+     */
+    public void setUncompressedDigitalVideoOpl(Integer uncompressedDigitalVideoOpl) {
+        int value = uncompressedDigitalVideoOpl != null ? uncompressedDigitalVideoOpl.intValue() : -1;
+        if ((uncompressedDigitalVideoOpl != null) && (value != 100) && (value != 250) && (value != 270) && (value != 300)) {
+            throw new IllegalArgumentException(ErrorMessages.UNCOMPRESSED_DIGITAL_VIDEO_OPL_VALUE_ERROR);
+        }
+        this.uncompressedDigitalVideoOpl = uncompressedDigitalVideoOpl;
+    }
+
+    /**
+     * @return the compressedDigitalVideoOpl
+     */
+    public Integer getCompressedDigitalVideoOpl() {
+        return compressedDigitalVideoOpl;
+    }
+
+    /**
+     * @param compressedDigitalVideoOpl the compressedDigitalVideoOpl to set
+     */
+    public void setCompressedDigitalVideoOpl(Integer compressedDigitalVideoOpl) {
+        int value = compressedDigitalVideoOpl != null ? compressedDigitalVideoOpl.intValue() : -1;
+        if ((compressedDigitalVideoOpl != null) && (value != 400) && (value != 500)) {
+            throw new IllegalArgumentException(ErrorMessages.COMPRESSED_DIGITAL_VIDEO_OPL_VALUE_ERROR);
+        }
+        this.compressedDigitalVideoOpl = compressedDigitalVideoOpl;
+    }
+
+    /**
+     * @return the analogVideoOpl
+     */
+    public Integer getAnalogVideoOpl() {
+        return analogVideoOpl;
+    }
+
+    /**
+     * @param analogVideoOpl the analogVideoOpl to set
+     */
+    public void setAnalogVideoOpl(Integer analogVideoOpl) {
+        int value = analogVideoOpl != null ? analogVideoOpl.intValue() : -1;
+        if ((analogVideoOpl != null) && (value != 100) && (value != 150) && (value != 200)) {
+            throw new IllegalArgumentException(ErrorMessages.ANALOG_VIDEO_OPL_VALUE_ERROR);
+        }
+        this.analogVideoOpl = analogVideoOpl;
+    }
+
+    /**
+     * @return the compressedDigitalAudioOpl
+     */
+    public Integer getCompressedDigitalAudioOpl() {
+        return compressedDigitalAudioOpl;
+    }
+
+    /**
+     * @param compressedDigitalAudioOpl the compressedDigitalAudioOpl to set
+     */
+    public void setCompressedDigitalAudioOpl(Integer compressedDigitalAudioOpl) {
+        int value = compressedDigitalAudioOpl != null ? compressedDigitalAudioOpl.intValue() : -1;
+        if ((compressedDigitalAudioOpl != null) && (value != 100) && (value != 150) && (value != 200) && (value != 250) && (value != 300)) {
+            throw new IllegalArgumentException(ErrorMessages.COMPRESSED_DIGITAL_AUDIO_OPL_VALUE_ERROR);
+        }
+        this.compressedDigitalAudioOpl = compressedDigitalAudioOpl;
+    }
+
+    /**
+     * @return the uncompressedDigitalAudioOpl
+     */
+    public Integer getUncompressedDigitalAudioOpl() {
+        return uncompressedDigitalAudioOpl;
+    }
+
+    /**
+     * @param uncompressedDigitalAudioOpl the uncompressedDigitalAudioOpl to set
+     */
+    public void setUncompressedDigitalAudioOpl(Integer uncompressedDigitalAudioOpl) {
+        int value = uncompressedDigitalAudioOpl != null ? uncompressedDigitalAudioOpl.intValue() : -1;
+        if ((uncompressedDigitalAudioOpl != null) && (value != 100) && (value != 150) && (value != 200) && (value != 250) && (value != 300)) {
+            throw new IllegalArgumentException(ErrorMessages.UNCOMPRESSED_DIGITAL_AUDIO_OPL_VALUE_ERROR);
+        }
+        this.uncompressedDigitalAudioOpl = uncompressedDigitalAudioOpl;
+    }
+
+    /**
+     * @return the imageConstraintForAnalogComputerMonitorRestriction
+     */
+    public boolean isImageConstraintForAnalogComputerMonitorRestriction() {
+        return imageConstraintForAnalogComputerMonitorRestriction;
+    }
+
+    /**
+     * @param imageConstraintForAnalogComputerMonitorRestriction the imageConstraintForAnalogComputerMonitorRestriction to set
+     */
+    public void setImageConstraintForAnalogComputerMonitorRestriction(
+            boolean imageConstraintForAnalogComputerMonitorRestriction) {
+        this.imageConstraintForAnalogComputerMonitorRestriction = imageConstraintForAnalogComputerMonitorRestriction;
+    }
+
+    /**
+     * @return the extensionData
+     */
+    public List<Element> getExtensionData() {
+        return extensionData;
+    }
+
+    /**
+     * @param extensionData the extensionData to set
+     */
+    public void setExtensionData(List<Element> extensionData) {
+        this.extensionData = extensionData;
+    }
+}
diff --git a/media/src/main/java/com/microsoft/windowsazure/services/media/implementation/templates/tokenrestriction/TokenVerificationKey.java b/media/src/main/java/com/microsoft/windowsazure/services/media/implementation/templates/tokenrestriction/TokenVerificationKey.java
index 652e4b3..ff49343 100644
--- a/media/src/main/java/com/microsoft/windowsazure/services/media/implementation/templates/tokenrestriction/TokenVerificationKey.java
+++ b/media/src/main/java/com/microsoft/windowsazure/services/media/implementation/templates/tokenrestriction/TokenVerificationKey.java
@@ -4,7 +4,7 @@ import javax.xml.bind.annotation.XmlSeeAlso;
 import javax.xml.bind.annotation.XmlTransient;
 
 @XmlTransient
-@XmlSeeAlso({SymmetricVerificationKey.class, X509CertTokenVerificationKey.class})
+@XmlSeeAlso({ SymmetricVerificationKey.class, X509CertTokenVerificationKey.class })
 public abstract class TokenVerificationKey {
 
 }
diff --git a/media/src/test/java/com/microsoft/windowsazure/services/media/IntegrationTestBase.java b/media/src/test/java/com/microsoft/windowsazure/services/media/IntegrationTestBase.java
index 1b6c975..ee5356c 100644
--- a/media/src/test/java/com/microsoft/windowsazure/services/media/IntegrationTestBase.java
+++ b/media/src/test/java/com/microsoft/windowsazure/services/media/IntegrationTestBase.java
@@ -399,9 +399,9 @@ public abstract class IntegrationTestBase {
 
     protected void assertDateApproxEquals(String message, Date expected,
             Date actual) {
-        // Default allows for a 30 seconds difference in dates, for clock skew,
+        // Default allows for a 2:30 minutes difference in dates, for clock skew,
         // network delays, etc.
-        long deltaInMilliseconds = 30000;
+        long deltaInMilliseconds = 150000;
 
         if (expected == null || actual == null) {
             assertEquals(message, expected, actual);
diff --git a/media/src/test/java/com/microsoft/windowsazure/services/media/implementation/templates/playreadylicense/MediaServicesLicenseTemplateSerializerTests.java b/media/src/test/java/com/microsoft/windowsazure/services/media/implementation/templates/playreadylicense/MediaServicesLicenseTemplateSerializerTests.java
new file mode 100644
index 0000000..d46676e
--- /dev/null
+++ b/media/src/test/java/com/microsoft/windowsazure/services/media/implementation/templates/playreadylicense/MediaServicesLicenseTemplateSerializerTests.java
@@ -0,0 +1,542 @@
+package com.microsoft.windowsazure.services.media.implementation.templates.playreadylicense;
+
+import static org.junit.Assert.*;
+
+import java.util.Date;
+import java.util.UUID;
+import java.util.Arrays;
+
+import javax.xml.bind.JAXBException;
+import javax.xml.datatype.DatatypeConfigurationException;
+import javax.xml.datatype.DatatypeFactory;
+import javax.xml.datatype.Duration;
+
+import org.junit.Test;
+
+import com.microsoft.windowsazure.services.media.implementation.templates.playreadylicense.AgcAndColorStripeRestriction;
+import com.microsoft.windowsazure.services.media.implementation.templates.playreadylicense.ContentEncryptionKeyFromHeader;
+import com.microsoft.windowsazure.services.media.implementation.templates.playreadylicense.ContentEncryptionKeyFromKeyIdentifier;
+import com.microsoft.windowsazure.services.media.implementation.templates.playreadylicense.ErrorMessages;
+import com.microsoft.windowsazure.services.media.implementation.templates.playreadylicense.ExplicitAnalogTelevisionRestriction;
+import com.microsoft.windowsazure.services.media.implementation.templates.playreadylicense.MediaServicesLicenseTemplateSerializer;
+import com.microsoft.windowsazure.services.media.implementation.templates.playreadylicense.PlayReadyLicenseResponseTemplate;
+import com.microsoft.windowsazure.services.media.implementation.templates.playreadylicense.PlayReadyLicenseTemplate;
+import com.microsoft.windowsazure.services.media.implementation.templates.playreadylicense.PlayReadyLicenseType;
+import com.microsoft.windowsazure.services.media.implementation.templates.playreadylicense.PlayReadyPlayRight;
+import com.microsoft.windowsazure.services.media.implementation.templates.playreadylicense.ScmsRestriction;
+import com.microsoft.windowsazure.services.media.implementation.templates.playreadylicense.UnknownOutputPassingOption;
+import com.sun.xml.bind.v2.runtime.unmarshaller.XsiNilLoader.Array;
+
+public class MediaServicesLicenseTemplateSerializerTests {
+
+    private final String schemaFile = null; // MediaServicesLicenseTemplateSerializerTests.class
+            ///  .getClassLoader().getResource("")
+            /// .getPath() + "schemas/TokenRestrictionTemplate.xsd";
+    
+    @Test
+    public void roundTripTest() throws Exception {
+        PlayReadyLicenseResponseTemplate template = new PlayReadyLicenseResponseTemplate();
+        template.setResponseCustomData("This is my response custom data");
+        PlayReadyLicenseTemplate licenseTemplate = new PlayReadyLicenseTemplate();
+        template.getLicenseTemplates().add(licenseTemplate);
+
+        //@Act
+        
+        licenseTemplate.setLicenseType(PlayReadyLicenseType.Persistent);
+        licenseTemplate.setBeginDate(new Date());
+        licenseTemplate.setExpirationDate(new Date());
+        licenseTemplate.setContentKey(new ContentEncryptionKeyFromKeyIdentifier(UUID.randomUUID()));
+        
+        PlayReadyPlayRight playRight = new PlayReadyPlayRight();
+        licenseTemplate.setPlayRight(playRight);
+        
+        playRight.setAgcAndColorStripeRestriction(new AgcAndColorStripeRestriction((byte) 1));
+        playRight.setAllowPassingVideoContentToUnknownOutput(UnknownOutputPassingOption.Allowed);
+        playRight.setAnalogVideoOpl(100);
+        playRight.setCompressedDigitalAudioOpl(300);
+        playRight.setCompressedDigitalVideoOpl(400);
+        playRight.setExplicitAnalogTelevisionOutputRestriction(new ExplicitAnalogTelevisionRestriction(true, (byte)0));
+        playRight.setImageConstraintForAnalogComponentVideoRestriction(true);
+        playRight.setImageConstraintForAnalogComputerMonitorRestriction(true);
+        playRight.setScmsRestriction(new ScmsRestriction((byte)2));
+        playRight.setUncompressedDigitalAudioOpl(250);
+        playRight.setUncompressedDigitalVideoOpl(270);
+        
+        String result = MediaServicesLicenseTemplateSerializer.serialize(template);
+        assertNotNull(result);
+        
+        PlayReadyLicenseResponseTemplate deserialized = MediaServicesLicenseTemplateSerializer.deserialize(result, schemaFile);
+        assertNotNull(deserialized);
+    }
+    
+    @Test
+    public void roundTripTestWithRelativeBeginDateRelativeEndDate() throws Exception {
+        PlayReadyLicenseResponseTemplate template = new PlayReadyLicenseResponseTemplate();
+        template.setResponseCustomData("This is my response custom data");
+        PlayReadyLicenseTemplate licenseTemplate = new PlayReadyLicenseTemplate();
+        template.getLicenseTemplates().add(licenseTemplate);
+        
+        licenseTemplate.setLicenseType(PlayReadyLicenseType.Persistent);
+        licenseTemplate.setRelativeBeginDate(DatatypeFactory.newInstance().newDuration("PT1H"));
+        licenseTemplate.setRelativeExpirationDate(DatatypeFactory.newInstance().newDuration("PT1H"));
+        licenseTemplate.setContentKey(new ContentEncryptionKeyFromKeyIdentifier(UUID.randomUUID()));
+        
+        PlayReadyPlayRight playRight = new PlayReadyPlayRight();
+        licenseTemplate.setPlayRight(playRight);
+        
+        playRight.setAgcAndColorStripeRestriction(new AgcAndColorStripeRestriction((byte) 1));
+        playRight.setAllowPassingVideoContentToUnknownOutput(UnknownOutputPassingOption.Allowed);
+        playRight.setAnalogVideoOpl(100);
+        playRight.setCompressedDigitalAudioOpl(300);
+        playRight.setCompressedDigitalVideoOpl(400);
+        playRight.setExplicitAnalogTelevisionOutputRestriction(new ExplicitAnalogTelevisionRestriction(true, (byte)0));
+        playRight.setImageConstraintForAnalogComponentVideoRestriction(true);
+        playRight.setImageConstraintForAnalogComputerMonitorRestriction(true);
+        playRight.setScmsRestriction(new ScmsRestriction((byte)2));
+        playRight.setUncompressedDigitalAudioOpl(250);
+        playRight.setUncompressedDigitalVideoOpl(270);
+        
+        String result = MediaServicesLicenseTemplateSerializer.serialize(template);
+        assertNotNull(result);
+        
+        PlayReadyLicenseResponseTemplate deserialized = MediaServicesLicenseTemplateSerializer.deserialize(result, schemaFile);
+        assertNotNull(deserialized);
+    }
+    
+    @Test
+    public void roundTripTestErrorWithRelativeBeginDateBeginDate() throws Exception {
+        try {
+            PlayReadyLicenseResponseTemplate template = new PlayReadyLicenseResponseTemplate();
+            template.setResponseCustomData("This is my response custom data");
+            PlayReadyLicenseTemplate licenseTemplate = new PlayReadyLicenseTemplate();
+            template.getLicenseTemplates().add(licenseTemplate);
+            
+            licenseTemplate.setLicenseType(PlayReadyLicenseType.Persistent);
+            licenseTemplate.setBeginDate(new Date());
+            licenseTemplate.setRelativeBeginDate(DatatypeFactory.newInstance().newDuration("PT1H"));
+            
+            fail("Should Thrown");
+        } catch (IllegalArgumentException e) {
+            assertTrue(e.getMessage().contains("both"));
+        }
+    }
+    
+    @Test
+    public void roundTripTestErrorWithBeginDateRelativeBeginDate() throws Exception {
+        try {
+            PlayReadyLicenseResponseTemplate template = new PlayReadyLicenseResponseTemplate();
+            template.setResponseCustomData("This is my response custom data");
+            PlayReadyLicenseTemplate licenseTemplate = new PlayReadyLicenseTemplate();
+            template.getLicenseTemplates().add(licenseTemplate);
+            
+            licenseTemplate.setLicenseType(PlayReadyLicenseType.Persistent);
+            licenseTemplate.setRelativeBeginDate(DatatypeFactory.newInstance().newDuration("PT1H"));
+            licenseTemplate.setBeginDate(new Date());
+            
+            fail("Should Thrown");
+        } catch (IllegalArgumentException e) {
+            assertTrue(e.getMessage().contains("both"));
+        }
+    }
+    
+    @Test
+    public void roundTripTestErrorWithRelativeExpirationDateExpirationDate() throws Exception {
+        try {
+            PlayReadyLicenseResponseTemplate template = new PlayReadyLicenseResponseTemplate();
+            template.setResponseCustomData("This is my response custom data");
+            PlayReadyLicenseTemplate licenseTemplate = new PlayReadyLicenseTemplate();
+            template.getLicenseTemplates().add(licenseTemplate);
+            
+            licenseTemplate.setLicenseType(PlayReadyLicenseType.Persistent);
+            licenseTemplate.setExpirationDate(new Date());
+            licenseTemplate.setRelativeExpirationDate(DatatypeFactory.newInstance().newDuration("PT1H"));
+            
+            fail("Should Thrown");
+        } catch (IllegalArgumentException e) {
+            assertTrue(e.getMessage().contains("both"));
+        }
+    }
+    
+    @Test
+    public void roundTripTestErrorWithExpirationDateRelativeExpirationDate() throws Exception {
+        try {
+            PlayReadyLicenseResponseTemplate template = new PlayReadyLicenseResponseTemplate();
+            template.setResponseCustomData("This is my response custom data");
+            PlayReadyLicenseTemplate licenseTemplate = new PlayReadyLicenseTemplate();
+            template.getLicenseTemplates().add(licenseTemplate);
+            
+            licenseTemplate.setLicenseType(PlayReadyLicenseType.Persistent);
+            licenseTemplate.setRelativeExpirationDate(DatatypeFactory.newInstance().newDuration("PT1H"));
+            licenseTemplate.setExpirationDate(new Date());
+            
+            fail("Should Thrown");
+        } catch (IllegalArgumentException e) {
+            assertTrue(e.getMessage().contains("both"));
+        }
+    }
+   
+    @Test
+    public void validateNonPersistentLicenseConstraints() throws Exception {
+        // Arrange
+        @SuppressWarnings("unused")
+        String serializedTemplate = null;
+        Duration durationSanmple = DatatypeFactory.newInstance().newDuration("PT1H");
+        PlayReadyLicenseResponseTemplate template = new PlayReadyLicenseResponseTemplate();
+        PlayReadyLicenseTemplate licenseTemplate = new PlayReadyLicenseTemplate();
+        template.getLicenseTemplates().add(licenseTemplate);
+        PlayReadyPlayRight playRight = new PlayReadyPlayRight();
+        licenseTemplate.setPlayRight(playRight);
+        // Set as Nonpersistent
+        licenseTemplate.setLicenseType(PlayReadyLicenseType.Nonpersistent);
+        
+        // ACT 1: Make sure we cannot set GracePeriod on a NonPersistent license
+        try
+        {
+            serializedTemplate = MediaServicesLicenseTemplateSerializer.serialize(template);
+            fail("Expected IllegalArgumentException");
+        }
+        catch (IllegalArgumentException e)
+        {
+            assertEquals(ErrorMessages.PLAY_READY_CONTENT_KEY_REQUIRED, e.getMessage());
+            licenseTemplate.setContentKey(new ContentEncryptionKeyFromHeader());
+        }
+        
+        // ACT 2: Make sure we cannot set GracePeriod on a NonPersistent license
+        licenseTemplate.setGracePeriod(durationSanmple);
+        try
+        {
+            serializedTemplate = MediaServicesLicenseTemplateSerializer.serialize(template);
+            fail("Expected IllegalArgumentException");
+        }
+        catch (IllegalArgumentException e)
+        {
+            assertEquals(ErrorMessages.GRACE_PERIOD_CANNOT_BE_SET_ON_NON_PERSISTENT_LICENSE, e.getMessage());
+        }
+        
+        // ACT 3: Make sure we cannot set a FirstPlayExpiration on a NonPersistent license.
+        licenseTemplate.setGracePeriod(null);
+        playRight.setFirstPlayExpiration(durationSanmple);
+        
+        try
+        {
+            serializedTemplate = MediaServicesLicenseTemplateSerializer.serialize(template);
+            fail("Expected IllegalArgumentException");
+        }
+        catch (IllegalArgumentException e)
+        {
+            assertEquals(ErrorMessages.FIRST_PLAY_EXPIRATION_CANNOT_BE_SET_ON_NON_PERSISTENT_LICENSE, e.getMessage());
+        }
+        
+        // ACT 4: Make sure we cannot set a BeginDate on a NonPersistent license.
+        playRight.setFirstPlayExpiration(null);
+        licenseTemplate.setBeginDate(new Date());
+        
+        try
+        {
+            serializedTemplate = MediaServicesLicenseTemplateSerializer.serialize(template);
+            fail("Expected IllegalArgumentException");
+        }
+        catch (IllegalArgumentException e)
+        {
+            assertEquals(ErrorMessages.BEGIN_DATE_CANNOT_BE_SET_ON_NON_PERSISTENT_LICENSE, e.getMessage());
+        }
+        
+        // ACT 5: Make sure we cannot set an ExpirationDate on a NonPersistent license.
+        licenseTemplate.setBeginDate(null);
+        licenseTemplate.setExpirationDate(new Date());
+        
+        try
+        {
+            serializedTemplate = MediaServicesLicenseTemplateSerializer.serialize(template);
+            fail("Expected IllegalArgumentException");
+        }
+        catch (IllegalArgumentException e)
+        {
+            assertEquals(ErrorMessages.EXPIRATION_CANNOT_BE_SET_ON_NON_PERSISTENT_LICENSE, e.getMessage());
+        }
+    }
+    
+    @Test
+    public void digitalVideoOnlyContentRestrictionAndAllowPassingVideoContentToUnknownOutputMutuallyExclusive() throws Exception {
+        String serializedTemplate = null;
+        PlayReadyLicenseResponseTemplate template = new PlayReadyLicenseResponseTemplate();
+        PlayReadyLicenseTemplate licenseTemplate = new PlayReadyLicenseTemplate();
+        template.getLicenseTemplates().add(licenseTemplate);
+        // Set as Nonpersistent
+        licenseTemplate.setLicenseType(PlayReadyLicenseType.Nonpersistent);
+        licenseTemplate.setContentKey(new ContentEncryptionKeyFromHeader());
+        PlayReadyPlayRight playRight = new PlayReadyPlayRight();
+        licenseTemplate.setPlayRight(playRight);
+        
+        // ACT 1: Make sure we cannot set DigitalVideoOnlyContentRestriction to true if 
+        //         UnknownOutputPassingOption.Allowed is set
+        playRight.setAllowPassingVideoContentToUnknownOutput(UnknownOutputPassingOption.Allowed);
+        playRight.setDigitalVideoOnlyContentRestriction(true);
+        try
+        {
+            serializedTemplate = MediaServicesLicenseTemplateSerializer.serialize(template);
+            fail("Expected IllegalArgumentException");
+        }
+        catch (IllegalArgumentException e)
+        {
+            // ASSERT 1
+            assertEquals(ErrorMessages.DIGITAL_VIDEO_ONLY_MUTUALLY_EXCLUSIVE_WITH_PASSING_TO_UNKNOWN_OUTPUT_ERROR, e.getMessage());
+        }
+        
+        // ACT 2: Make sure we cannot set UnknownOutputPassingOption.AllowedWithVideoConstriction
+        //         if DigitalVideoOnlyContentRestriction is true
+        playRight.setAllowPassingVideoContentToUnknownOutput(UnknownOutputPassingOption.AllowedWithVideoConstriction);
+        try
+        {
+            serializedTemplate = MediaServicesLicenseTemplateSerializer.serialize(template);
+            fail("Expected IllegalArgumentException");
+        }
+        catch (IllegalArgumentException e)
+        {
+            // ASSERT 2
+            assertEquals(ErrorMessages.DIGITAL_VIDEO_ONLY_MUTUALLY_EXCLUSIVE_WITH_PASSING_TO_UNKNOWN_OUTPUT_ERROR, e.getMessage());
+        }
+        
+        // ACT 3: Make sure we can set DigitalVideoOnlyContentRestriction to true if 
+        //         UnknownOutputPassingOption.NotAllowed is set
+        playRight.setAllowPassingVideoContentToUnknownOutput(UnknownOutputPassingOption.NotAllowed);
+        serializedTemplate = MediaServicesLicenseTemplateSerializer.serialize(template);
+  
+        // ASSERT 3
+        assertNotNull(serializedTemplate);
+        assertNotNull(MediaServicesLicenseTemplateSerializer.deserialize(serializedTemplate));
+    }
+    
+    @Test
+    public void knownGoodInputTest() throws Exception
+    {
+        String serializedTemplate = "<PlayReadyLicenseResponseTemplate xmlns:i=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns=\"http://schemas.microsoft.com/Azure/MediaServices/KeyDelivery/PlayReadyTemplate/v1\"><LicenseTemplates><PlayReadyLicenseTemplate><AllowTestDevices>false</AllowTestDevices><BeginDate i:nil=\"true\" /><ContentKey i:type=\"ContentEncryptionKeyFromHeader\" /><ContentType>Unspecified</ContentType><ExpirationDate i:nil=\"true\" /><LicenseType>Nonpersistent</LicenseType><PlayRight><AgcAndColorStripeRestriction><ConfigurationData>1</ConfigurationData></AgcAndColorStripeRestriction><AllowPassingVideoContentToUnknownOutput>Allowed</AllowPassingVideoContentToUnknownOutput><AnalogVideoOpl>100</AnalogVideoOpl><CompressedDigitalAudioOpl>300</CompressedDigitalAudioOpl><CompressedDigitalVideoOpl>400</CompressedDigitalVideoOpl><DigitalVideoOnlyContentRestriction>false</DigitalVideoOnlyContentRestriction><ExplicitAnalogTelevisionOutputRestriction><BestEffort>true</BestEffort><ConfigurationData>0</ConfigurationData></ExplicitAnalogTelevisionOutputRestriction><ImageConstraintForAnalogComponentVideoRestriction>true</ImageConstraintForAnalogComponentVideoRestriction><ImageConstraintForAnalogComputerMonitorRestriction>true</ImageConstraintForAnalogComputerMonitorRestriction><ScmsRestriction><ConfigurationData>2</ConfigurationData></ScmsRestriction><UncompressedDigitalAudioOpl>250</UncompressedDigitalAudioOpl><UncompressedDigitalVideoOpl>270</UncompressedDigitalVideoOpl></PlayRight></PlayReadyLicenseTemplate></LicenseTemplates><ResponseCustomData>This is my response custom data</ResponseCustomData></PlayReadyLicenseResponseTemplate>";
+
+        PlayReadyLicenseResponseTemplate responseTemplate2 = MediaServicesLicenseTemplateSerializer.deserialize(serializedTemplate, schemaFile);
+        assertNotNull(responseTemplate2);
+    }
+    
+    @Test
+    public void knownGoodInputMinimalLicenseTest() throws Exception
+    {
+        String serializedTemplate = "<PlayReadyLicenseResponseTemplate xmlns:i=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns=\"http://schemas.microsoft.com/Azure/MediaServices/KeyDelivery/PlayReadyTemplate/v1\"><LicenseTemplates><PlayReadyLicenseTemplate><ContentKey i:type=\"ContentEncryptionKeyFromHeader\" /><PlayRight /></PlayReadyLicenseTemplate></LicenseTemplates></PlayReadyLicenseResponseTemplate>";
+
+        PlayReadyLicenseResponseTemplate responseTemplate2 = MediaServicesLicenseTemplateSerializer.deserialize(serializedTemplate, schemaFile);
+        assertNotNull(responseTemplate2);
+    }
+    
+    @Test
+    public void inputMissingContentKeyShouldThrowArgumentException() throws Exception
+    {
+        String serializedTemplate = "<PlayReadyLicenseResponseTemplate xmlns:i=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns=\"http://schemas.microsoft.com/Azure/MediaServices/KeyDelivery/PlayReadyTemplate/v1\"><LicenseTemplates><PlayReadyLicenseTemplate><PlayRight /></PlayReadyLicenseTemplate></LicenseTemplates></PlayReadyLicenseResponseTemplate>";
+
+        try
+        {
+            MediaServicesLicenseTemplateSerializer.deserialize(serializedTemplate, schemaFile);
+            fail("Should throw an IllegalArgumentException");
+        }
+        catch (IllegalArgumentException e)
+        {
+            assertEquals(ErrorMessages.PLAY_READY_CONTENT_KEY_REQUIRED, e.getMessage());
+        }
+    }
+    
+    @Test
+    public void inputMissingPlayRightShouldThrowArgumentException() throws Exception
+    {
+        String serializedTemplate = "<PlayReadyLicenseResponseTemplate xmlns:i=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns=\"http://schemas.microsoft.com/Azure/MediaServices/KeyDelivery/PlayReadyTemplate/v1\"><LicenseTemplates><PlayReadyLicenseTemplate><ContentKey i:type=\"ContentEncryptionKeyFromHeader\" /></PlayReadyLicenseTemplate></LicenseTemplates></PlayReadyLicenseResponseTemplate>";
+
+        try
+        {
+            MediaServicesLicenseTemplateSerializer.deserialize(serializedTemplate, schemaFile);
+            fail("Should throw an IllegalArgumentException");
+        }
+        catch (IllegalArgumentException e)
+        {
+            assertEquals(ErrorMessages.PLAY_READY_PLAY_RIGHT_REQUIRED, e.getMessage());
+        }
+    }
+    
+    @Test
+    public void inputMissingLicenseTemplatesShouldThrowArgumentException() throws Exception
+    {
+        String serializedTemplate = "<PlayReadyLicenseResponseTemplate xmlns:i=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns=\"http://schemas.microsoft.com/Azure/MediaServices/KeyDelivery/PlayReadyTemplate/v1\"><LicenseTemplates></LicenseTemplates></PlayReadyLicenseResponseTemplate>";
+
+        try
+        {
+            MediaServicesLicenseTemplateSerializer.deserialize(serializedTemplate, schemaFile);
+            fail("Should throw an IllegalArgumentException");
+        }
+        catch (IllegalArgumentException e)
+        {
+            assertEquals(ErrorMessages.AT_LEAST_ONE_LICENSE_TEMPLATE_REQUIRED, e.getMessage());
+        }
+    }
+    
+    @Test
+    public void ScmsRestrictionConfigurationDataValidationTest()
+    {
+        byte[] validConfigurationValues = new byte[] { 0, 1, 2, 3 };
+        byte[] invalidConfigurationValues = new byte[] {(byte) 255, (byte) 128, 4, 5, 15};
+
+        for (byte configurationData : validConfigurationValues)
+        {
+            new ScmsRestriction(configurationData);
+        }
+
+        for  (byte configurationData : invalidConfigurationValues)
+        {
+            try
+            {
+                new ScmsRestriction(configurationData);
+                fail("Invalid configuration data accepted");
+            }
+            catch (IllegalArgumentException e)
+            {
+                assertEquals(ErrorMessages.INVALID_TWO_BIT_CONFIGURATION_DATA, e.getMessage());
+            }
+        }
+    }
+    
+    @Test
+    public void validateOutputProtectionLevelValueChecks()
+    {
+        //  From the PlayReady Compliance Rules for issuing PlayReady Licenses.
+        //
+        //                         Table 6.6: Allowed Output Protection Level Values
+        //
+        //                      Field                                       Allowed Values
+        //
+        //  Minimum Compressed Digital Audio Output Protection Level    100, 150, 200, 250, 300
+        //  Minimum Uncompressed Digital Audio Output Protection Level  100, 150, 200, 250, 300
+        //  Minimum Compressed Digital Video Output Protection Level    400, 500
+        //  Minimum Uncompressed Digital Video Output Protection Level  100, 250, 270, 300
+        //  Minimum Analog Television Output Protection Level           100, 150, 200
+        //
+
+        boolean[] expectedResult = null;
+
+        // First check null, which all of the Opls values support.  Setting Opl values is optional
+        // and null is the way the user signals that they do not want to set a value.
+        boolean[] currentResult = setOutputProtectionLevelValues(null);
+        expectedResult = new boolean[] { true, true, true, true, true };
+        assertTrue("null result didn't match expectations", Arrays.equals(currentResult, expectedResult));
+
+        for (int i = 0; i <= 550; i += 10)
+        {
+            currentResult = setOutputProtectionLevelValues(i);
+
+            switch (i)
+            { 
+                case 100:
+                    expectedResult = new boolean[] {true, true, false, true, true };
+                    assertTrue("100 result didn't match expectations", Arrays.equals(currentResult, expectedResult));
+                    break;
+                case 150:
+                    expectedResult = new boolean[] {true, true, false, false, true };
+                    assertTrue("150 result didn't match expectations", Arrays.equals(currentResult, expectedResult));
+                    break;
+                case 200:
+                    expectedResult = new boolean[] {true, true, false, false, true };
+                    assertTrue("200 result didn't match expectations", Arrays.equals(currentResult, expectedResult));
+                    break;
+                case 250:
+                    expectedResult = new boolean[] {true, true, false, true, false };
+                    assertTrue("250 result didn't match expectations", Arrays.equals(currentResult, expectedResult));
+                    break;
+                case 270:
+                    expectedResult = new boolean[] { false, false, false, true, false };
+                    assertTrue("270 result didn't match expectations", Arrays.equals(currentResult, expectedResult));
+                    break;
+                case 300:
+                    expectedResult = new boolean[] { true, true, false, true, false };
+                    assertTrue("300 result didn't match expectations", Arrays.equals(currentResult, expectedResult));
+                    break;
+                case 400:
+                    expectedResult = new boolean[] { false, false, true, false, false };
+                    assertTrue("400 result didn't match expectations", Arrays.equals(currentResult, expectedResult));
+                    break;
+                case 500:
+                    expectedResult = new boolean[] { false, false, true, false, false };
+                    assertTrue("500 result didn't match expectations", Arrays.equals(currentResult, expectedResult));
+                    break;
+                default:
+                    // These values should always return false for all types
+                    expectedResult = new boolean[] { false, false, false, false, false };
+                    assertTrue("" + i + " result didn't match expectations", Arrays.equals(currentResult, expectedResult));
+                    break;
+            }
+
+        }
+    }
+
+    private boolean[] setOutputProtectionLevelValues(Integer valueToSet)
+    {
+        PlayReadyPlayRight playRight = new PlayReadyPlayRight();
+        boolean[] returnValue = new boolean[5];
+
+        try
+        {
+            playRight.setCompressedDigitalAudioOpl(valueToSet);
+            returnValue[0] = true;
+        }
+        catch (IllegalArgumentException ae)
+        {
+            if (!ae.getMessage().equals(ErrorMessages.COMPRESSED_DIGITAL_AUDIO_OPL_VALUE_ERROR)) {
+                throw ae;
+            }
+        }
+
+        try
+        {
+            playRight.setUncompressedDigitalAudioOpl(valueToSet);
+            returnValue[1] = true;
+        }
+        catch (IllegalArgumentException ae)
+        {
+            if (!ae.getMessage().equals(ErrorMessages.UNCOMPRESSED_DIGITAL_AUDIO_OPL_VALUE_ERROR)) {
+                throw ae;
+            }
+        }
+
+        try
+        {
+            playRight.setCompressedDigitalVideoOpl(valueToSet);
+            returnValue[2] = true;
+        }
+        catch (IllegalArgumentException ae)
+        {
+            if (!ae.getMessage().equals(ErrorMessages.COMPRESSED_DIGITAL_VIDEO_OPL_VALUE_ERROR)) {
+                throw ae;
+            }
+        }
+
+        try
+        {
+            playRight.setUncompressedDigitalVideoOpl(valueToSet);
+            returnValue[3] = true;
+        }
+        catch (IllegalArgumentException ae)
+        {
+            if (!ae.getMessage().equals(ErrorMessages.UNCOMPRESSED_DIGITAL_VIDEO_OPL_VALUE_ERROR)) {
+                throw ae;
+            }
+        }
+
+        try
+        {
+            playRight.setAnalogVideoOpl(valueToSet);
+            returnValue[4] = true;
+        }
+        catch (IllegalArgumentException ae)
+        {
+            if (!ae.getMessage().equals(ErrorMessages.ANALOG_VIDEO_OPL_VALUE_ERROR)) {
+                throw ae;
+            }
+        }
+
+        return returnValue;
+    }
+
+}
+
diff --git a/media/src/test/java/com/microsoft/windowsazure/services/media/implementation/templates/playreadylicense/PlayReadyPlayRightTest.java b/media/src/test/java/com/microsoft/windowsazure/services/media/implementation/templates/playreadylicense/PlayReadyPlayRightTest.java
new file mode 100644
index 0000000..85fe399
--- /dev/null
+++ b/media/src/test/java/com/microsoft/windowsazure/services/media/implementation/templates/playreadylicense/PlayReadyPlayRightTest.java
@@ -0,0 +1,31 @@
+package com.microsoft.windowsazure.services.media.implementation.templates.playreadylicense;
+
+import static org.junit.Assert.*;
+
+import org.junit.Test;
+
+import com.microsoft.windowsazure.services.media.implementation.templates.playreadylicense.AgcAndColorStripeRestriction;
+import com.microsoft.windowsazure.services.media.implementation.templates.playreadylicense.ExplicitAnalogTelevisionRestriction;
+import com.microsoft.windowsazure.services.media.implementation.templates.playreadylicense.PlayReadyPlayRight;
+import com.microsoft.windowsazure.services.media.implementation.templates.playreadylicense.UnknownOutputPassingOption;
+
+public class PlayReadyPlayRightTest {
+    
+    @Test
+    public void RoundTripTest() throws Exception {
+        // Arrange
+        PlayReadyPlayRight playRight = new PlayReadyPlayRight();
+        // Act
+        playRight.setAgcAndColorStripeRestriction(new AgcAndColorStripeRestriction((byte) 0));
+        playRight.setAllowPassingVideoContentToUnknownOutput(UnknownOutputPassingOption.NotAllowed);
+        playRight.setAnalogVideoOpl(100);
+        playRight.setCompressedDigitalAudioOpl(200);
+        playRight.setCompressedDigitalVideoOpl(400);
+        playRight.setDigitalVideoOnlyContentRestriction(true);
+        playRight.setExplicitAnalogTelevisionOutputRestriction(new ExplicitAnalogTelevisionRestriction(true, (byte)0));
+        // Test
+        assertEquals(playRight.getAgcAndColorStripeRestriction().getConfigurationData(), (byte)0);
+        assertEquals(playRight.getAllowPassingVideoContentToUnknownOutput(), UnknownOutputPassingOption.NotAllowed);
+    }
+
+}
diff --git a/media/src/test/java/com/microsoft/windowsazure/services/scenarios/MediaServiceValidation.java b/media/src/test/java/com/microsoft/windowsazure/services/scenarios/MediaServiceValidation.java
index 1e25eca..4279d7b 100644
--- a/media/src/test/java/com/microsoft/windowsazure/services/scenarios/MediaServiceValidation.java
+++ b/media/src/test/java/com/microsoft/windowsazure/services/scenarios/MediaServiceValidation.java
@@ -239,9 +239,9 @@ class MediaServiceValidation {
 
     protected void assertDateApproxEquals(String message, Date expected,
             Date actual) {
-        // Default allows for a 30 seconds difference in dates, for clock skew,
+        // Default allows for a 2:30 minutes difference in dates, for clock skew,
         // network delays, etc.
-        long deltaInMilliseconds = 30000;
+        long deltaInMilliseconds = 150000;
 
         if (expected == null || actual == null) {
             assertEquals(message, expected, actual);
-- 
1.9.5.msysgit.1


From 131cfdd93b3cd8da0e6d4f52f178941719c916ed Mon Sep 17 00:00:00 2001
From: Emanuel Vecchio <vecchioemanuel@gmail.com>
Date: Fri, 24 Jul 2015 16:32:10 -0300
Subject: [PATCH 07/21] Integration Test, Unit Test and README updates.

---
 README.md                                          |  11 ++-
 media/pom.xml                                      |   2 +-
 .../content/AssetDeliveryPolicyRestType.java       |  49 ++++++++--
 .../services/media/models/AssetDeliveryPolicy.java |   9 +-
 .../media/models/AssetDeliveryPolicyInfo.java      |   3 +-
 .../services/media/models/ContentKey.java          |  20 +++-
 .../services/media/AssetIntegrationTest.java       | 106 ++++++++++++++++++++
 .../services/media/ContentKeyIntegrationTest.java  |  73 ++++++++++++++
 ...ntentKeyAuthorizationPolicyRestrictionTest.java |  12 ---
 .../ODataSerializationFromJerseyTest.java          |   1 -
 .../implementation/ODataSerializationTest.java     |   8 +-
 .../AgcAndColorStripeRestrictionTests.java         |   1 -
 ...ediaServicesLicenseTemplateSerializerTests.java |   3 -
 .../tokenrestriction/TokenClaimTests.java          |   4 +-
 .../TokenRestrictionTemplateSerializerTests.java   |  13 +--
 .../models/AssetDeliveryPolicyEntityTest.java      | 107 +++++++++++++++++++++
 .../queue/QueueServiceIntegrationTest.java         |   1 -
 .../services/scenarios/MediaServiceWrapper.java    |   6 +-
 18 files changed, 369 insertions(+), 60 deletions(-)
 create mode 100644 media/src/test/java/com/microsoft/windowsazure/services/media/models/AssetDeliveryPolicyEntityTest.java

diff --git a/README.md b/README.md
index 1308539..6f57484 100644
--- a/README.md
+++ b/README.md
@@ -23,10 +23,14 @@ This project provides a client library in Java that makes it easy to consume Mic
     * Create/Read/Update/Delete access policies
     * Create/Read/Update/Delete asset files
     * Create/Read/Update/Delete assets
+    * Create/Read/Delete asset delivery policies
     * Create/Read/Update/Delete/Rebind content keys
+    * Create/Read/Delete content keys authorization policies/options
     * Create/Read/Update/Cancel/Delete jobs
     * Add/Get job notifications
     * Create/Read/Update/Delete notification endpoints
+    * Serialize/Deserialize/GetTestToken [TokenRestriction](https://msdn.microsoft.com/en-us/library/azure/dn783467.aspx#code-snippet-4) Templates
+    * Serialize/Deserialize [PlayReadyLicenseResponse](https://azure.microsoft.com/en-us/documentation/articles/media-services-playready-license-template-overview/#_schema) Templates
 * Service Management
     * Management
       * Create/Delete/Get/List/Update affinity group
@@ -52,13 +56,13 @@ This project provides a client library in Java that makes it easy to consume Mic
     * Network Management
       * Create/Delete/Get/List client root certificate
       * Connect/Disconnect/Testing/Create/Delete/Failover/ResetSharedKey gateway operations
-      * SetConfiguration/GetConfiguration/Get/List network 
+      * SetConfiguration/GetConfiguration/Get/List network
       * Create/Delete/Get/List reserved IP operations
       * Check static IP operations
     * Storage Management
       * Create/CheckNameAvailability/Delete/Get/GetAsync/GetKeys/List/RegenerateKeys/Update Azure storage account
     * Sql Database Management
-      * Export/GetStatus/Import database 
+      * Export/GetStatus/Import database
       * Get/List database operation's operation
       * Create/Delete/Get/GetAsync/GetEventLogs/List/Update database operations
       * Create/Delete/Get/List/Update firewall rule
@@ -67,7 +71,7 @@ This project provides a client library in Java that makes it easy to consume Mic
 * Service Runtime
     * Retrieve information about the state of your Azure Compute instances
 * Storage
-	* The Azure Storage SDK for Java is maintained in a separate repository. You can find the Azure Storage SDK for Java at [https://github.com/Azure/azure-storage-java](https://github.com/Azure/azure-storage-java). 
+	* The Azure Storage SDK for Java is maintained in a separate repository. You can find the Azure Storage SDK for Java at [https://github.com/Azure/azure-storage-java](https://github.com/Azure/azure-storage-java).
 
 #Getting Started
 
@@ -177,4 +181,3 @@ If you encounter any bugs with the library please file an issue in the [Issues](
 
 * [Microsoft Azure Java Developer Center](http://azure.microsoft.com/en-us/develop/java/)
 * [JavaDocs](http://dl.windowsazure.com/javadoc/)
-
diff --git a/media/pom.xml b/media/pom.xml
index e4bf830..978b0b0 100644
--- a/media/pom.xml
+++ b/media/pom.xml
@@ -104,7 +104,7 @@
     <dependency>
       <groupId>com.fasterxml.jackson.core</groupId>
       <artifactId>jackson-core</artifactId>
-      <version>${jackson.version}</version>
+      <version>${jackson.version}</version><!--$NO-MVN-MAN-VER$-->
     </dependency>
     <dependency>
       <groupId>io.jsonwebtoken</groupId>
diff --git a/media/src/main/java/com/microsoft/windowsazure/services/media/implementation/content/AssetDeliveryPolicyRestType.java b/media/src/main/java/com/microsoft/windowsazure/services/media/implementation/content/AssetDeliveryPolicyRestType.java
index bff9937..263a4b4 100644
--- a/media/src/main/java/com/microsoft/windowsazure/services/media/implementation/content/AssetDeliveryPolicyRestType.java
+++ b/media/src/main/java/com/microsoft/windowsazure/services/media/implementation/content/AssetDeliveryPolicyRestType.java
@@ -16,11 +16,18 @@
 package com.microsoft.windowsazure.services.media.implementation.content;
 
 import java.util.Date;
+import java.util.HashMap;
+import java.util.Map;
 
 import javax.xml.bind.annotation.XmlAccessType;
 import javax.xml.bind.annotation.XmlAccessorType;
 import javax.xml.bind.annotation.XmlElement;
 
+import org.codehaus.jettison.json.JSONArray;
+import org.codehaus.jettison.json.JSONObject;
+
+import com.microsoft.windowsazure.services.media.models.AssetDeliveryPolicyConfigurationKey;
+
 /**
  * This type maps the XML returned in the odata ATOM serialization for Asset
  * entities.
@@ -49,7 +56,7 @@ public class AssetDeliveryPolicyRestType implements MediaServiceDTO {
     
     @XmlElement(name = "AssetDeliveryConfiguration", namespace = Constants.ODATA_DATA_NS)
     private String assetDeliveryConfiguration;
-
+      
     /**
      * @return the id
      */
@@ -149,18 +156,42 @@ public class AssetDeliveryPolicyRestType implements MediaServiceDTO {
     /**
      * @return the asset delivery configuration
      */
-    public String getAssetDeliveryConfiguration() {
-        return assetDeliveryConfiguration;
+    public Map<AssetDeliveryPolicyConfigurationKey, String> getAssetDeliveryConfiguration() {
+        try {
+            Map<AssetDeliveryPolicyConfigurationKey, String> results 
+                = new HashMap<AssetDeliveryPolicyConfigurationKey, String>();
+            JSONArray source = new JSONArray(assetDeliveryConfiguration);
+            for (int i = 0; i < source.length(); i++) {
+                JSONObject row = source.getJSONObject(i);
+                results.put(AssetDeliveryPolicyConfigurationKey.fromCode(row.getInt("Key")),
+                        row.getString("Value"));
+            }
+            return results;
+        } catch (Exception e) {
+            throw new RuntimeException(e);
+        }
     }
-
+    
     /**
      * @param assetDeliveryConfiguration
-     *            the asset delivery configuration to set
+     *            the asset delivery configuration
+     * @return 
      */
-    public AssetDeliveryPolicyRestType setAssetDeliveryConfiguration(String assetDeliveryConfiguration) {
-        this.assetDeliveryConfiguration = assetDeliveryConfiguration;
+    public AssetDeliveryPolicyRestType setAssetDeliveryConfiguration(Map<AssetDeliveryPolicyConfigurationKey, String> assetDeliveryConfiguration) {
+        try {
+            JSONArray result = new JSONArray();
+            if (assetDeliveryConfiguration != null) {
+                for (Map.Entry<AssetDeliveryPolicyConfigurationKey, String> item : assetDeliveryConfiguration.entrySet()) {
+                    JSONObject obj = new JSONObject();
+                    obj.put("Key", item.getKey().getCode());
+                    obj.put("Value", item.getValue());
+                    result.put(obj);
+                }
+                this.assetDeliveryConfiguration = result.toString();
+            }
+        } catch (Exception e) {
+            throw new RuntimeException(e);
+        }
         return this;
     }
-
-    
 }
diff --git a/media/src/main/java/com/microsoft/windowsazure/services/media/models/AssetDeliveryPolicy.java b/media/src/main/java/com/microsoft/windowsazure/services/media/models/AssetDeliveryPolicy.java
index 9ed7125..1e9c68e 100644
--- a/media/src/main/java/com/microsoft/windowsazure/services/media/models/AssetDeliveryPolicy.java
+++ b/media/src/main/java/com/microsoft/windowsazure/services/media/models/AssetDeliveryPolicy.java
@@ -16,6 +16,7 @@
 package com.microsoft.windowsazure.services.media.models;
 
 import java.util.EnumSet;
+import java.util.Map;
 
 import com.microsoft.windowsazure.services.media.entityoperations.DefaultDeleteOperation;
 import com.microsoft.windowsazure.services.media.entityoperations.DefaultGetOperation;
@@ -55,7 +56,7 @@ public final class AssetDeliveryPolicy {
         private String name;
         private EnumSet<AssetDeliveryProtocol> assetDeliveryProtocol;
         private AssetDeliveryPolicyType assetDeliveryPolicyType;
-        private String assetDeliveryConfiguration;
+        private Map<AssetDeliveryPolicyConfigurationKey, String> assetDeliveryConfiguration;
 
         public Creator() {
             super(ENTITY_SET, AssetDeliveryPolicyInfo.class);
@@ -108,12 +109,12 @@ public final class AssetDeliveryPolicy {
         /**
          * Set the configuration of the Asset Delivery Policy to be created.
          * 
-         * @param assetDeliveryConfiguration
+         * @param assetDeliveryPolicyConfiguration
          *            The configuration
          * @return The creator object (for call chaining)
          */
-        public Creator setAssetDeliveryConfiguration(String assetDeliveryConfiguration) {
-            this.assetDeliveryConfiguration = assetDeliveryConfiguration;
+        public Creator setAssetDeliveryConfiguration(Map<AssetDeliveryPolicyConfigurationKey, String> assetDeliveryPolicyConfiguration) {
+            this.assetDeliveryConfiguration = assetDeliveryPolicyConfiguration;
             return this;
         }
 
diff --git a/media/src/main/java/com/microsoft/windowsazure/services/media/models/AssetDeliveryPolicyInfo.java b/media/src/main/java/com/microsoft/windowsazure/services/media/models/AssetDeliveryPolicyInfo.java
index a8f3cf3..4665ce3 100644
--- a/media/src/main/java/com/microsoft/windowsazure/services/media/models/AssetDeliveryPolicyInfo.java
+++ b/media/src/main/java/com/microsoft/windowsazure/services/media/models/AssetDeliveryPolicyInfo.java
@@ -17,6 +17,7 @@ package com.microsoft.windowsazure.services.media.models;
 
 import java.util.Date;
 import java.util.EnumSet;
+import java.util.Map;
 
 import com.microsoft.windowsazure.services.media.implementation.ODataEntity;
 import com.microsoft.windowsazure.services.media.implementation.atom.EntryType;
@@ -82,7 +83,7 @@ public class AssetDeliveryPolicyInfo extends ODataEntity<AssetDeliveryPolicyRest
      * 
      * @return the configuration.
      */
-    public String getAssetDeliveryConfiguration() {
+    public Map<AssetDeliveryPolicyConfigurationKey, String> getAssetDeliveryConfiguration() {
         return getContent().getAssetDeliveryConfiguration();
     }
 
diff --git a/media/src/main/java/com/microsoft/windowsazure/services/media/models/ContentKey.java b/media/src/main/java/com/microsoft/windowsazure/services/media/models/ContentKey.java
index 7b8ba42..89d9cab 100644
--- a/media/src/main/java/com/microsoft/windowsazure/services/media/models/ContentKey.java
+++ b/media/src/main/java/com/microsoft/windowsazure/services/media/models/ContentKey.java
@@ -367,8 +367,13 @@ public final class ContentKey {
 
         @Override
         public Object getRequestContents() throws ServiceException {
-            String document = "{\"keyDeliveryType\": " + contentKeyDeliveryType.getCode() + "}";
-            return document;
+            JSONObject document = new JSONObject();
+            try {
+                document.put("keyDeliveryType", contentKeyDeliveryType.getCode());
+            } catch (JSONException e) {
+                throw new ServiceException("JSON Exception", e);
+            }
+            return document.toString();
         }
         
         @Override
@@ -389,7 +394,7 @@ public final class ContentKey {
             } catch (JSONException e) {
                 throw new ServiceException(e);
             }
-        }        
+        }
     }    
     
     /** Updates a ContentKey with an ContentKeyAuthorizationPolicyId
@@ -420,8 +425,13 @@ public final class ContentKey {
         
         @Override
         public Object getRequestContents() {
-            String document = "{\"AuthorizationPolicyId\":\"" + contentKeyAuthorizationPolicyId + "\"}";
-            return document;
+            JSONObject document = new JSONObject();
+            try {
+                document.put("AuthorizationPolicyId", contentKeyAuthorizationPolicyId);
+            } catch (JSONException e) {
+                throw new RuntimeException("JSON Exception", e);
+            }
+            return document.toString();
         }
 
     }
diff --git a/media/src/test/java/com/microsoft/windowsazure/services/media/AssetIntegrationTest.java b/media/src/test/java/com/microsoft/windowsazure/services/media/AssetIntegrationTest.java
index e887fc2..a3e8266 100644
--- a/media/src/test/java/com/microsoft/windowsazure/services/media/AssetIntegrationTest.java
+++ b/media/src/test/java/com/microsoft/windowsazure/services/media/AssetIntegrationTest.java
@@ -34,6 +34,10 @@ import com.microsoft.windowsazure.services.media.models.AccessPolicy;
 import com.microsoft.windowsazure.services.media.models.AccessPolicyInfo;
 import com.microsoft.windowsazure.services.media.models.AccessPolicyPermission;
 import com.microsoft.windowsazure.services.media.models.Asset;
+import com.microsoft.windowsazure.services.media.models.AssetDeliveryPolicy;
+import com.microsoft.windowsazure.services.media.models.AssetDeliveryPolicyInfo;
+import com.microsoft.windowsazure.services.media.models.AssetDeliveryPolicyType;
+import com.microsoft.windowsazure.services.media.models.AssetDeliveryProtocol;
 import com.microsoft.windowsazure.services.media.models.AssetFile;
 import com.microsoft.windowsazure.services.media.models.AssetInfo;
 import com.microsoft.windowsazure.services.media.models.AssetOption;
@@ -409,4 +413,106 @@ public class AssetIntegrationTest extends IntegrationTestBase {
         // Assert
         assertEquals(originalAsset.getId(), parentAsset.getId());
     }
+    
+    @Test
+    public void unlinkAssetContentKeySuccess() throws ServiceException,
+            URISyntaxException {
+        // Arrange
+        String originalTestName = testAssetPrefix
+                + "linkAssetContentKeySuccess";
+        AssetInfo assetInfo = service.create(Asset.create()
+                .setName(originalTestName)
+                .setOptions(AssetOption.StorageEncrypted));
+
+        String protectionKeyId = service.action(ProtectionKey
+                .getProtectionKeyId(ContentKeyType.StorageEncryption));
+        String contentKeyId = String
+                .format("nb:kid:UUID:%s", UUID.randomUUID());
+        String encryptedContentKey = "dummyEncryptedContentKey";
+        service.create(ContentKey.create(contentKeyId,
+                ContentKeyType.StorageEncryption, encryptedContentKey)
+                .setProtectionKeyId(protectionKeyId));
+        service.action(Asset.linkContentKey(assetInfo.getId(), contentKeyId));
+
+        // Act
+        service.delete(Asset.unlinkContentKey(assetInfo.getId(), contentKeyId));
+
+        // Assert
+        List<ContentKeyInfo> contentKeys = service.list(ContentKey
+                .list(assetInfo.getContentKeysLink()));
+        assertEquals(0, contentKeys.size());
+    }
+    
+    @Test
+    public void linkAssetDeliveryPolicySuccess() throws ServiceException,
+            URISyntaxException {
+        // Arrange
+        String originalTestName = testAssetPrefix
+                + "linkAssetContentKeySuccess";
+        AssetDeliveryPolicyInfo adpInfo = service.create(AssetDeliveryPolicy.create()
+                .setName(originalTestName)
+                .setAssetDeliveryPolicyType(AssetDeliveryPolicyType.NoDynamicEncryption)
+                .setAssetDeliveryProtocol(EnumSet.of(AssetDeliveryProtocol.SmoothStreaming)));
+        
+        AssetInfo assetInfo = service.create(Asset.create()
+                .setName(originalTestName)
+                .setOptions(AssetOption.StorageEncrypted));
+        
+        String protectionKeyId = service.action(ProtectionKey
+                .getProtectionKeyId(ContentKeyType.StorageEncryption));
+        String contentKeyId = String
+                .format("nb:kid:UUID:%s", UUID.randomUUID());
+        String encryptedContentKey = "dummyEncryptedContentKey";
+        service.create(ContentKey.create(contentKeyId,
+                ContentKeyType.StorageEncryption, encryptedContentKey)
+                .setProtectionKeyId(protectionKeyId));        
+        service.action(Asset.linkContentKey(assetInfo.getId(), contentKeyId));
+        
+        // Act
+        service.action(Asset.linkDeliveryPolicy(assetInfo.getId(), adpInfo.getId()));
+        
+        // Assert
+        AssetInfo assetInfo2 = service.get(Asset.get(assetInfo.getId()));
+        ListResult<AssetDeliveryPolicyInfo> listResult = service.list(AssetDeliveryPolicy.list(assetInfo2.getDeliveryPoliciesLink()));
+        assertNotNull(listResult);
+        assertEquals(listResult.size(), 1);
+        assertEquals(listResult.get(0).getName(), originalTestName);
+        assertEquals(listResult.get(0).getAssetDeliveryPolicyType(), AssetDeliveryPolicyType.NoDynamicEncryption);
+    }
+    
+    @Test
+    public void unlinkAssetDeliveryPolicySuccess() throws ServiceException,
+            URISyntaxException {        
+        // Arrange
+        String originalTestName = testAssetPrefix
+                + "unlinkAssetContentKeySuccess";
+        AssetDeliveryPolicyInfo adpInfo = service.create(AssetDeliveryPolicy.create()
+                .setName(originalTestName)
+                .setAssetDeliveryPolicyType(AssetDeliveryPolicyType.NoDynamicEncryption)
+                .setAssetDeliveryProtocol(EnumSet.of(AssetDeliveryProtocol.SmoothStreaming)));
+        
+        AssetInfo assetInfo = service.create(Asset.create()
+                .setName(originalTestName)
+                .setOptions(AssetOption.StorageEncrypted));
+        
+        String protectionKeyId = service.action(ProtectionKey
+                .getProtectionKeyId(ContentKeyType.StorageEncryption));
+        String contentKeyId = String
+                .format("nb:kid:UUID:%s", UUID.randomUUID());
+        String encryptedContentKey = "dummyEncryptedContentKey";
+        service.create(ContentKey.create(contentKeyId,
+                ContentKeyType.StorageEncryption, encryptedContentKey)
+                .setProtectionKeyId(protectionKeyId));        
+        service.action(Asset.linkContentKey(assetInfo.getId(), contentKeyId));
+        service.action(Asset.linkDeliveryPolicy(assetInfo.getId(), adpInfo.getId()));
+        
+        // Act
+        service.delete(Asset.unlinkDeliveryPolicy(assetInfo.getId(), adpInfo.getId()));
+        
+        // Assert
+        AssetInfo assetInfo2 = service.get(Asset.get(assetInfo.getId()));
+        ListResult<AssetDeliveryPolicyInfo> listResult = service.list(AssetDeliveryPolicy.list(assetInfo2.getDeliveryPoliciesLink()));
+        assertNotNull(listResult);
+        assertEquals(listResult.size(), 0);
+    }
 }
diff --git a/media/src/test/java/com/microsoft/windowsazure/services/media/ContentKeyIntegrationTest.java b/media/src/test/java/com/microsoft/windowsazure/services/media/ContentKeyIntegrationTest.java
index 0ce3970..cd683bc 100644
--- a/media/src/test/java/com/microsoft/windowsazure/services/media/ContentKeyIntegrationTest.java
+++ b/media/src/test/java/com/microsoft/windowsazure/services/media/ContentKeyIntegrationTest.java
@@ -19,6 +19,7 @@ import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertNotNull;
 
+import java.net.URI;
 import java.net.URL;
 import java.net.URLDecoder;
 import java.net.URLEncoder;
@@ -35,6 +36,13 @@ import org.junit.Test;
 import com.microsoft.windowsazure.core.utils.Base64;
 import com.microsoft.windowsazure.exception.ServiceException;
 import com.microsoft.windowsazure.services.media.models.ContentKey;
+import com.microsoft.windowsazure.services.media.models.ContentKeyAuthorizationPolicy;
+import com.microsoft.windowsazure.services.media.models.ContentKeyAuthorizationPolicyInfo;
+import com.microsoft.windowsazure.services.media.models.ContentKeyAuthorizationPolicyOption;
+import com.microsoft.windowsazure.services.media.models.ContentKeyAuthorizationPolicyOptionInfo;
+import com.microsoft.windowsazure.services.media.models.ContentKeyAuthorizationPolicyRestriction;
+import com.microsoft.windowsazure.services.media.models.ContentKeyAuthorizationPolicyRestriction.ContentKeyRestrictionType;
+import com.microsoft.windowsazure.services.media.models.ContentKeyDeliveryType;
 import com.microsoft.windowsazure.services.media.models.ContentKeyInfo;
 import com.microsoft.windowsazure.services.media.models.ContentKeyType;
 import com.microsoft.windowsazure.services.media.models.ProtectionKey;
@@ -371,4 +379,69 @@ public class ContentKeyIntegrationTest extends IntegrationTestBase {
         service.action(ContentKey.rebind(contentKeyInfo.getId(),
                 "InvalidX509Certificate"));
     }
+    
+    @Test
+    public void canSetContentKeyAuthorizationPolicySuccess() throws Exception {
+        // Arrange
+        String testCanCreateContentKeyId = createRandomContentKeyId();
+        String testCanCreateContentKeyName = testContentKeyPrefix
+                + "testSetContentKeyAuthorizationPolicy";
+        
+        String protectionKeyId = service.action(ProtectionKey
+                .getProtectionKeyId(ContentKeyType.EnvelopeEncryption));        
+        ContentKeyInfo contentKeyInfo = service.create(ContentKey
+                .create(testCanCreateContentKeyId, ContentKeyType.EnvelopeEncryption,
+                        testEncryptedContentKey)
+                .setName(testCanCreateContentKeyName)
+                .setProtectionKeyId(protectionKeyId));
+        List<ContentKeyAuthorizationPolicyRestriction> restrictions = new ArrayList<ContentKeyAuthorizationPolicyRestriction>();
+        restrictions.add(new ContentKeyAuthorizationPolicyRestriction(testCanCreateContentKeyName, ContentKeyRestrictionType.Open.getValue(), null));
+        ContentKeyAuthorizationPolicyOptionInfo contentKeyAuthPoliceOptionInfo = service.create(
+                    ContentKeyAuthorizationPolicyOption.create(testCanCreateContentKeyName, 
+                            ContentKeyDeliveryType.BaselineHttp.getCode(), null, restrictions));
+        ContentKeyAuthorizationPolicyInfo contentKeyAuthorizationPolicyInfo = service.create(
+                ContentKeyAuthorizationPolicy.create(testCanCreateContentKeyName));
+        service.action(ContentKeyAuthorizationPolicy.linkOptions(contentKeyAuthorizationPolicyInfo.getId(), contentKeyAuthPoliceOptionInfo.getId()));
+        
+        // Act
+        service.update(ContentKey.update(contentKeyInfo.getId(), contentKeyAuthorizationPolicyInfo.getId()));  
+  
+        // Assert
+        ContentKeyInfo contentKeyInfo2 = service.get(ContentKey.get(contentKeyInfo.getId()));
+        assertNotNull(contentKeyInfo2);
+        assertEquals(contentKeyInfo2.getName(), contentKeyInfo.getName());
+        assertEquals(contentKeyInfo2.getAuthorizationPolicyId(), contentKeyAuthorizationPolicyInfo.getId());
+    }
+    
+    @Test
+    public void canGetDeliveryUrlSuccess() throws Exception {
+        // Arrange
+        String testCanCreateContentKeyId = createRandomContentKeyId();
+        String testCanCreateContentKeyName = testContentKeyPrefix
+                + "testGetDeliveryUrl";
+        
+        String protectionKeyId = service.action(ProtectionKey
+                .getProtectionKeyId(ContentKeyType.EnvelopeEncryption));        
+        ContentKeyInfo contentKeyInfo = service.create(ContentKey
+                .create(testCanCreateContentKeyId, ContentKeyType.EnvelopeEncryption,
+                        testEncryptedContentKey)
+                .setName(testCanCreateContentKeyName)
+                .setProtectionKeyId(protectionKeyId));
+        List<ContentKeyAuthorizationPolicyRestriction> restrictions = new ArrayList<ContentKeyAuthorizationPolicyRestriction>();
+        restrictions.add(new ContentKeyAuthorizationPolicyRestriction(testCanCreateContentKeyName, ContentKeyRestrictionType.Open.getValue(), null));
+        ContentKeyAuthorizationPolicyOptionInfo contentKeyAuthPoliceOptionInfo = service.create(
+                    ContentKeyAuthorizationPolicyOption.create(testCanCreateContentKeyName, 
+                            ContentKeyDeliveryType.BaselineHttp.getCode(), null, restrictions));
+        ContentKeyAuthorizationPolicyInfo contentKeyAuthorizationPolicyInfo = service.create(
+                ContentKeyAuthorizationPolicy.create(testCanCreateContentKeyName));
+        service.action(ContentKeyAuthorizationPolicy.linkOptions(contentKeyAuthorizationPolicyInfo.getId(), contentKeyAuthPoliceOptionInfo.getId()));
+        
+        // Act
+        String acquisitionUrlString = service
+                .create(ContentKey.getKeyDeliveryUrl(contentKeyInfo.getId(), ContentKeyDeliveryType.BaselineHttp));
+  
+        // Assert
+        URI acquisitionUrl = URI.create(acquisitionUrlString);
+        assertNotNull(acquisitionUrl);
+    }
 }
diff --git a/media/src/test/java/com/microsoft/windowsazure/services/media/contentprotection/ContentKeyAuthorizationPolicyRestrictionTest.java b/media/src/test/java/com/microsoft/windowsazure/services/media/contentprotection/ContentKeyAuthorizationPolicyRestrictionTest.java
index 3c3d3c8..739b91f 100644
--- a/media/src/test/java/com/microsoft/windowsazure/services/media/contentprotection/ContentKeyAuthorizationPolicyRestrictionTest.java
+++ b/media/src/test/java/com/microsoft/windowsazure/services/media/contentprotection/ContentKeyAuthorizationPolicyRestrictionTest.java
@@ -16,21 +16,9 @@
 package com.microsoft.windowsazure.services.media.contentprotection;
 
 import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNotNull;
-import static org.junit.Assert.assertNull;
-
-import java.net.URLEncoder;
 
 import org.junit.Test;
 
-import com.microsoft.windowsazure.exception.ServiceException;
-import com.microsoft.windowsazure.services.media.entityoperations.EntityDeleteOperation;
-import com.microsoft.windowsazure.services.media.entityoperations.EntityGetOperation;
-import com.microsoft.windowsazure.services.media.entityoperations.EntityListOperation;
-import com.microsoft.windowsazure.services.media.implementation.content.ContentKeyAuthorizationPolicyType;
-import com.microsoft.windowsazure.services.media.implementation.templates.tokenrestriction.TokenType;
-import com.microsoft.windowsazure.services.media.models.ContentKeyAuthorizationPolicy;
-import com.microsoft.windowsazure.services.media.models.ContentKeyAuthorizationPolicyInfo;
 import com.microsoft.windowsazure.services.media.models.ContentKeyAuthorizationPolicyRestriction;
 
 /**
diff --git a/media/src/test/java/com/microsoft/windowsazure/services/media/implementation/ODataSerializationFromJerseyTest.java b/media/src/test/java/com/microsoft/windowsazure/services/media/implementation/ODataSerializationFromJerseyTest.java
index 6596241..81521a3 100644
--- a/media/src/test/java/com/microsoft/windowsazure/services/media/implementation/ODataSerializationFromJerseyTest.java
+++ b/media/src/test/java/com/microsoft/windowsazure/services/media/implementation/ODataSerializationFromJerseyTest.java
@@ -35,7 +35,6 @@ import com.sun.jersey.api.client.Client;
 import com.sun.jersey.api.client.WebResource;
 import com.sun.jersey.api.client.config.ClientConfig;
 import com.sun.jersey.api.client.config.DefaultClientConfig;
-import com.sun.jersey.api.client.filter.LoggingFilter;
 import com.sun.jersey.api.json.JSONConfiguration;
 
 public class ODataSerializationFromJerseyTest extends IntegrationTestBase {
diff --git a/media/src/test/java/com/microsoft/windowsazure/services/media/implementation/ODataSerializationTest.java b/media/src/test/java/com/microsoft/windowsazure/services/media/implementation/ODataSerializationTest.java
index af8d39d..0810cca 100644
--- a/media/src/test/java/com/microsoft/windowsazure/services/media/implementation/ODataSerializationTest.java
+++ b/media/src/test/java/com/microsoft/windowsazure/services/media/implementation/ODataSerializationTest.java
@@ -15,6 +15,8 @@
 
 package com.microsoft.windowsazure.services.media.implementation;
 
+import static org.junit.Assert.assertEquals;
+
 import java.io.ByteArrayInputStream;
 import java.io.InputStream;
 import java.util.List;
@@ -24,8 +26,6 @@ import javax.xml.bind.JAXBElement;
 import javax.xml.bind.Marshaller;
 import javax.xml.namespace.QName;
 
-import junit.framework.Assert;
-
 import org.junit.Test;
 
 import com.microsoft.windowsazure.services.media.implementation.atom.ContentType;
@@ -76,8 +76,8 @@ public class ODataSerializationTest {
         InputStream input = new ByteArrayInputStream(
                 sampleFeedOneAsset.getBytes("UTF-8"));
         List<AssetInfo> entries = um.unmarshalFeed(input, AssetInfo.class);
-        Assert.assertEquals(1, entries.size());
-        Assert.assertEquals("nb:cid:UUID:1f6c7bb4-8013-486e-b4c9-2e4a6842b9a6",
+        assertEquals(1, entries.size());
+        assertEquals("nb:cid:UUID:1f6c7bb4-8013-486e-b4c9-2e4a6842b9a6",
                 entries.get(0).getId());
     }
 
diff --git a/media/src/test/java/com/microsoft/windowsazure/services/media/implementation/templates/playreadylicense/AgcAndColorStripeRestrictionTests.java b/media/src/test/java/com/microsoft/windowsazure/services/media/implementation/templates/playreadylicense/AgcAndColorStripeRestrictionTests.java
index 279e761..0979434 100644
--- a/media/src/test/java/com/microsoft/windowsazure/services/media/implementation/templates/playreadylicense/AgcAndColorStripeRestrictionTests.java
+++ b/media/src/test/java/com/microsoft/windowsazure/services/media/implementation/templates/playreadylicense/AgcAndColorStripeRestrictionTests.java
@@ -2,7 +2,6 @@ package com.microsoft.windowsazure.services.media.implementation.templates.playr
 
 import static org.junit.Assert.*;
 
-import java.security.InvalidParameterException;
 import org.junit.Test;
 
 import com.microsoft.windowsazure.services.media.implementation.templates.playreadylicense.AgcAndColorStripeRestriction;
diff --git a/media/src/test/java/com/microsoft/windowsazure/services/media/implementation/templates/playreadylicense/MediaServicesLicenseTemplateSerializerTests.java b/media/src/test/java/com/microsoft/windowsazure/services/media/implementation/templates/playreadylicense/MediaServicesLicenseTemplateSerializerTests.java
index d46676e..ef5cf83 100644
--- a/media/src/test/java/com/microsoft/windowsazure/services/media/implementation/templates/playreadylicense/MediaServicesLicenseTemplateSerializerTests.java
+++ b/media/src/test/java/com/microsoft/windowsazure/services/media/implementation/templates/playreadylicense/MediaServicesLicenseTemplateSerializerTests.java
@@ -6,8 +6,6 @@ import java.util.Date;
 import java.util.UUID;
 import java.util.Arrays;
 
-import javax.xml.bind.JAXBException;
-import javax.xml.datatype.DatatypeConfigurationException;
 import javax.xml.datatype.DatatypeFactory;
 import javax.xml.datatype.Duration;
 
@@ -25,7 +23,6 @@ import com.microsoft.windowsazure.services.media.implementation.templates.playre
 import com.microsoft.windowsazure.services.media.implementation.templates.playreadylicense.PlayReadyPlayRight;
 import com.microsoft.windowsazure.services.media.implementation.templates.playreadylicense.ScmsRestriction;
 import com.microsoft.windowsazure.services.media.implementation.templates.playreadylicense.UnknownOutputPassingOption;
-import com.sun.xml.bind.v2.runtime.unmarshaller.XsiNilLoader.Array;
 
 public class MediaServicesLicenseTemplateSerializerTests {
 
diff --git a/media/src/test/java/com/microsoft/windowsazure/services/media/implementation/templates/tokenrestriction/TokenClaimTests.java b/media/src/test/java/com/microsoft/windowsazure/services/media/implementation/templates/tokenrestriction/TokenClaimTests.java
index 57e415a..8bd4f1c 100644
--- a/media/src/test/java/com/microsoft/windowsazure/services/media/implementation/templates/tokenrestriction/TokenClaimTests.java
+++ b/media/src/test/java/com/microsoft/windowsazure/services/media/implementation/templates/tokenrestriction/TokenClaimTests.java
@@ -2,11 +2,8 @@ package com.microsoft.windowsazure.services.media.implementation.templates.token
 
 import static org.junit.Assert.*;
 
-import java.security.InvalidParameterException;
 import org.junit.Test;
 
-import com.microsoft.windowsazure.services.media.implementation.templates.tokenrestriction.TokenType;
-
 public class TokenClaimTests {
     
     @Test
@@ -39,6 +36,7 @@ public class TokenClaimTests {
         
         // Act
         try { 
+            @SuppressWarnings("unused")
             TokenClaim value = new TokenClaim(providedType, expectedValue);
             fail("Should thrown");
         } catch (NullPointerException e) {
diff --git a/media/src/test/java/com/microsoft/windowsazure/services/media/implementation/templates/tokenrestriction/TokenRestrictionTemplateSerializerTests.java b/media/src/test/java/com/microsoft/windowsazure/services/media/implementation/templates/tokenrestriction/TokenRestrictionTemplateSerializerTests.java
index eab925c..24ecb40 100644
--- a/media/src/test/java/com/microsoft/windowsazure/services/media/implementation/templates/tokenrestriction/TokenRestrictionTemplateSerializerTests.java
+++ b/media/src/test/java/com/microsoft/windowsazure/services/media/implementation/templates/tokenrestriction/TokenRestrictionTemplateSerializerTests.java
@@ -1,6 +1,10 @@
 package com.microsoft.windowsazure.services.media.implementation.templates.tokenrestriction;
 
-import static org.junit.Assert.*;
+import static org.junit.Assert.assertArrayEquals;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
 
 import java.net.URI;
 import java.net.URISyntaxException;
@@ -12,16 +16,9 @@ import java.util.UUID;
 
 import javax.xml.bind.JAXBException;
 
-import org.junit.Ignore;
 import org.junit.Test;
 import org.xml.sax.SAXException;
 
-import com.microsoft.windowsazure.services.media.implementation.templates.tokenrestriction.SymmetricVerificationKey;
-import com.microsoft.windowsazure.services.media.implementation.templates.tokenrestriction.TokenClaim;
-import com.microsoft.windowsazure.services.media.implementation.templates.tokenrestriction.TokenRestrictionTemplate;
-import com.microsoft.windowsazure.services.media.implementation.templates.tokenrestriction.TokenRestrictionTemplateSerializer;
-import com.microsoft.windowsazure.services.media.implementation.templates.tokenrestriction.TokenType;
-
 public class TokenRestrictionTemplateSerializerTests {
 
     private final String schemaFile = TokenRestrictionTemplateSerializerTests.class.getClassLoader().getResource("")
diff --git a/media/src/test/java/com/microsoft/windowsazure/services/media/models/AssetDeliveryPolicyEntityTest.java b/media/src/test/java/com/microsoft/windowsazure/services/media/models/AssetDeliveryPolicyEntityTest.java
new file mode 100644
index 0000000..ce801b5
--- /dev/null
+++ b/media/src/test/java/com/microsoft/windowsazure/services/media/models/AssetDeliveryPolicyEntityTest.java
@@ -0,0 +1,107 @@
+/**
+ * Copyright Microsoft Corporation
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.microsoft.windowsazure.services.media.models;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotNull;
+
+import java.io.StringReader;
+import java.io.StringWriter;
+import java.util.Date;
+import java.util.EnumSet;
+import java.util.HashMap;
+import java.util.Map;
+
+import javax.xml.bind.JAXBContext;
+import javax.xml.bind.JAXBElement;
+import javax.xml.bind.Marshaller;
+import javax.xml.bind.Unmarshaller;
+import javax.xml.namespace.QName;
+import javax.xml.transform.stream.StreamSource;
+
+import org.junit.Test;
+
+import com.microsoft.windowsazure.services.media.implementation.content.AssetDeliveryPolicyRestType;
+
+/**
+ * Tests for access policy entity
+ * 
+ */
+public class AssetDeliveryPolicyEntityTest {
+
+    private final String sampleAdpId = "nb:adpid:UUID:92b0f6ba-3c9f-49b6-a5fa-2a8703b04ecd";
+
+    public AssetDeliveryPolicyEntityTest() throws Exception {
+    }
+
+    @Test
+    public void restTypeRoundTripTest() throws Exception {
+        // Arrange
+        String expectedName = "restTypeRoundTripTest";
+        String expectedEnvelopeBaseKeyAcquisitionUrl = "expectedEnvelopeBaseKeyAcquisitionUrl";
+        String expectedEnvelopeEncryptionIV = "expectedEnvelopeEncryptionIV";
+        String expectedEnvelopeEncryptionIVAsBase64 = "expectedEnvelopeEncryptionIVAsBase64";
+        String expectedEnvelopeKeyAcquisitionUrl = "expectedEnvelopeKeyAcquisitionUrl";
+        String expectedPlayReadyCustomAttributes = "expectedPlayReadyCustomAttributes";
+        String expectedPlayReadyLicenseAcquisitionUrl = "expectedPlayReadyLicenseAcquisitionUrl";
+        AssetDeliveryPolicyType expectedAssetDeliveryPolicyType = AssetDeliveryPolicyType.DynamicCommonEncryption;
+        Date expectedDate = new Date();
+        AssetDeliveryPolicyRestType adp = new AssetDeliveryPolicyRestType();
+        adp.setId(sampleAdpId);
+        adp.setCreated(expectedDate);
+        adp.setName(expectedName);
+        adp.setAssetDeliveryProtocol(AssetDeliveryProtocol.bitsFromProtocols(EnumSet.of(AssetDeliveryProtocol.Dash, AssetDeliveryProtocol.Hds, AssetDeliveryProtocol.HLS, AssetDeliveryProtocol.SmoothStreaming)));
+        Map<AssetDeliveryPolicyConfigurationKey, String> assetDeliveryConfiguration
+            = new HashMap<AssetDeliveryPolicyConfigurationKey, String>();
+        assetDeliveryConfiguration.put(AssetDeliveryPolicyConfigurationKey.EnvelopeBaseKeyAcquisitionUrl, expectedEnvelopeBaseKeyAcquisitionUrl);
+        assetDeliveryConfiguration.put(AssetDeliveryPolicyConfigurationKey.EnvelopeEncryptionIV, expectedEnvelopeEncryptionIV);
+        assetDeliveryConfiguration.put(AssetDeliveryPolicyConfigurationKey.EnvelopeEncryptionIVAsBase64, expectedEnvelopeEncryptionIVAsBase64);
+        assetDeliveryConfiguration.put(AssetDeliveryPolicyConfigurationKey.EnvelopeKeyAcquisitionUrl, expectedEnvelopeKeyAcquisitionUrl);
+        assetDeliveryConfiguration.put(AssetDeliveryPolicyConfigurationKey.PlayReadyCustomAttributes, expectedPlayReadyCustomAttributes);
+        assetDeliveryConfiguration.put(AssetDeliveryPolicyConfigurationKey.PlayReadyLicenseAcquisitionUrl, expectedPlayReadyLicenseAcquisitionUrl);
+        adp.setAssetDeliveryConfiguration(assetDeliveryConfiguration);
+        adp.setAssetDeliveryPolicyType(expectedAssetDeliveryPolicyType.getCode());
+        
+        JAXBContext context = JAXBContext.newInstance(AssetDeliveryPolicyRestType.class);
+        JAXBContext context2 = JAXBContext.newInstance(AssetDeliveryPolicyRestType.class);
+        Marshaller marshaller = context.createMarshaller();
+        Unmarshaller unmarshaller = context2.createUnmarshaller();
+        StringWriter writer = new StringWriter();
+        QName qName = new QName("test.schema", "AssetDeliveryPolicyRestType");
+        JAXBElement<AssetDeliveryPolicyRestType> root = new JAXBElement<AssetDeliveryPolicyRestType>(qName, AssetDeliveryPolicyRestType.class, adp);
+        // Act
+        marshaller.marshal(root, writer);
+        String xml = writer.toString();  
+
+        JAXBElement<AssetDeliveryPolicyRestType> root2 = (JAXBElement<AssetDeliveryPolicyRestType>) unmarshaller.unmarshal(new StreamSource(new StringReader(xml)), AssetDeliveryPolicyRestType.class);
+        AssetDeliveryPolicyRestType results = root2.getValue();
+        
+        // Assert
+        assertNotNull(results);
+        Map<AssetDeliveryPolicyConfigurationKey, String> resultADC = results.getAssetDeliveryConfiguration();
+        assertEquals(resultADC.get(AssetDeliveryPolicyConfigurationKey.EnvelopeBaseKeyAcquisitionUrl), expectedEnvelopeBaseKeyAcquisitionUrl);
+        assertEquals(resultADC.get(AssetDeliveryPolicyConfigurationKey.EnvelopeEncryptionIV), expectedEnvelopeEncryptionIV);
+        assertEquals(resultADC.get(AssetDeliveryPolicyConfigurationKey.EnvelopeEncryptionIVAsBase64), expectedEnvelopeEncryptionIVAsBase64);
+        assertEquals(resultADC.get(AssetDeliveryPolicyConfigurationKey.EnvelopeKeyAcquisitionUrl), expectedEnvelopeKeyAcquisitionUrl);
+        assertEquals(resultADC.get(AssetDeliveryPolicyConfigurationKey.PlayReadyCustomAttributes), expectedPlayReadyCustomAttributes);
+        assertEquals(resultADC.get(AssetDeliveryPolicyConfigurationKey.PlayReadyLicenseAcquisitionUrl), expectedPlayReadyLicenseAcquisitionUrl);
+        assertEquals(results.getAssetDeliveryPolicyType().intValue(), expectedAssetDeliveryPolicyType.getCode());
+        assertEquals(results.getCreated(), expectedDate);        
+        assertEquals(results.getName(), expectedName);
+        assertEquals(results.getId(), sampleAdpId);
+    }
+
+}
diff --git a/media/src/test/java/com/microsoft/windowsazure/services/queue/QueueServiceIntegrationTest.java b/media/src/test/java/com/microsoft/windowsazure/services/queue/QueueServiceIntegrationTest.java
index 461c625..8b3b924 100644
--- a/media/src/test/java/com/microsoft/windowsazure/services/queue/QueueServiceIntegrationTest.java
+++ b/media/src/test/java/com/microsoft/windowsazure/services/queue/QueueServiceIntegrationTest.java
@@ -44,7 +44,6 @@ import com.microsoft.windowsazure.services.queue.models.ListQueuesResult;
 import com.microsoft.windowsazure.services.queue.models.ListQueuesResult.Queue;
 import com.microsoft.windowsazure.services.queue.models.PeekMessagesOptions;
 import com.microsoft.windowsazure.services.queue.models.PeekMessagesResult;
-import com.microsoft.windowsazure.services.queue.models.ServiceProperties;
 import com.microsoft.windowsazure.services.queue.models.UpdateMessageResult;
 
 public class QueueServiceIntegrationTest extends IntegrationTestBase {
diff --git a/media/src/test/java/com/microsoft/windowsazure/services/scenarios/MediaServiceWrapper.java b/media/src/test/java/com/microsoft/windowsazure/services/scenarios/MediaServiceWrapper.java
index c6409e6..fafbd60 100644
--- a/media/src/test/java/com/microsoft/windowsazure/services/scenarios/MediaServiceWrapper.java
+++ b/media/src/test/java/com/microsoft/windowsazure/services/scenarios/MediaServiceWrapper.java
@@ -15,6 +15,8 @@
 
 package com.microsoft.windowsazure.services.scenarios;
 
+import static org.junit.Assert.fail;
+
 import java.io.ByteArrayInputStream;
 import java.io.IOException;
 import java.io.InputStream;
@@ -39,8 +41,6 @@ import javax.crypto.CipherInputStream;
 import javax.crypto.spec.IvParameterSpec;
 import javax.crypto.spec.SecretKeySpec;
 
-import junit.framework.Assert;
-
 import com.microsoft.windowsazure.core.utils.Base64;
 import com.microsoft.windowsazure.exception.ServiceException;
 import com.microsoft.windowsazure.services.media.MediaContract;
@@ -91,7 +91,7 @@ class MediaServiceWrapper {
             throws ServiceException {
         if (encryption == AssetOption.StorageEncrypted
                 && !EncryptionHelper.canUseStrongCrypto()) {
-            Assert.fail("JVM does not support the required encryption");
+            fail("JVM does not support the required encryption");
         }
 
         // Create asset. The SDK's top-level method is the simplest way to do
-- 
1.9.5.msysgit.1


From f0c51941962ce0d354adeedd2b3624c852a6ece2 Mon Sep 17 00:00:00 2001
From: Emanuel Vecchio <vecchioemanuel@gmail.com>
Date: Wed, 29 Jul 2015 12:12:11 -0300
Subject: [PATCH 08/21] Bug fixing in test token generation.

---
 .../TokenRestrictionTemplateSerializer.java        |  7 +++++-
 .../TokenRestrictionTemplateSerializerTests.java   | 28 +++++++++++++++++++++-
 2 files changed, 33 insertions(+), 2 deletions(-)

diff --git a/media/src/main/java/com/microsoft/windowsazure/services/media/implementation/templates/tokenrestriction/TokenRestrictionTemplateSerializer.java b/media/src/main/java/com/microsoft/windowsazure/services/media/implementation/templates/tokenrestriction/TokenRestrictionTemplateSerializer.java
index 0234156..561d415 100644
--- a/media/src/main/java/com/microsoft/windowsazure/services/media/implementation/templates/tokenrestriction/TokenRestrictionTemplateSerializer.java
+++ b/media/src/main/java/com/microsoft/windowsazure/services/media/implementation/templates/tokenrestriction/TokenRestrictionTemplateSerializer.java
@@ -143,6 +143,9 @@ public final class TokenRestrictionTemplateSerializer {
         for (TokenClaim claim : tokenTemplate.getRequiredClaims()) {
             String claimValue = claim.getClaimValue();
             if (claimValue == null && claim.getClaimType().equals(TokenClaim.getContentKeyIdentifierClaimType())) {
+                if (keyIdForContentKeyIdentifierClaim == null) {
+                    throw new IllegalArgumentException(String.format("The 'keyIdForContentKeyIdentifierClaim' parameter cannot be null when the token template contains a required '%s' claim type.", TokenClaim.getContentKeyIdentifierClaimType()));
+                }
                 claimValue = keyIdForContentKeyIdentifierClaim.toString();
             }
             claims.put(claim.getClaimType(), claimValue);    
@@ -167,9 +170,11 @@ public final class TokenRestrictionTemplateSerializer {
         for (TokenClaim claim : tokenTemplate.getRequiredClaims()) {
             String claimValue = claim.getClaimValue();
             if (claim.getClaimType().equals(TokenClaim.getContentKeyIdentifierClaimType())) {
+                if (keyIdForContentKeyIdentifierClaim == null) {
+                    throw new IllegalArgumentException(String.format("The 'keyIdForContentKeyIdentifierClaim' parameter cannot be null when the token template contains a required '%s' claim type.", TokenClaim.getContentKeyIdentifierClaimType()));
+                }
                 claimValue = keyIdForContentKeyIdentifierClaim.toString();
             }
-
             builder.append(String.format("%s=%s&", urlEncode(claim.getClaimType()), urlEncode(claimValue)));
         }
 
diff --git a/media/src/test/java/com/microsoft/windowsazure/services/media/implementation/templates/tokenrestriction/TokenRestrictionTemplateSerializerTests.java b/media/src/test/java/com/microsoft/windowsazure/services/media/implementation/templates/tokenrestriction/TokenRestrictionTemplateSerializerTests.java
index 24ecb40..77b474a 100644
--- a/media/src/test/java/com/microsoft/windowsazure/services/media/implementation/templates/tokenrestriction/TokenRestrictionTemplateSerializerTests.java
+++ b/media/src/test/java/com/microsoft/windowsazure/services/media/implementation/templates/tokenrestriction/TokenRestrictionTemplateSerializerTests.java
@@ -8,6 +8,7 @@ import static org.junit.Assert.fail;
 
 import java.net.URI;
 import java.net.URISyntaxException;
+import java.text.ParseException;
 import java.text.SimpleDateFormat;
 import java.util.Date;
 import java.util.Locale;
@@ -50,7 +51,7 @@ public class TokenRestrictionTemplateSerializerTests {
 
         assertArrayEquals(fromTemplate.getKeyValue(), fromTemplate2.getKeyValue());
     }
-
+    
     @Test
     public void KnownGoodInputForSwtOnlyScheme() throws JAXBException {
         String tokenTemplate = "<TokenRestrictionTemplate xmlns:i=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns=\"http://schemas.microsoft.com/Azure/MediaServices/KeyDelivery/TokenRestrictionTemplate/v1\"><AlternateVerificationKeys><TokenVerificationKey i:type=\"SymmetricVerificationKey\"><KeyValue>GG07fDPZ+HMD2vcoknMqYjEJMb7LSq8zUmdCYMvRCevnQK//ilbhODO/FydMrHiwZGmI6XywvOOU7SSzRPlI3Q==</KeyValue></TokenVerificationKey></AlternateVerificationKeys><Audience>http://sampleaudience/</Audience><Issuer>http://sampleissuerurl/</Issuer><PrimaryVerificationKey i:type=\"SymmetricVerificationKey\"><KeyValue>2OvxltHKwILn5PCRD8H+63sK98LBs1yF+ZdZbwzmToWYm29pLyqIMuCvMRGpLOv5DYh3NmpzWMAciu4ncW8VTg==</KeyValue></PrimaryVerificationKey><RequiredClaims><TokenClaim><ClaimType>urn:microsoft:azure:mediaservices:contentkeyidentifier</ClaimType><ClaimValue i:nil=\"true\" /></TokenClaim><TokenClaim><ClaimType>urn:myservice:claims:rental</ClaimType><ClaimValue>true</ClaimValue></TokenClaim></RequiredClaims></TokenRestrictionTemplate>";
@@ -182,4 +183,29 @@ public class TokenRestrictionTemplateSerializerTests {
         // Assert
         assertEquals(expectedToken, resultsToken);
     }
+    
+    @Test
+    public void NullContentKeyIdentifierClaimShouldThrown() throws Exception {
+        byte[] knownSymetricKey = "64bytes6RNhi8EsxcYsdYQ9zpFuNR1Ks9milykbxYWGILaK0LKzd5dCtYonsr456".getBytes();
+        SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd", Locale.ENGLISH);
+        sdf.setTimeZone(TimeZone.getTimeZone("UTC"));
+        Date knownExpireOn = sdf.parse("2016-01-01");
+        String knownAudience = "http://audience.com";
+        String knownIssuer = "http://issuer.com";
+        TokenRestrictionTemplate template = new TokenRestrictionTemplate(TokenType.SWT);
+        template.setPrimaryVerificationKey(new SymmetricVerificationKey(knownSymetricKey));
+        template.setAudience(new URI(knownAudience));
+        template.setIssuer(new URI(knownIssuer));
+        template.getRequiredClaims().add(TokenClaim.getContentKeyIdentifierClaim());
+
+        // Act
+        try {
+            TokenRestrictionTemplateSerializer.generateTestToken(template,
+                    template.getPrimaryVerificationKey(), null, knownExpireOn, null);
+            fail("Null ContentKeyIdentifier Claim Should thrown.");
+        } catch(IllegalArgumentException e) {
+            // Assert
+            assertTrue(e.getMessage().contains("keyIdForContentKeyIdentifierClaim"));
+        }
+    }
 }
-- 
1.9.5.msysgit.1


From ff0e693a4eb536b7b96105fe069886f9142ae493 Mon Sep 17 00:00:00 2001
From: Emanuel Vecchio <vecchioemanuel@gmail.com>
Date: Wed, 29 Jul 2015 17:22:45 -0300
Subject: [PATCH 09/21] Missing JWT test

---
 .../TokenRestrictionTemplateSerializerTests.java   | 27 +++++++++++++++++++++-
 1 file changed, 26 insertions(+), 1 deletion(-)

diff --git a/media/src/test/java/com/microsoft/windowsazure/services/media/implementation/templates/tokenrestriction/TokenRestrictionTemplateSerializerTests.java b/media/src/test/java/com/microsoft/windowsazure/services/media/implementation/templates/tokenrestriction/TokenRestrictionTemplateSerializerTests.java
index 77b474a..8d287b7 100644
--- a/media/src/test/java/com/microsoft/windowsazure/services/media/implementation/templates/tokenrestriction/TokenRestrictionTemplateSerializerTests.java
+++ b/media/src/test/java/com/microsoft/windowsazure/services/media/implementation/templates/tokenrestriction/TokenRestrictionTemplateSerializerTests.java
@@ -185,7 +185,7 @@ public class TokenRestrictionTemplateSerializerTests {
     }
     
     @Test
-    public void NullContentKeyIdentifierClaimShouldThrown() throws Exception {
+    public void NullContentKeyIdentifierClaimShouldThrownSWT() throws Exception {
         byte[] knownSymetricKey = "64bytes6RNhi8EsxcYsdYQ9zpFuNR1Ks9milykbxYWGILaK0LKzd5dCtYonsr456".getBytes();
         SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd", Locale.ENGLISH);
         sdf.setTimeZone(TimeZone.getTimeZone("UTC"));
@@ -208,4 +208,29 @@ public class TokenRestrictionTemplateSerializerTests {
             assertTrue(e.getMessage().contains("keyIdForContentKeyIdentifierClaim"));
         }
     }
+    
+    @Test
+    public void NullContentKeyIdentifierClaimShouldThrownJWT() throws Exception {
+        byte[] knownSymetricKey = "64bytes6RNhi8EsxcYsdYQ9zpFuNR1Ks9milykbxYWGILaK0LKzd5dCtYonsr456".getBytes();
+        SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd", Locale.ENGLISH);
+        sdf.setTimeZone(TimeZone.getTimeZone("UTC"));
+        Date knownExpireOn = sdf.parse("2016-01-01");
+        String knownAudience = "http://audience.com";
+        String knownIssuer = "http://issuer.com";
+        TokenRestrictionTemplate template = new TokenRestrictionTemplate(TokenType.JWT);
+        template.setPrimaryVerificationKey(new SymmetricVerificationKey(knownSymetricKey));
+        template.setAudience(new URI(knownAudience));
+        template.setIssuer(new URI(knownIssuer));
+        template.getRequiredClaims().add(TokenClaim.getContentKeyIdentifierClaim());
+
+        // Act
+        try {
+            TokenRestrictionTemplateSerializer.generateTestToken(template,
+                    template.getPrimaryVerificationKey(), null, knownExpireOn, null);
+            fail("Null ContentKeyIdentifier Claim Should thrown.");
+        } catch(IllegalArgumentException e) {
+            // Assert
+            assertTrue(e.getMessage().contains("keyIdForContentKeyIdentifierClaim"));
+        }
+    }
 }
-- 
1.9.5.msysgit.1


From 5d71ab8b5bea0e9febfec9b8238dd6e190ac1ea2 Mon Sep 17 00:00:00 2001
From: Emanuel Vecchio <vecchioemanuel@gmail.com>
Date: Mon, 27 Jul 2015 18:20:37 -0300
Subject: [PATCH 10/21] Added StreamingEndpoint Entity and Related Classes.

---
 .../media/implementation/ODataAtomMarshaller.java  |   2 +
 .../content/AkamaiAccessControlType.java           |  25 ++
 .../AkamaiSignatureHeaderAuthenticationKey.java    |  44 +++
 .../content/CrossSiteAccessPoliciesType.java       |  31 ++
 .../content/IPAccessControlType.java               |  24 ++
 .../media/implementation/content/IPRangeType.java  |  43 +++
 .../implementation/content/ObjectFactory.java      |  10 +
 .../StreamingEndpointAccessControlType.java        |  15 +
 .../content/StreamingEndpointCacheControlType.java |  20 ++
 .../content/StreamingEndpointType.java             | 178 ++++++++++
 .../services/media/models/StreamingEndpoint.java   | 388 +++++++++++++++++++++
 .../media/models/StreamingEndpointInfo.java        | 160 +++++++++
 12 files changed, 940 insertions(+)
 create mode 100644 media/src/main/java/com/microsoft/windowsazure/services/media/implementation/content/AkamaiAccessControlType.java
 create mode 100644 media/src/main/java/com/microsoft/windowsazure/services/media/implementation/content/AkamaiSignatureHeaderAuthenticationKey.java
 create mode 100644 media/src/main/java/com/microsoft/windowsazure/services/media/implementation/content/CrossSiteAccessPoliciesType.java
 create mode 100644 media/src/main/java/com/microsoft/windowsazure/services/media/implementation/content/IPAccessControlType.java
 create mode 100644 media/src/main/java/com/microsoft/windowsazure/services/media/implementation/content/IPRangeType.java
 create mode 100644 media/src/main/java/com/microsoft/windowsazure/services/media/implementation/content/StreamingEndpointAccessControlType.java
 create mode 100644 media/src/main/java/com/microsoft/windowsazure/services/media/implementation/content/StreamingEndpointCacheControlType.java
 create mode 100644 media/src/main/java/com/microsoft/windowsazure/services/media/implementation/content/StreamingEndpointType.java
 create mode 100644 media/src/main/java/com/microsoft/windowsazure/services/media/models/StreamingEndpoint.java
 create mode 100644 media/src/main/java/com/microsoft/windowsazure/services/media/models/StreamingEndpointInfo.java

diff --git a/media/src/main/java/com/microsoft/windowsazure/services/media/implementation/ODataAtomMarshaller.java b/media/src/main/java/com/microsoft/windowsazure/services/media/implementation/ODataAtomMarshaller.java
index 1fbfdc6..623a941 100644
--- a/media/src/main/java/com/microsoft/windowsazure/services/media/implementation/ODataAtomMarshaller.java
+++ b/media/src/main/java/com/microsoft/windowsazure/services/media/implementation/ODataAtomMarshaller.java
@@ -50,6 +50,7 @@ import com.microsoft.windowsazure.services.media.implementation.content.Notifica
 import com.microsoft.windowsazure.services.media.implementation.content.OperationType;
 import com.microsoft.windowsazure.services.media.implementation.content.OriginType;
 import com.microsoft.windowsazure.services.media.implementation.content.ProgramType;
+import com.microsoft.windowsazure.services.media.implementation.content.StreamingEndpointType;
 import com.microsoft.windowsazure.services.media.implementation.content.TaskType;
 
 /**
@@ -158,6 +159,7 @@ public class ODataAtomMarshaller {
         classes.add(OperationType.class);
         classes.add(OriginType.class);
         classes.add(ProgramType.class);
+        classes.add(StreamingEndpointType.class);
         classes.add(TaskType.class);
         return classes.toArray(new Class<?>[0]);
     }
diff --git a/media/src/main/java/com/microsoft/windowsazure/services/media/implementation/content/AkamaiAccessControlType.java b/media/src/main/java/com/microsoft/windowsazure/services/media/implementation/content/AkamaiAccessControlType.java
new file mode 100644
index 0000000..7d45079
--- /dev/null
+++ b/media/src/main/java/com/microsoft/windowsazure/services/media/implementation/content/AkamaiAccessControlType.java
@@ -0,0 +1,25 @@
+package com.microsoft.windowsazure.services.media.implementation.content;
+
+import java.util.List;
+
+import javax.xml.bind.annotation.XmlAccessType;
+import javax.xml.bind.annotation.XmlAccessorType;
+import javax.xml.bind.annotation.XmlElement;
+import javax.xml.bind.annotation.XmlElementWrapper;
+
+@XmlAccessorType(XmlAccessType.FIELD)
+public class AkamaiAccessControlType {
+    
+    @XmlElementWrapper(name = "AkamaiSignatureHeaderAuthenticationKeyList", namespace = Constants.ODATA_DATA_NS)
+    @XmlElement(name = "AkamaiSignatureHeaderAuthenticationKey", namespace = Constants.ODATA_DATA_NS)
+    private List<AkamaiSignatureHeaderAuthenticationKey> akamaiSignatureHeaderAuthenticationKeyList;
+
+    public List<AkamaiSignatureHeaderAuthenticationKey> getAkamaiSignatureHeaderAuthenticationKeyList() {
+        return akamaiSignatureHeaderAuthenticationKeyList;
+    }
+
+    public void setAkamaiSignatureHeaderAuthenticationKeyList(List<AkamaiSignatureHeaderAuthenticationKey> akamaiSignatureHeaderAuthenticationKeyList) {
+        this.akamaiSignatureHeaderAuthenticationKeyList = akamaiSignatureHeaderAuthenticationKeyList;
+    }
+
+}
diff --git a/media/src/main/java/com/microsoft/windowsazure/services/media/implementation/content/AkamaiSignatureHeaderAuthenticationKey.java b/media/src/main/java/com/microsoft/windowsazure/services/media/implementation/content/AkamaiSignatureHeaderAuthenticationKey.java
new file mode 100644
index 0000000..5677057
--- /dev/null
+++ b/media/src/main/java/com/microsoft/windowsazure/services/media/implementation/content/AkamaiSignatureHeaderAuthenticationKey.java
@@ -0,0 +1,44 @@
+package com.microsoft.windowsazure.services.media.implementation.content;
+
+import java.util.Date;
+
+import javax.xml.bind.annotation.XmlAccessType;
+import javax.xml.bind.annotation.XmlAccessorType;
+import javax.xml.bind.annotation.XmlElement;
+
+@XmlAccessorType(XmlAccessType.FIELD)
+public class AkamaiSignatureHeaderAuthenticationKey {
+
+    @XmlElement(name = "Identifier", namespace = Constants.ODATA_DATA_NS)
+    private String id;
+
+    @XmlElement(name = "Expiration", namespace = Constants.ODATA_DATA_NS)
+    private Date expiration;
+
+    @XmlElement(name = "Base64Key", namespace = Constants.ODATA_DATA_NS)
+    private String base64Key;
+
+    public String getId() {
+        return id;
+    }
+
+    public void setId(String id) {
+        this.id = id;
+    }
+
+    public Date getExpiration() {
+        return expiration;
+    }
+
+    public void setExpiration(Date expiration) {
+        this.expiration = expiration;
+    }
+
+    public String getBase64Key() {
+        return base64Key;
+    }
+
+    public void setBase64Key(String base64Key) {
+        this.base64Key = base64Key;
+    }
+}
diff --git a/media/src/main/java/com/microsoft/windowsazure/services/media/implementation/content/CrossSiteAccessPoliciesType.java b/media/src/main/java/com/microsoft/windowsazure/services/media/implementation/content/CrossSiteAccessPoliciesType.java
new file mode 100644
index 0000000..d5bcc97
--- /dev/null
+++ b/media/src/main/java/com/microsoft/windowsazure/services/media/implementation/content/CrossSiteAccessPoliciesType.java
@@ -0,0 +1,31 @@
+package com.microsoft.windowsazure.services.media.implementation.content;
+
+import javax.xml.bind.annotation.XmlAccessType;
+import javax.xml.bind.annotation.XmlAccessorType;
+import javax.xml.bind.annotation.XmlElement;
+
+@XmlAccessorType(XmlAccessType.FIELD)
+public class CrossSiteAccessPoliciesType {
+
+    @XmlElement(name = "ClientAccessPolicy", namespace = Constants.ODATA_DATA_NS)
+    private String clientAccessPolicy;
+    
+    @XmlElement(name = "CrossDomainPolicy", namespace = Constants.ODATA_DATA_NS)
+    private String crossDomainPolicy;
+
+    public String getClientAccessPolicy() {
+        return clientAccessPolicy;
+    }
+
+    public void setClientAccessPolicy(String clientAccessPolicy) {
+        this.clientAccessPolicy = clientAccessPolicy;
+    }
+
+    public String getCrossDomainPolicy() {
+        return crossDomainPolicy;
+    }
+
+    public void setCrossDomainPolicy(String crossDomainPolicy) {
+        this.crossDomainPolicy = crossDomainPolicy;
+    }
+}
diff --git a/media/src/main/java/com/microsoft/windowsazure/services/media/implementation/content/IPAccessControlType.java b/media/src/main/java/com/microsoft/windowsazure/services/media/implementation/content/IPAccessControlType.java
new file mode 100644
index 0000000..81f66a0
--- /dev/null
+++ b/media/src/main/java/com/microsoft/windowsazure/services/media/implementation/content/IPAccessControlType.java
@@ -0,0 +1,24 @@
+package com.microsoft.windowsazure.services.media.implementation.content;
+
+import java.util.List;
+
+import javax.xml.bind.annotation.XmlAccessType;
+import javax.xml.bind.annotation.XmlAccessorType;
+import javax.xml.bind.annotation.XmlElement;
+import javax.xml.bind.annotation.XmlElementWrapper;
+
+@XmlAccessorType(XmlAccessType.FIELD)
+public class IPAccessControlType {
+
+    @XmlElementWrapper(name = "Allow", namespace = Constants.ODATA_DATA_NS)
+    @XmlElement(name = "IPRange", namespace = Constants.ODATA_DATA_NS)
+    private List<IPRangeType> ipRange;
+
+    public List<IPRangeType> getIpRange() {
+        return ipRange;
+    }
+
+    public void setIpRange(List<IPRangeType> ipRange) {
+        this.ipRange = ipRange;
+    }
+}
diff --git a/media/src/main/java/com/microsoft/windowsazure/services/media/implementation/content/IPRangeType.java b/media/src/main/java/com/microsoft/windowsazure/services/media/implementation/content/IPRangeType.java
new file mode 100644
index 0000000..5650c09
--- /dev/null
+++ b/media/src/main/java/com/microsoft/windowsazure/services/media/implementation/content/IPRangeType.java
@@ -0,0 +1,43 @@
+package com.microsoft.windowsazure.services.media.implementation.content;
+
+import javax.xml.bind.annotation.XmlAccessType;
+import javax.xml.bind.annotation.XmlAccessorType;
+import javax.xml.bind.annotation.XmlElement;
+
+@XmlAccessorType(XmlAccessType.FIELD)
+public class IPRangeType {
+    
+    @XmlElement(name = "Name", namespace = Constants.ODATA_DATA_NS)
+    private String name;
+
+    @XmlElement(name = "Address", namespace = Constants.ODATA_DATA_NS)
+    private String address;
+
+    @XmlElement(name = "SubnetPrefixLength", namespace = Constants.ODATA_DATA_NS)
+    private int subnetPrefixLength;
+
+    public String getName() {
+        return name;
+    }
+
+    public void setName(String name) {
+        this.name = name;
+    }
+
+    public String getAddress() {
+        return address;
+    }
+
+    public void setAddress(String address) {
+        this.address = address;
+    }
+
+    public int getSubnetPrefixLength() {
+        return subnetPrefixLength;
+    }
+
+    public void setSubnetPrefixLength(int subnetPrefixLength) {
+        this.subnetPrefixLength = subnetPrefixLength;
+    }
+    
+}
diff --git a/media/src/main/java/com/microsoft/windowsazure/services/media/implementation/content/ObjectFactory.java b/media/src/main/java/com/microsoft/windowsazure/services/media/implementation/content/ObjectFactory.java
index 8cfe7b5..d3e9939 100644
--- a/media/src/main/java/com/microsoft/windowsazure/services/media/implementation/content/ObjectFactory.java
+++ b/media/src/main/java/com/microsoft/windowsazure/services/media/implementation/content/ObjectFactory.java
@@ -212,4 +212,14 @@ public class ObjectFactory {
     public AssetDeliveryPolicyRestType createAssetDeliveryPolicyType() {
         return new AssetDeliveryPolicyRestType();
     }
+    
+
+    /**
+     * Creates a instance of (@link @StreamingEndpointType).
+     * 
+     * @return the streaming endpoint type
+     */
+    public StreamingEndpointType createStreamingEndpointType() {
+        return new StreamingEndpointType();
+    }
 }
diff --git a/media/src/main/java/com/microsoft/windowsazure/services/media/implementation/content/StreamingEndpointAccessControlType.java b/media/src/main/java/com/microsoft/windowsazure/services/media/implementation/content/StreamingEndpointAccessControlType.java
new file mode 100644
index 0000000..e3a284a
--- /dev/null
+++ b/media/src/main/java/com/microsoft/windowsazure/services/media/implementation/content/StreamingEndpointAccessControlType.java
@@ -0,0 +1,15 @@
+package com.microsoft.windowsazure.services.media.implementation.content;
+
+import javax.xml.bind.annotation.XmlAccessType;
+import javax.xml.bind.annotation.XmlAccessorType;
+import javax.xml.bind.annotation.XmlElement;
+
+@XmlAccessorType(XmlAccessType.FIELD)
+public class StreamingEndpointAccessControlType {
+    
+    @XmlElement(name = "Akamai", namespace = Constants.ODATA_DATA_NS)
+    private AkamaiAccessControlType akamai;
+    
+    @XmlElement(name = "IP", namespace = Constants.ODATA_DATA_NS)
+    private IPAccessControlType iP;
+}
diff --git a/media/src/main/java/com/microsoft/windowsazure/services/media/implementation/content/StreamingEndpointCacheControlType.java b/media/src/main/java/com/microsoft/windowsazure/services/media/implementation/content/StreamingEndpointCacheControlType.java
new file mode 100644
index 0000000..1c84d95
--- /dev/null
+++ b/media/src/main/java/com/microsoft/windowsazure/services/media/implementation/content/StreamingEndpointCacheControlType.java
@@ -0,0 +1,20 @@
+package com.microsoft.windowsazure.services.media.implementation.content;
+
+import javax.xml.bind.annotation.XmlAccessType;
+import javax.xml.bind.annotation.XmlAccessorType;
+import javax.xml.bind.annotation.XmlElement;
+
+@XmlAccessorType(XmlAccessType.FIELD)
+public class StreamingEndpointCacheControlType {
+
+    @XmlElement(name = "MaxRange", namespace = Constants.ODATA_DATA_NS)
+    private int maxRange;
+
+    public int getMaxRange() {
+        return maxRange;
+    }
+
+    public void setMaxRange(int maxRange) {
+        this.maxRange = maxRange;
+    }
+}
diff --git a/media/src/main/java/com/microsoft/windowsazure/services/media/implementation/content/StreamingEndpointType.java b/media/src/main/java/com/microsoft/windowsazure/services/media/implementation/content/StreamingEndpointType.java
new file mode 100644
index 0000000..6697a06
--- /dev/null
+++ b/media/src/main/java/com/microsoft/windowsazure/services/media/implementation/content/StreamingEndpointType.java
@@ -0,0 +1,178 @@
+/**
+ * Copyright Microsoft Corporation
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.microsoft.windowsazure.services.media.implementation.content;
+
+import java.util.Date;
+import java.util.List;
+
+import javax.xml.bind.annotation.XmlAccessType;
+import javax.xml.bind.annotation.XmlAccessorType;
+import javax.xml.bind.annotation.XmlElement;
+import javax.xml.bind.annotation.XmlElementWrapper;
+
+
+/**
+ * This type maps the XML returned in the odata ATOM serialization for Asset
+ * entities.
+ * 
+ */
+@XmlAccessorType(XmlAccessType.FIELD)
+public class StreamingEndpointType implements MediaServiceDTO {
+
+    @XmlElement(name = "Id", namespace = Constants.ODATA_DATA_NS)
+    private String id;
+    
+    @XmlElement(name = "Name", namespace = Constants.ODATA_DATA_NS)
+    private String name;
+    
+    @XmlElement(name = "Description", namespace = Constants.ODATA_DATA_NS)
+    private String description;
+
+    @XmlElement(name = "Created", namespace = Constants.ODATA_DATA_NS)
+    private Date created;
+
+    @XmlElement(name = "LastModified", namespace = Constants.ODATA_DATA_NS)
+    private Date lastModified;
+    
+    @XmlElement(name = "State", namespace = Constants.ODATA_DATA_NS)
+    private Integer state;
+
+    @XmlElement(name = "HostName", namespace = Constants.ODATA_DATA_NS)
+    private String hostName;
+
+    @XmlElement(name = "ScaleUnits", namespace = Constants.ODATA_DATA_NS)
+    private int scaleUnits;
+    
+    @XmlElement(name = "CdnEnabled", namespace = Constants.ODATA_DATA_NS)
+    private boolean cdnEnabled;
+    
+    @XmlElementWrapper(name = "CustomHostNames", namespace = Constants.ODATA_DATA_NS)
+    @XmlElement(name = "CustomHostName", namespace = Constants.ODATA_DATA_NS)
+    private List<String> customHostName;
+    
+    @XmlElement(name = "AccessControl", namespace = Constants.ODATA_DATA_NS)
+    private StreamingEndpointAccessControlType streamingEndpointAccessControl;
+
+    @XmlElement(name = "CacheControl", namespace = Constants.ODATA_DATA_NS)
+    private StreamingEndpointCacheControlType streamingEndpointCacheControl;
+    
+    @XmlElement(name = "CrossSiteAccessPolicies", namespace = Constants.ODATA_DATA_NS)
+    private CrossSiteAccessPoliciesType crossSiteAccessPolicies;
+    
+    public String getId() {
+        return id;
+    }
+
+    public void setId(String id) {
+        this.id = id;
+    }
+
+    public String getName() {
+        return name;
+    }
+
+    public void setName(String name) {
+        this.name = name;
+    }
+
+    public String getDescription() {
+        return description;
+    }
+
+    public void setDescription(String description) {
+        this.description = description;
+    }
+
+    public Date getCreated() {
+        return created;
+    }
+
+    public void setCreated(Date created) {
+        this.created = created;
+    }
+
+    public Date getLastModified() {
+        return lastModified;
+    }
+
+    public void setLastModified(Date lastModified) {
+        this.lastModified = lastModified;
+    }
+
+    public Integer getState() {
+        return state;
+    }
+
+    public void setState(Integer state) {
+        this.state = state;
+    }
+
+    public String getHostName() {
+        return hostName;
+    }
+
+    public void setHostName(String hostName) {
+        this.hostName = hostName;
+    }
+
+    public int getScaleUnits() {
+        return scaleUnits;
+    }
+
+    public void setScaleUnits(int scaleUnits) {
+        this.scaleUnits = scaleUnits;
+    }
+
+    public List<String> getCustomHostName() {
+        return customHostName;
+    }
+
+    public void setCustomHostName(List<String> customHostName) {
+        this.customHostName = customHostName;
+    }
+
+    public boolean isCdnEnabled() {
+        return cdnEnabled;
+    }
+
+    public void setCdnEnabled(boolean cdnEnabled) {
+        this.cdnEnabled = cdnEnabled;
+    }
+
+    public StreamingEndpointAccessControlType getStreamingEndpointAccessControl() {
+        return streamingEndpointAccessControl;
+    }
+
+    public void setStreamingEndpointAccessControl(StreamingEndpointAccessControlType streamingEndpointAccessControl) {
+        this.streamingEndpointAccessControl = streamingEndpointAccessControl;
+    }
+
+    public StreamingEndpointCacheControlType getStreamingEndpointCacheControl() {
+        return streamingEndpointCacheControl;
+    }
+
+    public void setStreamingEndpointCacheControl(StreamingEndpointCacheControlType streamingEndpointCacheControl) {
+        this.streamingEndpointCacheControl = streamingEndpointCacheControl;
+    }
+
+    public CrossSiteAccessPoliciesType getCrossSiteAccessPolicies() {
+        return crossSiteAccessPolicies;
+    }
+
+    public void setCrossSiteAccessPolicies(CrossSiteAccessPoliciesType crossSiteAccessPolicies) {
+        this.crossSiteAccessPolicies = crossSiteAccessPolicies;
+    }
+}
diff --git a/media/src/main/java/com/microsoft/windowsazure/services/media/models/StreamingEndpoint.java b/media/src/main/java/com/microsoft/windowsazure/services/media/models/StreamingEndpoint.java
new file mode 100644
index 0000000..ed792e9
--- /dev/null
+++ b/media/src/main/java/com/microsoft/windowsazure/services/media/models/StreamingEndpoint.java
@@ -0,0 +1,388 @@
+/**
+ * Copyright Microsoft Corporation
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.microsoft.windowsazure.services.media.models;
+
+import java.util.List;
+
+import com.microsoft.windowsazure.services.media.entityoperations.DefaultDeleteOperation;
+import com.microsoft.windowsazure.services.media.entityoperations.DefaultGetOperation;
+import com.microsoft.windowsazure.services.media.entityoperations.DefaultListOperation;
+import com.microsoft.windowsazure.services.media.entityoperations.EntityCreateOperation;
+import com.microsoft.windowsazure.services.media.entityoperations.EntityDeleteOperation;
+import com.microsoft.windowsazure.services.media.entityoperations.EntityGetOperation;
+import com.microsoft.windowsazure.services.media.entityoperations.EntityOperationBase;
+import com.microsoft.windowsazure.services.media.entityoperations.EntityOperationSingleResultBase;
+import com.microsoft.windowsazure.services.media.entityoperations.EntityProxyData;
+import com.microsoft.windowsazure.services.media.entityoperations.EntityUpdateOperation;
+import com.microsoft.windowsazure.services.media.implementation.content.CrossSiteAccessPoliciesType;
+import com.microsoft.windowsazure.services.media.implementation.content.StreamingEndpointAccessControlType;
+import com.microsoft.windowsazure.services.media.implementation.content.StreamingEndpointCacheControlType;
+import com.microsoft.windowsazure.services.media.implementation.content.StreamingEndpointType;
+import com.sun.jersey.api.client.GenericType;
+
+/**
+ * Class for creating operations to manipulate Asset entities.
+ * 
+ */
+public final class StreamingEndpoint {
+
+    /** The Constant ENTITY_SET. */
+    private static final String ENTITY_SET = "StreamingEndpoints";
+
+    // Prevent instantiation
+    /**
+     * Instantiates a new asset.
+     */
+    private StreamingEndpoint() {
+    }
+
+    /**
+     * Creates an Asset Creator.
+     * 
+     * @return the creator
+     */
+    public static Creator create() {
+        return new Creator();
+    }
+
+    /**
+     * The Class Creator.
+     */
+    public static class Creator extends
+            EntityOperationSingleResultBase<StreamingEndpointInfo> implements
+            EntityCreateOperation<StreamingEndpointInfo> {
+
+        private String name;
+        private String description;
+        private int scaleUnits;
+        private boolean cdnEnabled;
+        private List<String> customHostNames;
+        private StreamingEndpointAccessControlType streamingEndpointAccessControl;
+        private StreamingEndpointCacheControlType streamingEndpointCacheControl;
+        private CrossSiteAccessPoliciesType crossSiteAccessPolicies;
+
+        /**
+         * Instantiates a new creator.
+         */
+        public Creator() {
+            super(ENTITY_SET, StreamingEndpointInfo.class);
+        }
+
+        /*
+         * (non-Javadoc)
+         * 
+         * @see com.microsoft.windowsazure.services.media.entityoperations.
+         * EntityCreateOperation#getRequestContents()
+         */
+        @Override
+        public Object getRequestContents() {
+            StreamingEndpointType streamingEndpointType = new StreamingEndpointType();
+            streamingEndpointType.setName(name);
+            streamingEndpointType.setDescription(description);
+            streamingEndpointType.setCdnEnabled(cdnEnabled);
+            streamingEndpointType.setCustomHostName(customHostNames);
+            streamingEndpointType.setCrossSiteAccessPolicies(crossSiteAccessPolicies);
+            streamingEndpointType.setScaleUnits(scaleUnits);
+            streamingEndpointType.setStreamingEndpointAccessControl(streamingEndpointAccessControl);
+            streamingEndpointType.setStreamingEndpointCacheControl(streamingEndpointCacheControl);
+            return streamingEndpointType;
+        }
+
+        /**
+         * Set the name of the streaming endpoint to be created.
+         * 
+         * @param name
+         *            The name
+         * @return The creator object (for call chaining)
+         */
+        public Creator setName(String name) {
+            this.name = name;
+            return this;
+        }
+
+        /**
+         * Set the description of the streaming endpoint to be created.
+         * 
+         * @param description
+         *            The description
+         * @return The creator object (for call chaining)
+         */
+        public Creator setDescription(String description) {
+            this.description = description;
+            return this;
+        }
+
+        /**
+         * Set the scale units of the streaming endpoint to be created.
+         * 
+         * @param scaleUnits
+         *            the scale units
+         * @return The creator object (for call chaining)
+         */
+        public Creator setScaleUnits(int scaleUnits) {
+            this.scaleUnits = scaleUnits;
+            return this;
+        }
+
+        /**
+         * Set if CDN is enabled on the streaming endpoint to be created.
+         * 
+         * @param cdnEnabled
+         *            true if CDN is enabled
+         * @return The creator object (for call chaining)
+         */
+        public Creator setCdnEnabled(boolean cdnEnabled) {
+            this.cdnEnabled = cdnEnabled;
+            return this;
+        }
+
+        /**
+         * Set the access control policies of the streaming endpoint to be created.
+         * 
+         * @param streamingEndpointAccessControl
+         *            the access control policies
+         * @return The creator object (for call chaining)
+         */
+        public Creator setStreamingEndpointAccessControl(StreamingEndpointAccessControlType streamingEndpointAccessControl) {
+            this.streamingEndpointAccessControl = streamingEndpointAccessControl;
+            return this;
+        }
+
+        /**
+         * Set the list of custom host names of the streaming endpoint to be created.
+         * 
+         * @param customHostNames
+         *            the list of custom host names
+         * @return The creator object (for call chaining)
+         */
+        public Creator setCustomHostNames(List<String> customHostNames) {
+            this.customHostNames = customHostNames;
+            return this;
+        }
+
+        /**
+         * Set the streaming endpoint cache control of the streaming endpoint to be created.
+         * 
+         * @param streamingEndpointCacheControl
+         *            the streaming endpoint cache control
+         * @return The creator object (for call chaining)
+         */
+        public Creator setStreamingEndpointCacheControl(StreamingEndpointCacheControlType streamingEndpointCacheControl) {
+            this.streamingEndpointCacheControl = streamingEndpointCacheControl;
+            return this;
+        }
+
+        /**
+         * Set the cross site access policies of the streaming endpoint to be created.
+         * 
+         * @param crossSiteAccessPolicies
+         *            the cross site access policies
+         * @return The creator object (for call chaining)
+         */
+        public Creator setSrossSiteAccessPolicies(CrossSiteAccessPoliciesType crossSiteAccessPolicies) {
+            this.crossSiteAccessPolicies = crossSiteAccessPolicies;
+            return this;
+        }
+        
+    }
+
+    /**
+     * Create an operation object that will get the state of the given asset.
+     * 
+     * @param assetId
+     *            id of asset to retrieve
+     * @return the get operation
+     */
+    public static EntityGetOperation<StreamingEndpointInfo> get(String streamingEndpointId) {
+        return new DefaultGetOperation<StreamingEndpointInfo>(ENTITY_SET, streamingEndpointId,
+                StreamingEndpointInfo.class);
+    }
+
+    /**
+     * Create an operation that will list all the assets.
+     * 
+     * @return The list operation
+     */
+    public static DefaultListOperation<StreamingEndpointInfo> list() {
+        return new DefaultListOperation<StreamingEndpointInfo>(ENTITY_SET,
+                new GenericType<ListResult<StreamingEndpointInfo>>() {
+                });
+    }
+
+    /**
+     * Create an operation that will update the given asset.
+     * 
+     * @param assetId
+     *            id of the asset to update
+     * @return the update operation
+     */
+    public static Updater update(String streamingEndpointId) {
+        return new Updater(streamingEndpointId);
+    }
+
+    /**
+     * The Class Updater.
+     */
+    public static class Updater extends EntityOperationBase implements
+            EntityUpdateOperation {
+
+        private String name;
+        private String description;
+        private boolean cdnEnabled;
+        private List<String> customHostNames;
+        private StreamingEndpointAccessControlType streamingEndpointAccessControl;
+        private StreamingEndpointCacheControlType streamingEndpointCacheControl;
+        private CrossSiteAccessPoliciesType crossSiteAccessPolicies;
+
+        /**
+         * Instantiates a new updater.
+         * 
+         * @param assetId
+         *            the asset id
+         */
+        protected Updater(String streamingEndpointId) {
+            super(new EntityOperationBase.EntityIdUriBuilder(ENTITY_SET,
+                    streamingEndpointId));
+        }
+
+        /*
+         * (non-Javadoc)
+         * 
+         * @see com.microsoft.windowsazure.services.media.entityoperations.
+         * EntityOperation
+         * #setProxyData(com.microsoft.windowsazure.services.media
+         * .entityoperations.EntityProxyData)
+         */
+        @Override
+        public void setProxyData(EntityProxyData proxyData) {
+            // Deliberately empty
+        }
+
+        /*
+         * (non-Javadoc)
+         * 
+         * @see com.microsoft.windowsazure.services.media.entityoperations.
+         * EntityUpdateOperation#getRequestContents()
+         */
+        @Override
+        public Object getRequestContents() {
+            StreamingEndpointType streamingEndpointType = new StreamingEndpointType();
+            streamingEndpointType.setName(name);
+            streamingEndpointType.setDescription(description);
+            streamingEndpointType.setCdnEnabled(cdnEnabled);
+            streamingEndpointType.setCustomHostName(customHostNames);
+            streamingEndpointType.setCrossSiteAccessPolicies(crossSiteAccessPolicies);
+            streamingEndpointType.setStreamingEndpointAccessControl(streamingEndpointAccessControl);
+            streamingEndpointType.setStreamingEndpointCacheControl(streamingEndpointCacheControl);
+            return streamingEndpointType;
+        }
+
+        /**
+         * Sets new name for streaming endpoint to be updated.
+         * 
+         * @param name
+         *            The new name
+         * @return Updater instance
+         */
+        public Updater setName(String name) {
+            this.name = name;
+            return this;
+        }
+
+        /**
+         * Set the new description of the streaming endpoint to be updated.
+         * 
+         * @param description
+         *            The description
+         * @return The creator object (for call chaining)
+         */
+        public Updater setDescription(String description) {
+            this.description = description;
+            return this;
+        }
+
+        /**
+         * Set the new value for CDN enabled on the streaming endpoint to be updated.
+         * 
+         * @param cdnEnabled
+         *            true if CDN is enabled
+         * @return The creator object (for call chaining)
+         */
+        public Updater setCdnEnabled(boolean cdnEnabled) {
+            this.cdnEnabled = cdnEnabled;
+            return this;
+        }
+
+        /**
+         * Set the new access control policies of the streaming endpoint to be updated.
+         * 
+         * @param streamingEndpointAccessControl
+         *            the access control policies
+         * @return The creator object (for call chaining)
+         */
+        public Updater setStreamingEndpointAccessControl(StreamingEndpointAccessControlType streamingEndpointAccessControl) {
+            this.streamingEndpointAccessControl = streamingEndpointAccessControl;
+            return this;
+        }
+
+        /**
+         * Set the new list of custom host names of the streaming endpoint to be updated.
+         * 
+         * @param customHostNames
+         *            the list of custom host names
+         * @return The creator object (for call chaining)
+         */
+        public Updater setCustomHostNames(List<String> customHostNames) {
+            this.customHostNames = customHostNames;
+            return this;
+        }
+
+        /**
+         * Set the new streaming endpoint cache control of the streaming endpoint to be updated.
+         * 
+         * @param streamingEndpointCacheControl
+         *            the streaming endpoint cache control
+         * @return The creator object (for call chaining)
+         */
+        public Updater setStreamingEndpointCacheControl(StreamingEndpointCacheControlType streamingEndpointCacheControl) {
+            this.streamingEndpointCacheControl = streamingEndpointCacheControl;
+            return this;
+        }
+
+        /**
+         * Set the new cross site access policies of the streaming endpoint to be updated.
+         * 
+         * @param crossSiteAccessPolicies
+         *            the cross site access policies
+         * @return The creator object (for call chaining)
+         */
+        public Updater setSrossSiteAccessPolicies(CrossSiteAccessPoliciesType crossSiteAccessPolicies) {
+            this.crossSiteAccessPolicies = crossSiteAccessPolicies;
+            return this;
+        }
+    }
+
+    /**
+     * Create an operation to delete the given streaming endpoint
+     * 
+     * @param assetId
+     *            id of asset to delete
+     * @return the delete operation
+     */
+    public static EntityDeleteOperation delete(String streamingEndpointId) {
+        return new DefaultDeleteOperation(ENTITY_SET, streamingEndpointId);
+    }
+}
diff --git a/media/src/main/java/com/microsoft/windowsazure/services/media/models/StreamingEndpointInfo.java b/media/src/main/java/com/microsoft/windowsazure/services/media/models/StreamingEndpointInfo.java
new file mode 100644
index 0000000..9982e54
--- /dev/null
+++ b/media/src/main/java/com/microsoft/windowsazure/services/media/models/StreamingEndpointInfo.java
@@ -0,0 +1,160 @@
+/**
+ * Copyright Microsoft Corporation
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.microsoft.windowsazure.services.media.models;
+
+import java.util.Date;
+import java.util.List;
+
+import com.microsoft.windowsazure.services.media.implementation.ODataEntity;
+import com.microsoft.windowsazure.services.media.implementation.atom.EntryType;
+import com.microsoft.windowsazure.services.media.implementation.content.CrossSiteAccessPoliciesType;
+import com.microsoft.windowsazure.services.media.implementation.content.StreamingEndpointAccessControlType;
+import com.microsoft.windowsazure.services.media.implementation.content.StreamingEndpointCacheControlType;
+import com.microsoft.windowsazure.services.media.implementation.content.StreamingEndpointType;
+
+/**
+ * Data about a Media Services Asset entity.
+ * 
+ */
+public class StreamingEndpointInfo extends ODataEntity<StreamingEndpointType> {
+
+    /**
+     * Instantiates a new streaming end point info.
+     * 
+     * @param entry
+     *            the entry
+     * @param content
+     *            the content
+     */
+    public StreamingEndpointInfo(EntryType entry, StreamingEndpointType content) {
+        super(entry, content);
+    }
+
+    /**
+     * Get the streaming end point id.
+     * 
+     * @return the id
+     */
+    public String getId() {
+        return getContent().getId();
+    }
+
+    /**
+     * Get the streaming end point name.
+     * 
+     * @return the name
+     */
+    public String getName() {
+        return this.getContent().getName();
+    }
+    
+    /**
+     * Get the streaming end point description.
+     * 
+     * @return the description
+     */
+    public String getDescription() {
+        return this.getContent().getDescription();
+    }
+
+    /**
+     * Get the creation date.
+     * 
+     * @return the date
+     */
+    public Date getCreated() {
+        return this.getContent().getCreated();
+    }
+
+    /**
+     * Get last modified date.
+     * 
+     * @return the date
+     */
+    public Date getLastModified() {
+        return getContent().getLastModified();
+    }
+    
+    /**
+     * Get the streaming end point state.
+     * 
+     * @return the state
+     */
+    public AssetState getState() {
+        return AssetState.fromCode(getContent().getState());
+    }
+
+    /**
+     * Get the host name
+     * 
+     * @return the host name
+     */
+    public String getHostName() {
+        return getContent().getHostName();
+    }
+    
+    /**
+     * Get the scale units
+     * 
+     * @return the scale units
+     */
+    public int getScaleUnits() {
+        return getContent().getScaleUnits();
+    }
+    
+    /**
+     * Get the list of custom host names.
+     * 
+     * @return the id
+     */
+    public List<String> getCustomHostNames() {
+        return getContent().getCustomHostName();
+    }
+    
+    /**
+     * True if CDN is enabled.
+     */
+    public boolean isCdnEnabled() {
+        return getContent().isCdnEnabled();
+    }
+
+    /**
+     * Get the access control policy
+     * 
+     * @return the access control policy
+     */
+    public StreamingEndpointAccessControlType getStreamingEndpointAccessControl() {
+        return getContent().getStreamingEndpointAccessControl();
+    }
+
+    /**
+     * Get the cache control policy
+     * 
+     * @return the cahe control policy
+     */
+    public StreamingEndpointCacheControlType getStreamingEndpointCacheControl() {
+        return getContent().getStreamingEndpointCacheControl();
+    }
+
+    /**
+     * Get the cross site access policy
+     * 
+     * @return the cross site access policy
+     */
+    public CrossSiteAccessPoliciesType getCrossSiteAccessPolicies() {
+        return getContent().getCrossSiteAccessPolicies();
+    }    
+}
-- 
1.9.5.msysgit.1


From 7f7fea73bd643bd0ac3b9332ebc26d74b55bb1c6 Mon Sep 17 00:00:00 2001
From: Emanuel Vecchio <vecchioemanuel@gmail.com>
Date: Tue, 28 Jul 2015 18:19:45 -0300
Subject: [PATCH 11/21] Operation Entity and StreamingEndpoint IntegrationTest

Disclaimer: This is a EOD commit, DO NOT USE IT.
---
 .../media/entityoperations/EntityContract.java     |   8 +-
 .../media/entityoperations/EntityRestProxy.java    |  63 ++++++--
 .../EntityWithOperationIdentifier.java             |  11 ++
 .../implementation/MediaExceptionProcessor.java    |  14 +-
 .../implementation/content/OperationType.java      |   2 +-
 .../content/StreamingEndpointType.java             |   6 +-
 .../services/media/models/Operation.java           |  48 ++++++
 .../services/media/models/OperationInfo.java       |  57 +++++++
 .../services/media/models/StreamingEndpoint.java   |  33 ++++
 .../media/models/StreamingEndpointInfo.java        |  36 ++++-
 .../media/models/StreamingEndpointState.java       |  79 ++++++++++
 .../services/media/IntegrationTestBase.java        |  70 ++++++++-
 .../media/StreamingEndopointIntegrationTest.java   | 170 +++++++++++++++++++++
 13 files changed, 568 insertions(+), 29 deletions(-)
 create mode 100644 media/src/main/java/com/microsoft/windowsazure/services/media/entityoperations/EntityWithOperationIdentifier.java
 create mode 100644 media/src/main/java/com/microsoft/windowsazure/services/media/models/Operation.java
 create mode 100644 media/src/main/java/com/microsoft/windowsazure/services/media/models/OperationInfo.java
 create mode 100644 media/src/main/java/com/microsoft/windowsazure/services/media/models/StreamingEndpointState.java
 create mode 100644 media/src/test/java/com/microsoft/windowsazure/services/media/StreamingEndopointIntegrationTest.java

diff --git a/media/src/main/java/com/microsoft/windowsazure/services/media/entityoperations/EntityContract.java b/media/src/main/java/com/microsoft/windowsazure/services/media/entityoperations/EntityContract.java
index 5be4a66..36ada55 100644
--- a/media/src/main/java/com/microsoft/windowsazure/services/media/entityoperations/EntityContract.java
+++ b/media/src/main/java/com/microsoft/windowsazure/services/media/entityoperations/EntityContract.java
@@ -73,27 +73,29 @@ public interface EntityContract {
      * @throws ServiceException
      *             the service exception
      */
-    void update(EntityUpdateOperation updater) throws ServiceException;
+    String update(EntityUpdateOperation updater) throws ServiceException;
 
     /**
      * Delete an entity.
      * 
      * @param deleter
      *            Object providing details of the delete
+     * @return 
      * @throws ServiceException
      *             the service exception
      */
-    void delete(EntityDeleteOperation deleter) throws ServiceException;
+    String delete(EntityDeleteOperation deleter) throws ServiceException;
 
     /**
      * Perform an action on an entity.
      * 
      * @param action
      *            Object providing details of the action
+     * @return 
      * @throws ServiceException
      *             the service exception
      */
-    void action(EntityActionOperation action) throws ServiceException;
+    String action(EntityActionOperation action) throws ServiceException;
 
     /**
      * Action.
diff --git a/media/src/main/java/com/microsoft/windowsazure/services/media/entityoperations/EntityRestProxy.java b/media/src/main/java/com/microsoft/windowsazure/services/media/entityoperations/EntityRestProxy.java
index 8e84dda..d6ff998 100644
--- a/media/src/main/java/com/microsoft/windowsazure/services/media/entityoperations/EntityRestProxy.java
+++ b/media/src/main/java/com/microsoft/windowsazure/services/media/entityoperations/EntityRestProxy.java
@@ -15,6 +15,7 @@
 
 package com.microsoft.windowsazure.services.media.entityoperations;
 
+import java.util.List;
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Executors;
 
@@ -132,9 +133,23 @@ public abstract class EntityRestProxy implements EntityContract {
     public <T> T create(EntityCreateOperation<T> creator)
             throws ServiceException {
         creator.setProxyData(createProxyData());
-        Object rawResponse = getResource(creator).post(
-                creator.getResponseClass(), creator.getRequestContents());
+        ClientResponse clientResponse = getResource(creator).post(
+                ClientResponse.class, creator.getRequestContents());
+        
+        PipelineHelpers.throwIfNotSuccess(clientResponse);
+       
+        Object rawResponse = clientResponse.getEntity(creator.getResponseClass());
         Object processedResponse = creator.processResponse(rawResponse);
+        
+        if (processedResponse instanceof EntityWithOperationIdentifier &&
+                clientResponse.getHeaders().containsKey("operation-id")) {
+            EntityWithOperationIdentifier entityWithOpId = (EntityWithOperationIdentifier) processedResponse;
+            List<String> operationIds = clientResponse.getHeaders().get("operation-id");
+            if (operationIds.size() >= 0) {
+                entityWithOpId.setOperationId(operationIds.get(0));
+            }
+        }
+        
         return (T) processedResponse;
     }
 
@@ -186,13 +201,20 @@ public abstract class EntityRestProxy implements EntityContract {
      * EntityUpdateOperation)
      */
     @Override
-    public void update(EntityUpdateOperation updater) throws ServiceException {
+    public String update(EntityUpdateOperation updater) throws ServiceException {
         updater.setProxyData(createProxyData());
-        Object rawResponse = getResource(updater).header("X-HTTP-METHOD",
+        ClientResponse clientResponse = getResource(updater).header("X-HTTP-METHOD",
                 "MERGE").post(ClientResponse.class,
                 updater.getRequestContents());
-        PipelineHelpers.throwIfNotSuccess((ClientResponse) rawResponse);
-        updater.processResponse(rawResponse);
+        PipelineHelpers.throwIfNotSuccess(clientResponse);
+        updater.processResponse(clientResponse);
+        if (clientResponse.getHeaders().containsKey("operation-id")) {
+            List<String> operationIds = clientResponse.getHeaders().get("operation-id");
+            if (operationIds.size() >= 0) {
+                return operationIds.get(0);
+            }
+        }
+        return null;
     }
 
     /*
@@ -202,11 +224,20 @@ public abstract class EntityRestProxy implements EntityContract {
      * com.microsoft.windowsazure.services.media.entityoperations.EntityContract
      * #delete(com.microsoft.windowsazure.services.media.entityoperations.
      * EntityDeleteOperation)
+     * @return operation-id if any otherwise null.
      */
     @Override
-    public void delete(EntityDeleteOperation deleter) throws ServiceException {
+    public String delete(EntityDeleteOperation deleter) throws ServiceException {
         deleter.setProxyData(createProxyData());
-        getResource(deleter.getUri()).delete();
+        ClientResponse clientResponse =  getResource(deleter.getUri()).delete(ClientResponse.class);
+        PipelineHelpers.throwIfNotSuccess(clientResponse);
+        if (clientResponse.getHeaders().containsKey("operation-id")) {
+            List<String> operationIds = clientResponse.getHeaders().get("operation-id");
+            if (operationIds.size() >= 0) {
+                return operationIds.get(0);
+            }
+        }
+        return null;
     }
 
     /*
@@ -243,10 +274,20 @@ public abstract class EntityRestProxy implements EntityContract {
      * EntityActionOperation)
      */
     @Override
-    public void action(EntityActionOperation entityActionOperation)
+    public String action(EntityActionOperation entityActionOperation)
             throws ServiceException {
-        entityActionOperation
-                .processResponse(getActionClientResponse(entityActionOperation));
+        ClientResponse clientResponse = getActionClientResponse(entityActionOperation);
+        entityActionOperation.processResponse(clientResponse);
+        
+        //PipelineHelpers.throwIfNotSuccess(clientResponse);
+        
+        if (clientResponse.getHeaders().containsKey("operation-id")) {
+            List<String> operationIds = clientResponse.getHeaders().get("operation-id");
+            if (operationIds.size() >= 0) {
+                return operationIds.get(0);
+            }
+        }
+        return null;
     }
 
     /**
diff --git a/media/src/main/java/com/microsoft/windowsazure/services/media/entityoperations/EntityWithOperationIdentifier.java b/media/src/main/java/com/microsoft/windowsazure/services/media/entityoperations/EntityWithOperationIdentifier.java
new file mode 100644
index 0000000..10069c8
--- /dev/null
+++ b/media/src/main/java/com/microsoft/windowsazure/services/media/entityoperations/EntityWithOperationIdentifier.java
@@ -0,0 +1,11 @@
+package com.microsoft.windowsazure.services.media.entityoperations;
+
+public interface EntityWithOperationIdentifier {
+    
+    String getOperationId();
+    
+    void setOperationId(String string);
+
+    boolean hasOperationIdentifier();
+
+}
diff --git a/media/src/main/java/com/microsoft/windowsazure/services/media/implementation/MediaExceptionProcessor.java b/media/src/main/java/com/microsoft/windowsazure/services/media/implementation/MediaExceptionProcessor.java
index 5348bf1..9dec814 100644
--- a/media/src/main/java/com/microsoft/windowsazure/services/media/implementation/MediaExceptionProcessor.java
+++ b/media/src/main/java/com/microsoft/windowsazure/services/media/implementation/MediaExceptionProcessor.java
@@ -193,9 +193,9 @@ public class MediaExceptionProcessor implements MediaContract {
      * EntityUpdateOperation)
      */
     @Override
-    public void update(EntityUpdateOperation updater) throws ServiceException {
+    public String update(EntityUpdateOperation updater) throws ServiceException {
         try {
-            service.update(updater);
+            return service.update(updater);
         } catch (UniformInterfaceException e) {
             throw processCatch(new ServiceException(e));
         } catch (ClientHandlerException e) {
@@ -211,11 +211,13 @@ public class MediaExceptionProcessor implements MediaContract {
      * com.microsoft.windowsazure.services.media.entityoperations.EntityContract
      * #delete(com.microsoft.windowsazure.services.media.entityoperations.
      * EntityDeleteOperation)
+     * 
+     * @return operation-id if any otherwise null.
      */
     @Override
-    public void delete(EntityDeleteOperation deleter) throws ServiceException {
+    public String delete(EntityDeleteOperation deleter) throws ServiceException {
         try {
-            service.delete(deleter);
+            return service.delete(deleter);
         } catch (UniformInterfaceException e) {
             throw processCatch(new ServiceException(e));
         } catch (ClientHandlerException e) {
@@ -232,10 +234,10 @@ public class MediaExceptionProcessor implements MediaContract {
      * EntityActionOperation)
      */
     @Override
-    public void action(EntityActionOperation entityActionOperation)
+    public String action(EntityActionOperation entityActionOperation)
             throws ServiceException {
         try {
-            service.action(entityActionOperation);
+            return service.action(entityActionOperation);
         } catch (UniformInterfaceException e) {
             throw processCatch(new ServiceException(e));
         } catch (ClientHandlerException e) {
diff --git a/media/src/main/java/com/microsoft/windowsazure/services/media/implementation/content/OperationType.java b/media/src/main/java/com/microsoft/windowsazure/services/media/implementation/content/OperationType.java
index 59638a2..3ace5b3 100644
--- a/media/src/main/java/com/microsoft/windowsazure/services/media/implementation/content/OperationType.java
+++ b/media/src/main/java/com/microsoft/windowsazure/services/media/implementation/content/OperationType.java
@@ -20,7 +20,7 @@ import javax.xml.bind.annotation.XmlAccessorType;
 import javax.xml.bind.annotation.XmlElement;
 
 /**
- * This type maps the XML returned in the odata ATOM serialization for Asset
+ * This type maps the XML returned in the odata ATOM serialization for operation
  * entities.
  * 
  */
diff --git a/media/src/main/java/com/microsoft/windowsazure/services/media/implementation/content/StreamingEndpointType.java b/media/src/main/java/com/microsoft/windowsazure/services/media/implementation/content/StreamingEndpointType.java
index 6697a06..68b706d 100644
--- a/media/src/main/java/com/microsoft/windowsazure/services/media/implementation/content/StreamingEndpointType.java
+++ b/media/src/main/java/com/microsoft/windowsazure/services/media/implementation/content/StreamingEndpointType.java
@@ -48,7 +48,7 @@ public class StreamingEndpointType implements MediaServiceDTO {
     private Date lastModified;
     
     @XmlElement(name = "State", namespace = Constants.ODATA_DATA_NS)
-    private Integer state;
+    private String state;
 
     @XmlElement(name = "HostName", namespace = Constants.ODATA_DATA_NS)
     private String hostName;
@@ -112,11 +112,11 @@ public class StreamingEndpointType implements MediaServiceDTO {
         this.lastModified = lastModified;
     }
 
-    public Integer getState() {
+    public String getState() {
         return state;
     }
 
-    public void setState(Integer state) {
+    public void setState(String state) {
         this.state = state;
     }
 
diff --git a/media/src/main/java/com/microsoft/windowsazure/services/media/models/Operation.java b/media/src/main/java/com/microsoft/windowsazure/services/media/models/Operation.java
new file mode 100644
index 0000000..2c9303e
--- /dev/null
+++ b/media/src/main/java/com/microsoft/windowsazure/services/media/models/Operation.java
@@ -0,0 +1,48 @@
+/**
+ * Copyright Microsoft Corporation
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.microsoft.windowsazure.services.media.models;
+
+import com.microsoft.windowsazure.services.media.entityoperations.DefaultGetOperation;
+import com.microsoft.windowsazure.services.media.entityoperations.EntityGetOperation;
+
+/**
+ * Class for creating operations to manipulate Asset entities.
+ * 
+ */
+public final class Operation {
+
+    /** The Constant ENTITY_SET. */
+    private static final String ENTITY_SET = "Operations";
+
+    // Prevent instantiation
+    /**
+     * Instantiates a new asset.
+     */
+    private Operation() {
+    }
+
+    /**
+     * Create an operation object that will get the state of the given asset.
+     * 
+     * @param assetId
+     *            id of asset to retrieve
+     * @return the get operation
+     */
+    public static EntityGetOperation<OperationInfo> get(String operationId) {
+        return new DefaultGetOperation<OperationInfo>(ENTITY_SET, operationId,
+                OperationInfo.class);
+    }    
+}
\ No newline at end of file
diff --git a/media/src/main/java/com/microsoft/windowsazure/services/media/models/OperationInfo.java b/media/src/main/java/com/microsoft/windowsazure/services/media/models/OperationInfo.java
new file mode 100644
index 0000000..7b826f9
--- /dev/null
+++ b/media/src/main/java/com/microsoft/windowsazure/services/media/models/OperationInfo.java
@@ -0,0 +1,57 @@
+package com.microsoft.windowsazure.services.media.models;
+
+import com.microsoft.windowsazure.services.media.implementation.ODataEntity;
+import com.microsoft.windowsazure.services.media.implementation.atom.EntryType;
+import com.microsoft.windowsazure.services.media.implementation.content.OperationType;
+
+public class OperationInfo extends ODataEntity<OperationType> {
+
+    public OperationInfo(EntryType entry, OperationType content) {
+        super(entry, content);
+    }
+
+    /**
+     * Gets the id.
+     * 
+     * @return the id
+     */
+    public String getId() {
+        return getContent().getId();
+    }
+
+    /**
+     * Gets the target entity id.
+     * 
+     * @return the target entity id
+     */
+    public String getTargetEntityId() {
+        return getContent().getTargetEntityId();
+    }
+
+    /**
+     * Gets the state.
+     * 
+     * @return the state
+     */
+    public String getState() {
+        return getContent().getState();
+    }
+
+    /**
+     * Gets the error code.
+     * 
+     * @return the error code
+     */
+    public String getErrorCode() {
+        return getContent().getErrorCode();
+    }
+
+    /**
+     * Gets the error message.
+     * 
+     * @return the error message
+     */
+    public String getErrorMessage() {
+        return getContent().getErrorMessage();
+    }
+}
diff --git a/media/src/main/java/com/microsoft/windowsazure/services/media/models/StreamingEndpoint.java b/media/src/main/java/com/microsoft/windowsazure/services/media/models/StreamingEndpoint.java
index ed792e9..8dd7be8 100644
--- a/media/src/main/java/com/microsoft/windowsazure/services/media/models/StreamingEndpoint.java
+++ b/media/src/main/java/com/microsoft/windowsazure/services/media/models/StreamingEndpoint.java
@@ -17,9 +17,12 @@ package com.microsoft.windowsazure.services.media.models;
 
 import java.util.List;
 
+import com.microsoft.windowsazure.services.media.entityoperations.DefaultActionOperation;
 import com.microsoft.windowsazure.services.media.entityoperations.DefaultDeleteOperation;
+import com.microsoft.windowsazure.services.media.entityoperations.DefaultEntityActionOperation;
 import com.microsoft.windowsazure.services.media.entityoperations.DefaultGetOperation;
 import com.microsoft.windowsazure.services.media.entityoperations.DefaultListOperation;
+import com.microsoft.windowsazure.services.media.entityoperations.EntityActionOperation;
 import com.microsoft.windowsazure.services.media.entityoperations.EntityCreateOperation;
 import com.microsoft.windowsazure.services.media.entityoperations.EntityDeleteOperation;
 import com.microsoft.windowsazure.services.media.entityoperations.EntityGetOperation;
@@ -232,6 +235,10 @@ public final class StreamingEndpoint {
     public static Updater update(String streamingEndpointId) {
         return new Updater(streamingEndpointId);
     }
+    
+    public static Updater update(StreamingEndpointInfo streamingEndpointInfo) {
+        return new Updater(streamingEndpointInfo);
+    }
 
     /**
      * The Class Updater.
@@ -257,6 +264,18 @@ public final class StreamingEndpoint {
             super(new EntityOperationBase.EntityIdUriBuilder(ENTITY_SET,
                     streamingEndpointId));
         }
+        
+        protected Updater(StreamingEndpointInfo streamingEndpointInfo) {
+            super(new EntityOperationBase.EntityIdUriBuilder(ENTITY_SET,
+                    streamingEndpointInfo.getId()));
+            this.setCdnEnabled(streamingEndpointInfo.isCdnEnabled());
+            this.setCustomHostNames(streamingEndpointInfo.getCustomHostNames());
+            this.setDescription(streamingEndpointInfo.getDescription());
+            this.setName(streamingEndpointInfo.getName());
+            this.setSrossSiteAccessPolicies(streamingEndpointInfo.getCrossSiteAccessPolicies());
+            this.setStreamingEndpointAccessControl(streamingEndpointInfo.getStreamingEndpointAccessControl());
+            this.setStreamingEndpointCacheControl(streamingEndpointInfo.getStreamingEndpointCacheControl());
+        }
 
         /*
          * (non-Javadoc)
@@ -385,4 +404,18 @@ public final class StreamingEndpoint {
     public static EntityDeleteOperation delete(String streamingEndpointId) {
         return new DefaultDeleteOperation(ENTITY_SET, streamingEndpointId);
     }
+
+    public static EntityActionOperation start(String streamingEndpointId) {
+        return new DefaultEntityActionOperation(ENTITY_SET, streamingEndpointId, "Start");
+    }
+    
+    public static EntityActionOperation stop(String streamingEndpointId) {
+        return new DefaultEntityActionOperation(ENTITY_SET, streamingEndpointId, "Stop");
+    }
+    
+    public static EntityActionOperation scale(String streamingEndpointId, int scaleUnits) {
+        DefaultEntityActionOperation operation = new DefaultEntityActionOperation(ENTITY_SET, streamingEndpointId, "Scale");
+        operation.addBodyParameter("scaleUnits", scaleUnits);
+        return operation;
+    }
 }
diff --git a/media/src/main/java/com/microsoft/windowsazure/services/media/models/StreamingEndpointInfo.java b/media/src/main/java/com/microsoft/windowsazure/services/media/models/StreamingEndpointInfo.java
index 9982e54..40d75fd 100644
--- a/media/src/main/java/com/microsoft/windowsazure/services/media/models/StreamingEndpointInfo.java
+++ b/media/src/main/java/com/microsoft/windowsazure/services/media/models/StreamingEndpointInfo.java
@@ -18,6 +18,7 @@ package com.microsoft.windowsazure.services.media.models;
 import java.util.Date;
 import java.util.List;
 
+import com.microsoft.windowsazure.services.media.entityoperations.EntityWithOperationIdentifier;
 import com.microsoft.windowsazure.services.media.implementation.ODataEntity;
 import com.microsoft.windowsazure.services.media.implementation.atom.EntryType;
 import com.microsoft.windowsazure.services.media.implementation.content.CrossSiteAccessPoliciesType;
@@ -29,7 +30,10 @@ import com.microsoft.windowsazure.services.media.implementation.content.Streamin
  * Data about a Media Services Asset entity.
  * 
  */
-public class StreamingEndpointInfo extends ODataEntity<StreamingEndpointType> {
+public class StreamingEndpointInfo extends ODataEntity<StreamingEndpointType>
+        implements EntityWithOperationIdentifier {
+    
+    private String operationIdentifier = null;
 
     /**
      * Instantiates a new streaming end point info.
@@ -69,7 +73,7 @@ public class StreamingEndpointInfo extends ODataEntity<StreamingEndpointType> {
     public String getDescription() {
         return this.getContent().getDescription();
     }
-
+    
     /**
      * Get the creation date.
      * 
@@ -93,8 +97,8 @@ public class StreamingEndpointInfo extends ODataEntity<StreamingEndpointType> {
      * 
      * @return the state
      */
-    public AssetState getState() {
-        return AssetState.fromCode(getContent().getState());
+    public StreamingEndpointState getState() {
+        return StreamingEndpointState.fromCode(getContent().getState());
     }
 
     /**
@@ -156,5 +160,29 @@ public class StreamingEndpointInfo extends ODataEntity<StreamingEndpointType> {
      */
     public CrossSiteAccessPoliciesType getCrossSiteAccessPolicies() {
         return getContent().getCrossSiteAccessPolicies();
+    }
+
+    /**
+     * Get the operation-id if any.
+     */
+    @Override
+    public String getOperationId() {        
+        return operationIdentifier;
+    }
+
+    /**
+     * Set the operation-id.
+     */
+    @Override
+    public void setOperationId(String operationIdentifier) {
+        this.operationIdentifier = operationIdentifier;        
+    }
+
+    /**
+     * @return true if the entity has an operation-id.
+     */
+    @Override
+    public boolean hasOperationIdentifier() {
+        return operationIdentifier != null;
     }    
 }
diff --git a/media/src/main/java/com/microsoft/windowsazure/services/media/models/StreamingEndpointState.java b/media/src/main/java/com/microsoft/windowsazure/services/media/models/StreamingEndpointState.java
new file mode 100644
index 0000000..cf6957a
--- /dev/null
+++ b/media/src/main/java/com/microsoft/windowsazure/services/media/models/StreamingEndpointState.java
@@ -0,0 +1,79 @@
+/*
+ * Copyright Microsoft Corporation
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.microsoft.windowsazure.services.media.models;
+
+import java.security.InvalidParameterException;
+
+/**
+ * Specifies the states of the se.
+ */
+public enum StreamingEndpointState {
+
+    Stopped("Stopped"),
+
+    Starting("Starting"),
+    
+    Running("Running"),
+    
+    Scaling("Scaling"),
+    
+    Stopping("Stopping");
+
+    /** The se state code. */
+    private String streamingEndpointStateCode;
+
+    /**
+     * Instantiates a new se state.
+     * 
+     * @param streamingEndpointStateCode
+     *            the se state code
+     */
+    private StreamingEndpointState(String streamingEndpointStateCode) {
+        this.streamingEndpointStateCode = streamingEndpointStateCode;
+    }
+
+    /**
+     * Gets the code.
+     * 
+     * @return the code
+     */
+    public String getCode() {
+        return streamingEndpointStateCode;
+    }
+
+    /**
+     * Create an StreamingEndpointState instance from the corresponding int.
+     * 
+     * @param state
+     *            state as integer
+     * @return new StreamingEndpointState instance
+     */
+    public static StreamingEndpointState fromCode(String state) {
+        if (state.equals("Stopped")) {
+            return StreamingEndpointState.Stopped;
+        } else if (state.equals("Starting")) {
+            return StreamingEndpointState.Starting;
+        } else if (state.equals("Running")) {
+            return StreamingEndpointState.Running;
+        } else if (state.equals("Scaling")) {
+           return StreamingEndpointState.Scaling;
+        } else if (state.equals("Stopping")) {
+           return StreamingEndpointState.Stopping;
+        } else {
+            throw new InvalidParameterException("state");
+        }
+    }
+}
diff --git a/media/src/test/java/com/microsoft/windowsazure/services/media/IntegrationTestBase.java b/media/src/test/java/com/microsoft/windowsazure/services/media/IntegrationTestBase.java
index ee5356c..0048063 100644
--- a/media/src/test/java/com/microsoft/windowsazure/services/media/IntegrationTestBase.java
+++ b/media/src/test/java/com/microsoft/windowsazure/services/media/IntegrationTestBase.java
@@ -36,6 +36,7 @@ import org.junit.rules.ExpectedException;
 
 import com.microsoft.windowsazure.Configuration;
 import com.microsoft.windowsazure.exception.ServiceException;
+import com.microsoft.windowsazure.services.media.entityoperations.EntityWithOperationIdentifier;
 import com.microsoft.windowsazure.services.media.models.AccessPolicy;
 import com.microsoft.windowsazure.services.media.models.AccessPolicyInfo;
 import com.microsoft.windowsazure.services.media.models.AccessPolicyPermission;
@@ -55,6 +56,11 @@ import com.microsoft.windowsazure.services.media.models.MediaProcessor;
 import com.microsoft.windowsazure.services.media.models.MediaProcessorInfo;
 import com.microsoft.windowsazure.services.media.models.NotificationEndPoint;
 import com.microsoft.windowsazure.services.media.models.NotificationEndPointInfo;
+import com.microsoft.windowsazure.services.media.models.Operation;
+import com.microsoft.windowsazure.services.media.models.OperationInfo;
+import com.microsoft.windowsazure.services.media.models.StreamingEndpoint;
+import com.microsoft.windowsazure.services.media.models.StreamingEndpointInfo;
+import com.microsoft.windowsazure.services.media.models.StreamingEndpointState;
 import com.microsoft.windowsazure.services.queue.QueueConfiguration;
 import com.microsoft.windowsazure.services.queue.QueueContract;
 import com.microsoft.windowsazure.services.queue.QueueService;
@@ -74,7 +80,7 @@ public abstract class IntegrationTestBase {
     protected static final String testChannelPrefix = "testChannel";
     protected static final String testProgramPrefix = "testProgram";
     protected static final String testNotificationEndPointPrefix = "testNotificationEndPointPrefix";
-
+    protected static final String testStreamingEndPointPrefix = "testSEPPrfx";
 
     protected static final String validButNonexistAssetId = "nb:cid:UUID:0239f11f-2d36-4e5f-aa35-44d58ccc0973";
     protected static final String validButNonexistAccessPolicyId = "nb:pid:UUID:38dcb3a0-ef64-4ad0-bbb5-67a14c6df2f7";
@@ -157,6 +163,68 @@ public abstract class IntegrationTestBase {
         removeAllTestContentKeys();
         removeAllTestQueues();
         removeAllTestNotificationEndPoints();
+        removeAllTestStreamingEndPoints();
+    }
+    
+    protected static String awaitOperation(EntityWithOperationIdentifier operation) throws ServiceException {
+        if (operation.hasOperationIdentifier()) {
+            return awaitOperation(operation.getOperationId());
+        }
+        return null;
+    }
+    
+    protected static String awaitOperation(String operationId) throws ServiceException {
+        if (operationId == null) return "Succeeded";
+        OperationInfo opinfo;
+        do {
+            opinfo = service.get(Operation.get(operationId));            
+            try {
+                Thread.sleep(2000);
+            } catch (InterruptedException e) {
+                // intentionally do nothing
+            }
+        } while(opinfo.getState().equals("InProgress"));
+        return opinfo.getState();
+    }
+    
+    private static boolean ensureStreamingPointStopped(String streamingEndpointId) throws ServiceException {
+        StreamingEndpointInfo streamingEndPoint = service.get(StreamingEndpoint.get(streamingEndpointId));
+        if (streamingEndPoint.getState().equals(StreamingEndpointState.Stopped)) {
+            return true;
+        }
+        if (streamingEndPoint.getState().equals(StreamingEndpointState.Running)) {
+            String opid = service.action(StreamingEndpoint.stop(streamingEndpointId));
+            awaitOperation(opid);
+            return ensureStreamingPointStopped(streamingEndpointId);
+        }
+        try {
+            Thread.sleep(5000);
+        } catch (InterruptedException e) {
+            // do nothing
+        }
+        return ensureStreamingPointStopped(streamingEndpointId);
+    }
+    
+    private static void removeAllTestStreamingEndPoints()
+    {
+        try {
+            ListResult<StreamingEndpointInfo> listStreamingEndpointResult = service.list(StreamingEndpoint.list());
+            for (StreamingEndpointInfo streamingEndPoint : listStreamingEndpointResult) {
+                if (streamingEndPoint.getName().startsWith(testStreamingEndPointPrefix)) {
+                    try {
+                        ensureStreamingPointStopped(streamingEndPoint.getId());
+                        String operationId = service.delete(StreamingEndpoint.delete(streamingEndPoint.getId()));
+                        if (operationId != null) {
+                            awaitOperation(operationId);
+                        }
+                    } catch (Exception e) {
+                        // e.printStackTrace();
+                    }
+                }
+            }
+        } catch (Exception e) {
+            // e.printStackTrace();
+        }
     }
     
     private static void removeAllTestNotificationEndPoints()
diff --git a/media/src/test/java/com/microsoft/windowsazure/services/media/StreamingEndopointIntegrationTest.java b/media/src/test/java/com/microsoft/windowsazure/services/media/StreamingEndopointIntegrationTest.java
new file mode 100644
index 0000000..37d9fa6
--- /dev/null
+++ b/media/src/test/java/com/microsoft/windowsazure/services/media/StreamingEndopointIntegrationTest.java
@@ -0,0 +1,170 @@
+/**
+ * Copyright Microsoft Corporation
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.microsoft.windowsazure.services.media;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertTrue;
+
+import org.junit.Ignore;
+import org.junit.Test;
+
+import com.microsoft.windowsazure.services.media.models.ListResult;
+import com.microsoft.windowsazure.services.media.models.StreamingEndpoint;
+import com.microsoft.windowsazure.services.media.models.StreamingEndpointInfo;
+import com.microsoft.windowsazure.services.media.models.StreamingEndpointState;
+
+public class StreamingEndopointIntegrationTest extends IntegrationTestBase {
+
+    @Test
+    @Ignore
+    public void streamingEndpointCreateListByNameAndDelete() throws Exception {
+        // Arrange
+        String expectedName = testStreamingEndPointPrefix + "ListByNameTest";
+        StreamingEndpointInfo streamingEndpointInfo = service.create(StreamingEndpoint.create().setName(expectedName));
+        
+        awaitOperation(streamingEndpointInfo);
+        
+        // Act
+        ListResult<StreamingEndpointInfo> listStreamingEndpointResult = service.list(StreamingEndpoint.list()
+                .set("$filter", "(Name eq '" + expectedName + "')"));
+
+        // Assert
+        assertNotNull(listStreamingEndpointResult);
+        assertEquals(1, listStreamingEndpointResult.size());
+        StreamingEndpointInfo info = listStreamingEndpointResult.get(0);
+        assertNotNull(info);
+        assertEquals(info.getName(), expectedName);
+        
+        // Cleanup
+        String deleteOpId = service.delete(StreamingEndpoint.delete(info.getId()));
+        awaitOperation(deleteOpId);
+    }
+    
+    @Test
+    @Ignore
+    public void streamingEndpointCreateStartStopDeleteTest() throws Exception {
+        // Arrange
+        String expectedName = testStreamingEndPointPrefix + "Startable";
+        StreamingEndpointInfo streamingEndpointInfo = service.create(StreamingEndpoint.create().setName(expectedName));
+        
+        awaitOperation(streamingEndpointInfo);
+        
+        // Act
+        String startingOpId = service.action(StreamingEndpoint.start(streamingEndpointInfo.getId()));
+        String state = awaitOperation(startingOpId);
+        
+        // Assert
+        assertEquals("Succeeded", state);        
+        streamingEndpointInfo = service.get(StreamingEndpoint.get(streamingEndpointInfo.getId()));
+        assertNotNull(streamingEndpointInfo);        
+        assertEquals(StreamingEndpointState.Running, streamingEndpointInfo.getState());
+        
+        // Act 2
+        startingOpId = service.action(StreamingEndpoint.stop(streamingEndpointInfo.getId())); 
+        state = awaitOperation(startingOpId);
+        
+        // Assert 2
+        assertEquals("Succeeded", state);
+        
+        // Cleanup
+        String deleteOpId = service.delete(StreamingEndpoint.delete(streamingEndpointInfo.getId()));
+        state = awaitOperation(deleteOpId);
+        // Assert Cleanup
+        assertEquals("Succeeded", state);
+    }
+    
+    
+    @Test
+    @Ignore
+    public void streamingEndpointCreateStartScaleStopDeleteTest() throws Exception {
+        // Arrange
+        int expectedScaleUnits = 2;
+        String expectedName = testStreamingEndPointPrefix + "Scalable";
+        StreamingEndpointInfo streamingEndpointInfo = service.create(StreamingEndpoint.create().setName(expectedName));
+        
+        awaitOperation(streamingEndpointInfo);
+        
+        // Act
+        String startingOpId = service.action(StreamingEndpoint.start(streamingEndpointInfo.getId()));
+        String state = awaitOperation(startingOpId);
+        
+        // Assert
+        assertEquals("Succeeded", state);        
+        streamingEndpointInfo = service.get(StreamingEndpoint.get(streamingEndpointInfo.getId()));
+        assertNotNull(streamingEndpointInfo);        
+        assertEquals(StreamingEndpointState.Running, streamingEndpointInfo.getState());
+        
+        startingOpId = service.action(StreamingEndpoint.scale(streamingEndpointInfo.getId(), expectedScaleUnits)); 
+        state = awaitOperation(startingOpId);
+        // Assert 3
+        assertEquals("Succeeded", state);
+        streamingEndpointInfo = service.get(StreamingEndpoint.get(streamingEndpointInfo.getId()));
+        assertNotNull(streamingEndpointInfo);
+        assertEquals(expectedScaleUnits, streamingEndpointInfo.getScaleUnits());
+        
+        // Act 3
+        startingOpId = service.action(StreamingEndpoint.stop(streamingEndpointInfo.getId())); 
+        state = awaitOperation(startingOpId);
+        // Assert 3
+        assertEquals("Succeeded", state);
+        
+        // Cleanup
+        String deleteOpId = service.delete(StreamingEndpoint.delete(streamingEndpointInfo.getId()));
+        state = awaitOperation(deleteOpId);
+        // Assert Cleanup
+        assertEquals("Succeeded", state);
+    }
+    
+    @Test
+    public void streamingEndpointEnableCDNTest() throws Exception {
+        // Arrange
+        int expectedScaleUnits = 1;
+        String expectedName = testStreamingEndPointPrefix + "EnableCDN";
+        
+        // Act 1
+        StreamingEndpointInfo streamingEndpointInfo = service.create(StreamingEndpoint.create().setName(expectedName));
+        String state = awaitOperation(streamingEndpointInfo);
+        // Assert 1
+        assertEquals("Succeeded", state); 
+        
+        // Act 2
+        String opId = service.action(StreamingEndpoint.scale(streamingEndpointInfo.getId(), expectedScaleUnits));
+        state = awaitOperation(opId);
+        // Assert 2
+        assertEquals("Succeeded", state); 
+        
+        // Act 3
+        opId = service.update(StreamingEndpoint.update(streamingEndpointInfo).setCdnEnabled(true));
+        state = awaitOperation(opId);
+        // Assert 3
+        assertEquals("Succeeded", state); 
+        
+        // Act 4
+        streamingEndpointInfo = service.get(StreamingEndpoint.get(streamingEndpointInfo.getId()));
+        // Assert 4
+        assertTrue(streamingEndpointInfo.isCdnEnabled());
+        
+        // Cleanup
+        String deleteOpId = service.delete(StreamingEndpoint.delete(streamingEndpointInfo.getId()));
+        state = awaitOperation(deleteOpId);
+        // Assert Cleanup
+        assertEquals("Succeeded", state);
+    }
+    
+    
+
+}
-- 
1.9.5.msysgit.1


From a38585ab5a53f453f6a272bd767fb2a789a941ca Mon Sep 17 00:00:00 2001
From: Emanuel Vecchio <vecchioemanuel@gmail.com>
Date: Wed, 29 Jul 2015 12:03:59 -0300
Subject: [PATCH 12/21] temp commit

---
 .../services/media/models/StreamingEndpoint.java          | 15 ---------------
 1 file changed, 15 deletions(-)

diff --git a/media/src/main/java/com/microsoft/windowsazure/services/media/models/StreamingEndpoint.java b/media/src/main/java/com/microsoft/windowsazure/services/media/models/StreamingEndpoint.java
index 8dd7be8..e433595 100644
--- a/media/src/main/java/com/microsoft/windowsazure/services/media/models/StreamingEndpoint.java
+++ b/media/src/main/java/com/microsoft/windowsazure/services/media/models/StreamingEndpoint.java
@@ -246,7 +246,6 @@ public final class StreamingEndpoint {
     public static class Updater extends EntityOperationBase implements
             EntityUpdateOperation {
 
-        private String name;
         private String description;
         private boolean cdnEnabled;
         private List<String> customHostNames;
@@ -271,7 +270,6 @@ public final class StreamingEndpoint {
             this.setCdnEnabled(streamingEndpointInfo.isCdnEnabled());
             this.setCustomHostNames(streamingEndpointInfo.getCustomHostNames());
             this.setDescription(streamingEndpointInfo.getDescription());
-            this.setName(streamingEndpointInfo.getName());
             this.setSrossSiteAccessPolicies(streamingEndpointInfo.getCrossSiteAccessPolicies());
             this.setStreamingEndpointAccessControl(streamingEndpointInfo.getStreamingEndpointAccessControl());
             this.setStreamingEndpointCacheControl(streamingEndpointInfo.getStreamingEndpointCacheControl());
@@ -299,7 +297,6 @@ public final class StreamingEndpoint {
         @Override
         public Object getRequestContents() {
             StreamingEndpointType streamingEndpointType = new StreamingEndpointType();
-            streamingEndpointType.setName(name);
             streamingEndpointType.setDescription(description);
             streamingEndpointType.setCdnEnabled(cdnEnabled);
             streamingEndpointType.setCustomHostName(customHostNames);
@@ -310,18 +307,6 @@ public final class StreamingEndpoint {
         }
 
         /**
-         * Sets new name for streaming endpoint to be updated.
-         * 
-         * @param name
-         *            The new name
-         * @return Updater instance
-         */
-        public Updater setName(String name) {
-            this.name = name;
-            return this;
-        }
-
-        /**
          * Set the new description of the streaming endpoint to be updated.
          * 
          * @param description
-- 
1.9.5.msysgit.1


From 7a5eeeb4e3ca7534ef63f47c52a44611e2c55eb9 Mon Sep 17 00:00:00 2001
From: Emanuel Vecchio <vecchioemanuel@gmail.com>
Date: Wed, 29 Jul 2015 14:30:09 -0300
Subject: [PATCH 13/21] Bug fixing, update a Streaming Endpoint success now.

---
 .../content/StreamingEndpointCacheControlType.java             |  2 +-
 .../media/implementation/content/StreamingEndpointType.java    |  2 +-
 .../windowsazure/services/media/models/StreamingEndpoint.java  | 10 +++++-----
 3 files changed, 7 insertions(+), 7 deletions(-)

diff --git a/media/src/main/java/com/microsoft/windowsazure/services/media/implementation/content/StreamingEndpointCacheControlType.java b/media/src/main/java/com/microsoft/windowsazure/services/media/implementation/content/StreamingEndpointCacheControlType.java
index 1c84d95..688cbd9 100644
--- a/media/src/main/java/com/microsoft/windowsazure/services/media/implementation/content/StreamingEndpointCacheControlType.java
+++ b/media/src/main/java/com/microsoft/windowsazure/services/media/implementation/content/StreamingEndpointCacheControlType.java
@@ -8,7 +8,7 @@ import javax.xml.bind.annotation.XmlElement;
 public class StreamingEndpointCacheControlType {
 
     @XmlElement(name = "MaxRange", namespace = Constants.ODATA_DATA_NS)
-    private int maxRange;
+    private Integer maxRange;
 
     public int getMaxRange() {
         return maxRange;
diff --git a/media/src/main/java/com/microsoft/windowsazure/services/media/implementation/content/StreamingEndpointType.java b/media/src/main/java/com/microsoft/windowsazure/services/media/implementation/content/StreamingEndpointType.java
index 68b706d..4f5a06f 100644
--- a/media/src/main/java/com/microsoft/windowsazure/services/media/implementation/content/StreamingEndpointType.java
+++ b/media/src/main/java/com/microsoft/windowsazure/services/media/implementation/content/StreamingEndpointType.java
@@ -54,7 +54,7 @@ public class StreamingEndpointType implements MediaServiceDTO {
     private String hostName;
 
     @XmlElement(name = "ScaleUnits", namespace = Constants.ODATA_DATA_NS)
-    private int scaleUnits;
+    private Integer scaleUnits;
     
     @XmlElement(name = "CdnEnabled", namespace = Constants.ODATA_DATA_NS)
     private boolean cdnEnabled;
diff --git a/media/src/main/java/com/microsoft/windowsazure/services/media/models/StreamingEndpoint.java b/media/src/main/java/com/microsoft/windowsazure/services/media/models/StreamingEndpoint.java
index e433595..32b435a 100644
--- a/media/src/main/java/com/microsoft/windowsazure/services/media/models/StreamingEndpoint.java
+++ b/media/src/main/java/com/microsoft/windowsazure/services/media/models/StreamingEndpoint.java
@@ -246,12 +246,12 @@ public final class StreamingEndpoint {
     public static class Updater extends EntityOperationBase implements
             EntityUpdateOperation {
 
-        private String description;
+        private String description = null;
         private boolean cdnEnabled;
-        private List<String> customHostNames;
-        private StreamingEndpointAccessControlType streamingEndpointAccessControl;
-        private StreamingEndpointCacheControlType streamingEndpointCacheControl;
-        private CrossSiteAccessPoliciesType crossSiteAccessPolicies;
+        private List<String> customHostNames  = null;
+        private StreamingEndpointAccessControlType streamingEndpointAccessControl  = null;
+        private StreamingEndpointCacheControlType streamingEndpointCacheControl = null;
+        private CrossSiteAccessPoliciesType crossSiteAccessPolicies = null;
 
         /**
          * Instantiates a new updater.
-- 
1.9.5.msysgit.1


From 8eed1af2cd17946e28651f128c869fd1afaf250b Mon Sep 17 00:00:00 2001
From: Emanuel Vecchio <vecchioemanuel@gmail.com>
Date: Wed, 29 Jul 2015 14:52:20 -0300
Subject: [PATCH 14/21] Streaming Endpoints feature complete

- Added OperationState Enum.
- Added OperationUtils class.
- Integration Test OK
---
 .../services/media/OperationUtils.java             | 57 +++++++++++++++++
 .../media/entityoperations/EntityRestProxy.java    |  4 +-
 .../services/media/models/OperationInfo.java       |  4 +-
 .../services/media/models/OperationState.java      | 71 ++++++++++++++++++++++
 .../services/media/models/StreamingEndpoint.java   |  1 -
 .../services/media/IntegrationTestBase.java        | 26 +-------
 .../media/StreamingEndopointIntegrationTest.java   | 53 ++++++++--------
 7 files changed, 162 insertions(+), 54 deletions(-)
 create mode 100644 media/src/main/java/com/microsoft/windowsazure/services/media/OperationUtils.java
 create mode 100644 media/src/main/java/com/microsoft/windowsazure/services/media/models/OperationState.java

diff --git a/media/src/main/java/com/microsoft/windowsazure/services/media/OperationUtils.java b/media/src/main/java/com/microsoft/windowsazure/services/media/OperationUtils.java
new file mode 100644
index 0000000..33f5c49
--- /dev/null
+++ b/media/src/main/java/com/microsoft/windowsazure/services/media/OperationUtils.java
@@ -0,0 +1,57 @@
+package com.microsoft.windowsazure.services.media;
+
+import com.microsoft.windowsazure.exception.ServiceException;
+import com.microsoft.windowsazure.services.media.entityoperations.EntityWithOperationIdentifier;
+import com.microsoft.windowsazure.services.media.models.Operation;
+import com.microsoft.windowsazure.services.media.models.OperationInfo;
+import com.microsoft.windowsazure.services.media.models.OperationState;
+
+public final class OperationUtils {
+    
+    private OperationUtils() {
+        // do nothing
+    }
+    
+    /**
+     * Awaits for an operation to be completed.
+     * 
+     * @param service 
+     *          the media contract
+     * @param operationId
+     *          the operation id to wait for.
+     * @return the final state of the operation. If operationId is null, returns OperationState.Succeeded.
+     * @throws ServiceException 
+     */
+    public static OperationState await(MediaContract service, String operationId) throws ServiceException {
+        if (operationId == null) {
+            return OperationState.Succeeded;
+        }
+        OperationInfo opinfo;
+        do {
+            opinfo = service.get(Operation.get(operationId));            
+            try {
+                Thread.sleep(2000);
+            } catch (InterruptedException e) {
+                // intentionally do nothing
+            }
+        } while (opinfo.getState().equals("InProgress"));
+        return opinfo.getState();
+    }
+    
+    /**
+     * Awaits for an operation to be completed.
+     * 
+     * @param service 
+     *          the media contract
+     * @param operation
+     *          the operation id to wait for.
+     * @return the final state of the operation. If the entity has not operationId, returns OperationState.Succeeded.
+     * @throws ServiceException 
+     */
+    public static OperationState await(MediaContract service, EntityWithOperationIdentifier entity) throws ServiceException {
+        if (entity.hasOperationIdentifier()) {
+            return await(service, entity.getOperationId());
+        }
+        return OperationState.Succeeded;
+    }
+}
diff --git a/media/src/main/java/com/microsoft/windowsazure/services/media/entityoperations/EntityRestProxy.java b/media/src/main/java/com/microsoft/windowsazure/services/media/entityoperations/EntityRestProxy.java
index d6ff998..453adc7 100644
--- a/media/src/main/java/com/microsoft/windowsazure/services/media/entityoperations/EntityRestProxy.java
+++ b/media/src/main/java/com/microsoft/windowsazure/services/media/entityoperations/EntityRestProxy.java
@@ -141,8 +141,8 @@ public abstract class EntityRestProxy implements EntityContract {
         Object rawResponse = clientResponse.getEntity(creator.getResponseClass());
         Object processedResponse = creator.processResponse(rawResponse);
         
-        if (processedResponse instanceof EntityWithOperationIdentifier &&
-                clientResponse.getHeaders().containsKey("operation-id")) {
+        if (processedResponse instanceof EntityWithOperationIdentifier 
+                && clientResponse.getHeaders().containsKey("operation-id")) {
             EntityWithOperationIdentifier entityWithOpId = (EntityWithOperationIdentifier) processedResponse;
             List<String> operationIds = clientResponse.getHeaders().get("operation-id");
             if (operationIds.size() >= 0) {
diff --git a/media/src/main/java/com/microsoft/windowsazure/services/media/models/OperationInfo.java b/media/src/main/java/com/microsoft/windowsazure/services/media/models/OperationInfo.java
index 7b826f9..612b824 100644
--- a/media/src/main/java/com/microsoft/windowsazure/services/media/models/OperationInfo.java
+++ b/media/src/main/java/com/microsoft/windowsazure/services/media/models/OperationInfo.java
@@ -33,8 +33,8 @@ public class OperationInfo extends ODataEntity<OperationType> {
      * 
      * @return the state
      */
-    public String getState() {
-        return getContent().getState();
+    public OperationState getState() {
+        return OperationState.fromCode(getContent().getState());
     }
 
     /**
diff --git a/media/src/main/java/com/microsoft/windowsazure/services/media/models/OperationState.java b/media/src/main/java/com/microsoft/windowsazure/services/media/models/OperationState.java
new file mode 100644
index 0000000..3c5bde6
--- /dev/null
+++ b/media/src/main/java/com/microsoft/windowsazure/services/media/models/OperationState.java
@@ -0,0 +1,71 @@
+/*
+ * Copyright Microsoft Corporation
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.microsoft.windowsazure.services.media.models;
+
+import java.security.InvalidParameterException;
+
+/**
+ * Specifies the states of the se.
+ */
+public enum OperationState {
+
+    Succeeded("Succeeded"),
+
+    Failed("Failed"),
+    
+    InProgress("InProgress");
+
+    /** The op state code. */
+    private String operationStateCode;
+
+    /**
+     * Instantiates a new op state.
+     * 
+     * @param operationStateCode
+     *            the op state code
+     */
+    private OperationState(String operationStateCode) {
+        this.operationStateCode = operationStateCode;
+    }
+
+    /**
+     * Gets the code.
+     * 
+     * @return the code
+     */
+    public String getCode() {
+        return operationStateCode;
+    }
+
+    /**
+     * Create an OperationState instance from the corresponding String.
+     * 
+     * @param state
+     *            state as integer
+     * @return new StreamingEndpointState instance
+     */
+    public static OperationState fromCode(String state) {
+        if (state.equals("Succeeded")) {
+            return OperationState.Succeeded;
+        } else if (state.equals("Failed")) {
+            return OperationState.Failed;
+        } else if (state.equals("InProgress")) {
+            return OperationState.InProgress;
+        } else {
+            throw new InvalidParameterException("state");
+        }
+    }
+}
diff --git a/media/src/main/java/com/microsoft/windowsazure/services/media/models/StreamingEndpoint.java b/media/src/main/java/com/microsoft/windowsazure/services/media/models/StreamingEndpoint.java
index 32b435a..2bf9315 100644
--- a/media/src/main/java/com/microsoft/windowsazure/services/media/models/StreamingEndpoint.java
+++ b/media/src/main/java/com/microsoft/windowsazure/services/media/models/StreamingEndpoint.java
@@ -17,7 +17,6 @@ package com.microsoft.windowsazure.services.media.models;
 
 import java.util.List;
 
-import com.microsoft.windowsazure.services.media.entityoperations.DefaultActionOperation;
 import com.microsoft.windowsazure.services.media.entityoperations.DefaultDeleteOperation;
 import com.microsoft.windowsazure.services.media.entityoperations.DefaultEntityActionOperation;
 import com.microsoft.windowsazure.services.media.entityoperations.DefaultGetOperation;
diff --git a/media/src/test/java/com/microsoft/windowsazure/services/media/IntegrationTestBase.java b/media/src/test/java/com/microsoft/windowsazure/services/media/IntegrationTestBase.java
index 0048063..44411b3 100644
--- a/media/src/test/java/com/microsoft/windowsazure/services/media/IntegrationTestBase.java
+++ b/media/src/test/java/com/microsoft/windowsazure/services/media/IntegrationTestBase.java
@@ -58,6 +58,7 @@ import com.microsoft.windowsazure.services.media.models.NotificationEndPoint;
 import com.microsoft.windowsazure.services.media.models.NotificationEndPointInfo;
 import com.microsoft.windowsazure.services.media.models.Operation;
 import com.microsoft.windowsazure.services.media.models.OperationInfo;
+import com.microsoft.windowsazure.services.media.models.OperationState;
 import com.microsoft.windowsazure.services.media.models.StreamingEndpoint;
 import com.microsoft.windowsazure.services.media.models.StreamingEndpointInfo;
 import com.microsoft.windowsazure.services.media.models.StreamingEndpointState;
@@ -166,27 +167,6 @@ public abstract class IntegrationTestBase {
         removeAllTestStreamingEndPoints();
     }
     
-    protected static String awaitOperation(EntityWithOperationIdentifier operation) throws ServiceException {
-        if (operation.hasOperationIdentifier()) {
-            return awaitOperation(operation.getOperationId());
-        }
-        return null;
-    }
-    
-    protected static String awaitOperation(String operationId) throws ServiceException {
-        if (operationId == null) return "Succeeded";
-        OperationInfo opinfo;
-        do {
-            opinfo = service.get(Operation.get(operationId));            
-            try {
-                Thread.sleep(2000);
-            } catch (InterruptedException e) {
-                // intentionally do nothing
-            }
-        } while(opinfo.getState().equals("InProgress"));
-        return opinfo.getState();
-    }
-    
     private static boolean ensureStreamingPointStopped(String streamingEndpointId) throws ServiceException {
         StreamingEndpointInfo streamingEndPoint = service.get(StreamingEndpoint.get(streamingEndpointId));
         if (streamingEndPoint.getState().equals(StreamingEndpointState.Stopped)) {
@@ -194,7 +174,7 @@ public abstract class IntegrationTestBase {
         }
         if (streamingEndPoint.getState().equals(StreamingEndpointState.Running)) {
             String opid = service.action(StreamingEndpoint.stop(streamingEndpointId));
-            awaitOperation(opid);
+            OperationUtils.await(service, opid);
             return ensureStreamingPointStopped(streamingEndpointId);
         }
         try {
@@ -215,7 +195,7 @@ public abstract class IntegrationTestBase {
                         ensureStreamingPointStopped(streamingEndPoint.getId());
                         String operationId = service.delete(StreamingEndpoint.delete(streamingEndPoint.getId()));
                         if (operationId != null) {
-                            awaitOperation(operationId);
+                            OperationUtils.await(service, operationId);
                         }
                     } catch (Exception e) {
                         // e.printStackTrace();
diff --git a/media/src/test/java/com/microsoft/windowsazure/services/media/StreamingEndopointIntegrationTest.java b/media/src/test/java/com/microsoft/windowsazure/services/media/StreamingEndopointIntegrationTest.java
index 37d9fa6..204dda2 100644
--- a/media/src/test/java/com/microsoft/windowsazure/services/media/StreamingEndopointIntegrationTest.java
+++ b/media/src/test/java/com/microsoft/windowsazure/services/media/StreamingEndopointIntegrationTest.java
@@ -23,6 +23,7 @@ import org.junit.Ignore;
 import org.junit.Test;
 
 import com.microsoft.windowsazure.services.media.models.ListResult;
+import com.microsoft.windowsazure.services.media.models.OperationState;
 import com.microsoft.windowsazure.services.media.models.StreamingEndpoint;
 import com.microsoft.windowsazure.services.media.models.StreamingEndpointInfo;
 import com.microsoft.windowsazure.services.media.models.StreamingEndpointState;
@@ -36,7 +37,7 @@ public class StreamingEndopointIntegrationTest extends IntegrationTestBase {
         String expectedName = testStreamingEndPointPrefix + "ListByNameTest";
         StreamingEndpointInfo streamingEndpointInfo = service.create(StreamingEndpoint.create().setName(expectedName));
         
-        awaitOperation(streamingEndpointInfo);
+        OperationUtils.await(service, streamingEndpointInfo);
         
         // Act
         ListResult<StreamingEndpointInfo> listStreamingEndpointResult = service.list(StreamingEndpoint.list()
@@ -51,7 +52,7 @@ public class StreamingEndopointIntegrationTest extends IntegrationTestBase {
         
         // Cleanup
         String deleteOpId = service.delete(StreamingEndpoint.delete(info.getId()));
-        awaitOperation(deleteOpId);
+        OperationUtils.await(service, deleteOpId);
     }
     
     @Test
@@ -61,30 +62,30 @@ public class StreamingEndopointIntegrationTest extends IntegrationTestBase {
         String expectedName = testStreamingEndPointPrefix + "Startable";
         StreamingEndpointInfo streamingEndpointInfo = service.create(StreamingEndpoint.create().setName(expectedName));
         
-        awaitOperation(streamingEndpointInfo);
+        OperationUtils.await(service, streamingEndpointInfo);
         
         // Act
         String startingOpId = service.action(StreamingEndpoint.start(streamingEndpointInfo.getId()));
-        String state = awaitOperation(startingOpId);
+        OperationState state = OperationUtils.await(service, startingOpId);
         
         // Assert
-        assertEquals("Succeeded", state);        
+        assertEquals(state, OperationState.Succeeded);        
         streamingEndpointInfo = service.get(StreamingEndpoint.get(streamingEndpointInfo.getId()));
         assertNotNull(streamingEndpointInfo);        
         assertEquals(StreamingEndpointState.Running, streamingEndpointInfo.getState());
         
         // Act 2
         startingOpId = service.action(StreamingEndpoint.stop(streamingEndpointInfo.getId())); 
-        state = awaitOperation(startingOpId);
+        state = OperationUtils.await(service, startingOpId);
         
         // Assert 2
-        assertEquals("Succeeded", state);
+        assertEquals(state, OperationState.Succeeded);
         
         // Cleanup
         String deleteOpId = service.delete(StreamingEndpoint.delete(streamingEndpointInfo.getId()));
-        state = awaitOperation(deleteOpId);
+        state = OperationUtils.await(service, deleteOpId);
         // Assert Cleanup
-        assertEquals("Succeeded", state);
+        assertEquals(state, OperationState.Succeeded);
     }
     
     
@@ -96,37 +97,37 @@ public class StreamingEndopointIntegrationTest extends IntegrationTestBase {
         String expectedName = testStreamingEndPointPrefix + "Scalable";
         StreamingEndpointInfo streamingEndpointInfo = service.create(StreamingEndpoint.create().setName(expectedName));
         
-        awaitOperation(streamingEndpointInfo);
+        OperationUtils.await(service, streamingEndpointInfo);
         
         // Act
         String startingOpId = service.action(StreamingEndpoint.start(streamingEndpointInfo.getId()));
-        String state = awaitOperation(startingOpId);
+        OperationState state = OperationUtils.await(service, startingOpId);
         
         // Assert
-        assertEquals("Succeeded", state);        
+        assertEquals(state, OperationState.Succeeded);        
         streamingEndpointInfo = service.get(StreamingEndpoint.get(streamingEndpointInfo.getId()));
         assertNotNull(streamingEndpointInfo);        
         assertEquals(StreamingEndpointState.Running, streamingEndpointInfo.getState());
         
         startingOpId = service.action(StreamingEndpoint.scale(streamingEndpointInfo.getId(), expectedScaleUnits)); 
-        state = awaitOperation(startingOpId);
+        state = OperationUtils.await(service, startingOpId);
         // Assert 3
-        assertEquals("Succeeded", state);
+        assertEquals(state, OperationState.Succeeded);
         streamingEndpointInfo = service.get(StreamingEndpoint.get(streamingEndpointInfo.getId()));
         assertNotNull(streamingEndpointInfo);
         assertEquals(expectedScaleUnits, streamingEndpointInfo.getScaleUnits());
         
         // Act 3
         startingOpId = service.action(StreamingEndpoint.stop(streamingEndpointInfo.getId())); 
-        state = awaitOperation(startingOpId);
+        state = OperationUtils.await(service, startingOpId);
         // Assert 3
-        assertEquals("Succeeded", state);
+        assertEquals(state, OperationState.Succeeded);
         
         // Cleanup
         String deleteOpId = service.delete(StreamingEndpoint.delete(streamingEndpointInfo.getId()));
-        state = awaitOperation(deleteOpId);
+        state = OperationUtils.await(service, deleteOpId);
         // Assert Cleanup
-        assertEquals("Succeeded", state);
+        assertEquals(state, OperationState.Succeeded);
     }
     
     @Test
@@ -137,21 +138,21 @@ public class StreamingEndopointIntegrationTest extends IntegrationTestBase {
         
         // Act 1
         StreamingEndpointInfo streamingEndpointInfo = service.create(StreamingEndpoint.create().setName(expectedName));
-        String state = awaitOperation(streamingEndpointInfo);
+        OperationState state = OperationUtils.await(service, streamingEndpointInfo);
         // Assert 1
-        assertEquals("Succeeded", state); 
+        assertEquals(state, OperationState.Succeeded); 
         
         // Act 2
         String opId = service.action(StreamingEndpoint.scale(streamingEndpointInfo.getId(), expectedScaleUnits));
-        state = awaitOperation(opId);
+        state = OperationUtils.await(service, opId);
         // Assert 2
-        assertEquals("Succeeded", state); 
+        assertEquals(state, OperationState.Succeeded); 
         
         // Act 3
         opId = service.update(StreamingEndpoint.update(streamingEndpointInfo).setCdnEnabled(true));
-        state = awaitOperation(opId);
+        state = OperationUtils.await(service, opId);
         // Assert 3
-        assertEquals("Succeeded", state); 
+        assertEquals(state, OperationState.Succeeded); 
         
         // Act 4
         streamingEndpointInfo = service.get(StreamingEndpoint.get(streamingEndpointInfo.getId()));
@@ -160,9 +161,9 @@ public class StreamingEndopointIntegrationTest extends IntegrationTestBase {
         
         // Cleanup
         String deleteOpId = service.delete(StreamingEndpoint.delete(streamingEndpointInfo.getId()));
-        state = awaitOperation(deleteOpId);
+        state = OperationUtils.await(service, deleteOpId);
         // Assert Cleanup
-        assertEquals("Succeeded", state);
+        assertEquals(state, OperationState.Succeeded);
     }
     
     
-- 
1.9.5.msysgit.1


From e402c9c5bbe2289e813deff8f2dd7bcca07af3e4 Mon Sep 17 00:00:00 2001
From: Emanuel Vecchio <vecchioemanuel@gmail.com>
Date: Wed, 29 Jul 2015 17:17:00 -0300
Subject: [PATCH 15/21] Added Encoding Reserved Units

---
 .../media/implementation/ODataAtomMarshaller.java  |   2 +
 .../content/EncodingReservedUnitRestType.java      |  97 ++++++++++++++
 .../implementation/content/ObjectFactory.java      |  21 +++-
 .../media/models/EncodingReservedUnit.java         | 140 +++++++++++++++++++++
 .../media/models/EncodingReservedUnitInfo.java     |  67 ++++++++++
 .../media/models/EncodingReservedUnitType.java     |  73 +++++++++++
 .../EncodingReservedUnitTypeIntegrationTest.java   | 102 +++++++++++++++
 .../media/StreamingEndopointIntegrationTest.java   |   3 -
 8 files changed, 497 insertions(+), 8 deletions(-)
 create mode 100644 media/src/main/java/com/microsoft/windowsazure/services/media/implementation/content/EncodingReservedUnitRestType.java
 create mode 100644 media/src/main/java/com/microsoft/windowsazure/services/media/models/EncodingReservedUnit.java
 create mode 100644 media/src/main/java/com/microsoft/windowsazure/services/media/models/EncodingReservedUnitInfo.java
 create mode 100644 media/src/main/java/com/microsoft/windowsazure/services/media/models/EncodingReservedUnitType.java
 create mode 100644 media/src/test/java/com/microsoft/windowsazure/services/media/EncodingReservedUnitTypeIntegrationTest.java

diff --git a/media/src/main/java/com/microsoft/windowsazure/services/media/implementation/ODataAtomMarshaller.java b/media/src/main/java/com/microsoft/windowsazure/services/media/implementation/ODataAtomMarshaller.java
index 623a941..07d2448 100644
--- a/media/src/main/java/com/microsoft/windowsazure/services/media/implementation/ODataAtomMarshaller.java
+++ b/media/src/main/java/com/microsoft/windowsazure/services/media/implementation/ODataAtomMarshaller.java
@@ -43,6 +43,7 @@ import com.microsoft.windowsazure.services.media.implementation.content.ContentK
 import com.microsoft.windowsazure.services.media.implementation.content.ContentKeyAuthorizationPolicyRestrictionType;
 import com.microsoft.windowsazure.services.media.implementation.content.ContentKeyAuthorizationPolicyType;
 import com.microsoft.windowsazure.services.media.implementation.content.ContentKeyRestType;
+import com.microsoft.windowsazure.services.media.implementation.content.EncodingReservedUnitRestType;
 import com.microsoft.windowsazure.services.media.implementation.content.JobNotificationSubscriptionType;
 import com.microsoft.windowsazure.services.media.implementation.content.JobType;
 import com.microsoft.windowsazure.services.media.implementation.content.LocatorRestType;
@@ -150,6 +151,7 @@ public class ODataAtomMarshaller {
         classes.add(ContentKeyAuthorizationPolicyOptionType.class);
         classes.add(ContentKeyAuthorizationPolicyRestrictionType.class);
         classes.add(ContentKeyRestType.class);
+        classes.add(EncodingReservedUnitRestType.class);
         classes.add(EntryType.class);
         classes.add(FeedType.class);
         classes.add(JobNotificationSubscriptionType.class);
diff --git a/media/src/main/java/com/microsoft/windowsazure/services/media/implementation/content/EncodingReservedUnitRestType.java b/media/src/main/java/com/microsoft/windowsazure/services/media/implementation/content/EncodingReservedUnitRestType.java
new file mode 100644
index 0000000..bab01b3
--- /dev/null
+++ b/media/src/main/java/com/microsoft/windowsazure/services/media/implementation/content/EncodingReservedUnitRestType.java
@@ -0,0 +1,97 @@
+/**
+ * Copyright Microsoft Corporation
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.microsoft.windowsazure.services.media.implementation.content;
+
+import javax.xml.bind.annotation.XmlAccessType;
+import javax.xml.bind.annotation.XmlAccessorType;
+import javax.xml.bind.annotation.XmlElement;
+
+/**
+ * Wrapper DTO for Media Services access policies.
+ * 
+ */
+@XmlAccessorType(XmlAccessType.FIELD)
+public class EncodingReservedUnitRestType implements MediaServiceDTO {
+
+    @XmlElement(name = "AccountId", namespace = Constants.ODATA_DATA_NS)
+    private String accountId;
+
+    @XmlElement(name = "ReservedUnitType", namespace = Constants.ODATA_DATA_NS)
+    private int reservedUnitType;
+
+    @XmlElement(name = "MaxReservableUnits", namespace = Constants.ODATA_DATA_NS)
+    private Integer maxReservableUnits;
+
+    @XmlElement(name = "CurrentReservedUnits", namespace = Constants.ODATA_DATA_NS)
+    private int currentReservedUnits;
+
+    /**
+     * @return the accountId
+     */
+    public String getAccountId() {
+        return accountId;
+    }
+
+    /**
+     * @param accountId the accountId to set
+     */
+    public void setAccountId(String accountId) {
+        this.accountId = accountId;
+    }
+
+    /**
+     * @return the reservedUnitType
+     */
+    public int getReservedUnitType() {
+        return reservedUnitType;
+    }
+
+    /**
+     * @param reservedUnitType the reservedUnitType to set
+     */
+    public void setReservedUnitType(int reservedUnitType) {
+        this.reservedUnitType = reservedUnitType;
+    }
+
+    /**
+     * @return the maxReservableUnits
+     */
+    public int getMaxReservableUnits() {
+        return maxReservableUnits;
+    }
+
+    /**
+     * @param maxReservableUnits the maxReservableUnits to set
+     */
+    public void setMaxReservableUnits(int maxReservableUnits) {
+        this.maxReservableUnits = maxReservableUnits;
+    }
+
+    /**
+     * @return the currentReservedUnits
+     */
+    public int getCurrentReservedUnits() {
+        return currentReservedUnits;
+    }
+
+    /**
+     * @param currentReservedUnits the currentReservedUnits to set
+     */
+    public void setCurrentReservedUnits(int currentReservedUnits) {
+        this.currentReservedUnits = currentReservedUnits;
+    }
+    
+}
diff --git a/media/src/main/java/com/microsoft/windowsazure/services/media/implementation/content/ObjectFactory.java b/media/src/main/java/com/microsoft/windowsazure/services/media/implementation/content/ObjectFactory.java
index d3e9939..371d089 100644
--- a/media/src/main/java/com/microsoft/windowsazure/services/media/implementation/content/ObjectFactory.java
+++ b/media/src/main/java/com/microsoft/windowsazure/services/media/implementation/content/ObjectFactory.java
@@ -178,7 +178,7 @@ public class ObjectFactory {
     }
     
     /**
-     * Creates a instance of (@link @ContentKeyAuthorizationPolicyOptionType).
+     * Creates a instance of (@link ContentKeyAuthorizationPolicyOptionType).
      * 
      * @return the content key authorization policy option type
      */
@@ -187,7 +187,7 @@ public class ObjectFactory {
     }
     
     /**
-     * Creates a instance of (@link @ContentKeyAuthorizationPolicyRestrictionType).
+     * Creates a instance of (@link ContentKeyAuthorizationPolicyRestrictionType).
      * 
      * @return the content key authorization policy restriction type
      */
@@ -196,7 +196,7 @@ public class ObjectFactory {
     }
     
     /**
-     * Creates a instance of (@link @ContentKeyAuthorizationPolicyType).
+     * Creates a instance of (@link ContentKeyAuthorizationPolicyType).
      * 
      * @return the content key authorization policy type
      */
@@ -205,7 +205,7 @@ public class ObjectFactory {
     }
     
     /**
-     * Creates a instance of (@link @AssetDeliveryPolicyType).
+     * Creates a instance of (@link AssetDeliveryPolicyType).
      * 
      * @return the asset delivery policy type
      */
@@ -215,11 +215,22 @@ public class ObjectFactory {
     
 
     /**
-     * Creates a instance of (@link @StreamingEndpointType).
+     * Creates a instance of (@link StreamingEndpointType).
      * 
      * @return the streaming endpoint type
      */
     public StreamingEndpointType createStreamingEndpointType() {
         return new StreamingEndpointType();
     }
+    
+    /**
+     * Creates a instance of (@link EncodingReservedUnitType).
+     * 
+     * @return the EncodingReservedUnitType type
+     */
+    public EncodingReservedUnitRestType createEncodingReservedUnitType() {
+        return new EncodingReservedUnitRestType();
+    }
+    
+    
 }
diff --git a/media/src/main/java/com/microsoft/windowsazure/services/media/models/EncodingReservedUnit.java b/media/src/main/java/com/microsoft/windowsazure/services/media/models/EncodingReservedUnit.java
new file mode 100644
index 0000000..cc71763
--- /dev/null
+++ b/media/src/main/java/com/microsoft/windowsazure/services/media/models/EncodingReservedUnit.java
@@ -0,0 +1,140 @@
+/**
+ * Copyright Microsoft Corporation
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.microsoft.windowsazure.services.media.models;
+
+import java.net.URI;
+
+import com.microsoft.windowsazure.services.media.entityoperations.DefaultGetOperation;
+import com.microsoft.windowsazure.services.media.entityoperations.EntityGetOperation;
+import com.microsoft.windowsazure.services.media.entityoperations.EntityOperationBase;
+import com.microsoft.windowsazure.services.media.entityoperations.EntityProxyData;
+import com.microsoft.windowsazure.services.media.entityoperations.EntityUpdateOperation;
+import com.microsoft.windowsazure.services.media.entityoperations.EntityOperationBase.EntityUriBuilder;
+import com.microsoft.windowsazure.services.media.implementation.content.EncodingReservedUnitRestType;
+
+/**
+ * Class for updating EncodingReservedUnitTypes
+ * 
+ */
+public final class EncodingReservedUnit {
+
+    private static final String ENTITY_SET = "EncodingReservedUnitTypes";
+
+    private EncodingReservedUnit() {
+    }
+    
+    /**
+     * Get the EncodingReservedUnitTypes
+     * 
+     * @return the operation
+     */
+    public static EntityGetOperation<EncodingReservedUnitInfo> get() {
+        return new DefaultGetOperation<EncodingReservedUnitInfo>(ENTITY_SET, 
+                EncodingReservedUnitInfo.class);
+    }   
+    
+    /**
+     * Update the EncodingReservedUnitTypes
+     * @param encodingReservedUnitInfo 
+     * 
+     * @return the update operation
+     */
+    public static Updater update(EncodingReservedUnitInfo encodingReservedUnitInfo) {
+        return new Updater(encodingReservedUnitInfo);
+    }
+
+    /**
+     * The Class Updater.
+     */
+    public static class Updater extends EntityOperationBase implements
+            EntityUpdateOperation {
+
+        private int reservedUnitType;
+        private int currentReservedUnits;
+
+        /**
+         * Instantiates a new updater.
+         * @param encodingReservedUnitInfo 
+         * 
+         * @param assetId
+         *            the asset id
+         */
+        protected Updater(final EncodingReservedUnitInfo encodingReservedUnitInfo) {
+            super(new EntityUriBuilder() {
+                @Override
+                public String getUri() {
+                    URI uri = URI.create(String.format("%s(guid'%s')", ENTITY_SET, 
+                            encodingReservedUnitInfo.getAccountId()));
+                    return uri.toString();
+                }
+            });
+            this.setReservedUnitType(encodingReservedUnitInfo.getReservedUnitType());
+            this.setCurrentReservedUnits(encodingReservedUnitInfo.getCurrentReservedUnits());
+        }
+
+        /*
+         * (non-Javadoc)
+         * 
+         * @see com.microsoft.windowsazure.services.media.entityoperations.
+         * EntityOperation
+         * #setProxyData(com.microsoft.windowsazure.services.media
+         * .entityoperations.EntityProxyData)
+         */
+        @Override
+        public void setProxyData(EntityProxyData proxyData) {
+            // Deliberately empty
+        }
+
+        /*
+         * (non-Javadoc)
+         * 
+         * @see com.microsoft.windowsazure.services.media.entityoperations.
+         * EntityUpdateOperation#getRequestContents()
+         */
+        @Override
+        public Object getRequestContents() {
+            EncodingReservedUnitRestType encodingReservedUnitType = new EncodingReservedUnitRestType();
+            encodingReservedUnitType.setAccountId(null); // never send account Id
+            encodingReservedUnitType.setCurrentReservedUnits(currentReservedUnits);
+            encodingReservedUnitType.setReservedUnitType(reservedUnitType);
+            return encodingReservedUnitType;
+        }
+
+        /**
+         * Sets new quantity of reserved units.
+         * 
+         * @param currentReservedUnits
+         *            the new quantity of reserved units.
+         * @return Updater instance
+         */
+        public Updater setCurrentReservedUnits(int currentReservedUnits) {
+            this.currentReservedUnits = currentReservedUnits;
+            return this;
+        }
+        
+        /**
+         * Sets new reserved units type.
+         * 
+         * @param encodingReservedUnitType
+         *            the new quantity of reserved units.
+         * @return Updater instance
+         */
+        public Updater setReservedUnitType(EncodingReservedUnitType encodingReservedUnitType) {
+            this.reservedUnitType = encodingReservedUnitType.getCode();
+            return this;
+        }
+    }
+}
diff --git a/media/src/main/java/com/microsoft/windowsazure/services/media/models/EncodingReservedUnitInfo.java b/media/src/main/java/com/microsoft/windowsazure/services/media/models/EncodingReservedUnitInfo.java
new file mode 100644
index 0000000..81436e6
--- /dev/null
+++ b/media/src/main/java/com/microsoft/windowsazure/services/media/models/EncodingReservedUnitInfo.java
@@ -0,0 +1,67 @@
+/**
+ * Copyright Microsoft Corporation
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.microsoft.windowsazure.services.media.models;
+
+import com.microsoft.windowsazure.services.media.implementation.ODataEntity;
+import com.microsoft.windowsazure.services.media.implementation.atom.EntryType;
+import com.microsoft.windowsazure.services.media.implementation.content.EncodingReservedUnitRestType;
+
+/**
+ * Type containing data about access policies.
+ * 
+ */
+public class EncodingReservedUnitInfo extends ODataEntity<EncodingReservedUnitRestType> {
+
+    /**
+     * Creates a new {@link EncodingReservedUnitInfo} wrapping the given ATOM entry and
+     * content objects.
+     * 
+     * @param entry
+     *            Entry containing this AccessPolicy data
+     * @param content
+     *            Content with the AccessPolicy data
+     */
+    public EncodingReservedUnitInfo(EntryType entry, EncodingReservedUnitRestType content) {
+        super(entry, content);
+    }
+    /**
+     * @return the accountId
+     */
+    public String getAccountId() {
+        return getContent().getAccountId();
+    }
+
+    /**
+     * @return the reservedUnitType
+     */
+    public EncodingReservedUnitType getReservedUnitType() {
+        return EncodingReservedUnitType.fromCode(getContent().getReservedUnitType());
+    }
+
+    /**
+     * @return the maxReservableUnits
+     */
+    public int getMaxReservableUnits() {
+        return getContent().getMaxReservableUnits();
+    }
+
+    /**
+     * @return the currentReservedUnits
+     */
+    public int getCurrentReservedUnits() {
+        return getContent().getCurrentReservedUnits();
+    }    
+}
diff --git a/media/src/main/java/com/microsoft/windowsazure/services/media/models/EncodingReservedUnitType.java b/media/src/main/java/com/microsoft/windowsazure/services/media/models/EncodingReservedUnitType.java
new file mode 100644
index 0000000..6e7b241
--- /dev/null
+++ b/media/src/main/java/com/microsoft/windowsazure/services/media/models/EncodingReservedUnitType.java
@@ -0,0 +1,73 @@
+/*
+ * Copyright Microsoft Corporation
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.microsoft.windowsazure.services.media.models;
+
+import java.security.InvalidParameterException;
+
+/**
+ * Specifies the types of Encoding Reserved Units.
+ */
+public enum EncodingReservedUnitType {
+
+    /** The Basic. */
+    Basic(0),
+    /** The Standard. */
+    Standard (1),
+    /** The Premium . */
+    Premium (2);
+
+    /** The Encoding Reserved Unit type code. */
+    private int encodingReservedUnitType;
+
+    /**
+     * Instantiates a new asset state.
+     * 
+     * @param encodingReservedUnitType
+     *            the EncodingReservedUnitType code
+     */
+    private EncodingReservedUnitType(int encodingReservedUnitType) {
+        this.encodingReservedUnitType = encodingReservedUnitType;
+    }
+
+    /**
+     * Gets the code.
+     * 
+     * @return the code
+     */
+    public int getCode() {
+        return encodingReservedUnitType;
+    }
+
+    /**
+     * Create an EncodingReservedUnitType instance from the corresponding int.
+     * 
+     * @param type
+     *            type as integer
+     * @return new EncodingReservedUnitType instance
+     */
+    public static EncodingReservedUnitType fromCode(int state) {
+        switch (state) {
+        case 0:
+            return EncodingReservedUnitType.Basic;
+        case 1:
+            return EncodingReservedUnitType.Standard;
+        case 2:
+            return EncodingReservedUnitType.Premium;
+        default:
+            throw new InvalidParameterException("state");
+        }
+    }
+}
diff --git a/media/src/test/java/com/microsoft/windowsazure/services/media/EncodingReservedUnitTypeIntegrationTest.java b/media/src/test/java/com/microsoft/windowsazure/services/media/EncodingReservedUnitTypeIntegrationTest.java
new file mode 100644
index 0000000..9229929
--- /dev/null
+++ b/media/src/test/java/com/microsoft/windowsazure/services/media/EncodingReservedUnitTypeIntegrationTest.java
@@ -0,0 +1,102 @@
+/**
+ * Copyright Microsoft Corporation
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.microsoft.windowsazure.services.media;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertTrue;
+
+import org.junit.After;
+import org.junit.AfterClass;
+import org.junit.Before;
+import org.junit.BeforeClass;
+import org.junit.Test;
+
+import com.microsoft.windowsazure.exception.ServiceException;
+import com.microsoft.windowsazure.services.media.models.EncodingReservedUnit;
+import com.microsoft.windowsazure.services.media.models.EncodingReservedUnitInfo;
+import com.microsoft.windowsazure.services.media.models.EncodingReservedUnitType;
+import com.microsoft.windowsazure.services.media.models.OperationState;
+
+public class EncodingReservedUnitTypeIntegrationTest extends IntegrationTestBase {
+    private static EncodingReservedUnitInfo encodingReservedUnitInfo;
+    
+    @BeforeClass
+    public static void beforeTesting() throws ServiceException {
+        encodingReservedUnitInfo = service.get(EncodingReservedUnit.get());
+    }
+    
+    @AfterClass
+    public static void afterTesting() throws ServiceException {
+        String opId = service.update(EncodingReservedUnit.update(encodingReservedUnitInfo)
+                .setCurrentReservedUnits(encodingReservedUnitInfo.getCurrentReservedUnits())
+                .setReservedUnitType(encodingReservedUnitInfo.getReservedUnitType()));
+        
+        OperationUtils.await(service, opId);
+    }
+
+    @Test
+    public void getEncodingReservedUnitType() throws Exception {
+        // Arrange
+        // Act
+        EncodingReservedUnitInfo encodingReservedUnitInfo = service.get(EncodingReservedUnit.get());
+        
+        // Assert
+        assertNotNull(encodingReservedUnitInfo);        
+    }
+    
+    @Test
+    public void updateCurrentEncodingReservedUnits() throws Exception {
+        // Arrange
+        int expectedReservedUnits = 2;
+        EncodingReservedUnitInfo encodingReservedUnitInfo = service.get(EncodingReservedUnit.get());
+        assertNotNull(encodingReservedUnitInfo);
+        
+        // Act
+        String opId = service.update(EncodingReservedUnit.update(encodingReservedUnitInfo)
+                .setCurrentReservedUnits(expectedReservedUnits));
+        
+        OperationState state = OperationUtils.await(service, opId);
+        
+        encodingReservedUnitInfo = service.get(EncodingReservedUnit.get());
+        
+        // Assert
+        assertEquals(OperationState.Succeeded, state);
+        assertNotNull(encodingReservedUnitInfo);
+        assertEquals(encodingReservedUnitInfo.getCurrentReservedUnits(), expectedReservedUnits);
+    }
+    
+    @Test
+    public void updateTypeofEncodingReservedUnits() throws Exception {
+        // Arrange
+        EncodingReservedUnitType expectedReservedUnitType = EncodingReservedUnitType.Standard;
+        EncodingReservedUnitInfo encodingReservedUnitInfo = service.get(EncodingReservedUnit.get());
+        assertNotNull(encodingReservedUnitInfo);
+        
+        // Act
+        String opId = service.update(EncodingReservedUnit.update(encodingReservedUnitInfo)
+                .setReservedUnitType(expectedReservedUnitType));
+        
+        OperationState state = OperationUtils.await(service, opId);
+        
+        encodingReservedUnitInfo = service.get(EncodingReservedUnit.get());
+        
+        // Assert
+        assertEquals(OperationState.Succeeded, state);
+        assertNotNull(encodingReservedUnitInfo);
+        assertEquals(encodingReservedUnitInfo.getReservedUnitType(), expectedReservedUnitType);
+    }
+}
diff --git a/media/src/test/java/com/microsoft/windowsazure/services/media/StreamingEndopointIntegrationTest.java b/media/src/test/java/com/microsoft/windowsazure/services/media/StreamingEndopointIntegrationTest.java
index 204dda2..bdbb3b4 100644
--- a/media/src/test/java/com/microsoft/windowsazure/services/media/StreamingEndopointIntegrationTest.java
+++ b/media/src/test/java/com/microsoft/windowsazure/services/media/StreamingEndopointIntegrationTest.java
@@ -31,7 +31,6 @@ import com.microsoft.windowsazure.services.media.models.StreamingEndpointState;
 public class StreamingEndopointIntegrationTest extends IntegrationTestBase {
 
     @Test
-    @Ignore
     public void streamingEndpointCreateListByNameAndDelete() throws Exception {
         // Arrange
         String expectedName = testStreamingEndPointPrefix + "ListByNameTest";
@@ -56,7 +55,6 @@ public class StreamingEndopointIntegrationTest extends IntegrationTestBase {
     }
     
     @Test
-    @Ignore
     public void streamingEndpointCreateStartStopDeleteTest() throws Exception {
         // Arrange
         String expectedName = testStreamingEndPointPrefix + "Startable";
@@ -90,7 +88,6 @@ public class StreamingEndopointIntegrationTest extends IntegrationTestBase {
     
     
     @Test
-    @Ignore
     public void streamingEndpointCreateStartScaleStopDeleteTest() throws Exception {
         // Arrange
         int expectedScaleUnits = 2;
-- 
1.9.5.msysgit.1


From 3ce2e55df7144a3df7049411b746c4f9ae612c11 Mon Sep 17 00:00:00 2001
From: Emanuel Vecchio <vecchioemanuel@gmail.com>
Date: Wed, 29 Jul 2015 18:14:54 -0300
Subject: [PATCH 16/21] Fixed await with OperationState

---
 .../java/com/microsoft/windowsazure/services/media/OperationUtils.java  | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/media/src/main/java/com/microsoft/windowsazure/services/media/OperationUtils.java b/media/src/main/java/com/microsoft/windowsazure/services/media/OperationUtils.java
index 33f5c49..0eb7779 100644
--- a/media/src/main/java/com/microsoft/windowsazure/services/media/OperationUtils.java
+++ b/media/src/main/java/com/microsoft/windowsazure/services/media/OperationUtils.java
@@ -34,7 +34,7 @@ public final class OperationUtils {
             } catch (InterruptedException e) {
                 // intentionally do nothing
             }
-        } while (opinfo.getState().equals("InProgress"));
+        } while (opinfo.getState().equals(OperationState.InProgress));
         return opinfo.getState();
     }
     
-- 
1.9.5.msysgit.1


From d080476ef60f1464dedce84ab884a3a8282b694d Mon Sep 17 00:00:00 2001
From: Emanuel Vecchio <vecchioemanuel@gmail.com>
Date: Thu, 30 Jul 2015 10:47:32 -0300
Subject: [PATCH 17/21] Added StorageAccounts Feature

---
 .../media/implementation/ODataAtomMarshaller.java  |  2 +
 .../implementation/content/ObjectFactory.java      |  9 +++
 .../implementation/content/StorageAccountType.java | 81 ++++++++++++++++++++++
 .../services/media/models/StorageAccountInfo.java  | 66 ++++++++++++++++++
 .../services/media/models/StorageAccounts.java     | 48 +++++++++++++
 .../services/media/StorageAccountsTest.java        | 41 +++++++++++
 6 files changed, 247 insertions(+)
 create mode 100644 media/src/main/java/com/microsoft/windowsazure/services/media/implementation/content/StorageAccountType.java
 create mode 100644 media/src/main/java/com/microsoft/windowsazure/services/media/models/StorageAccountInfo.java
 create mode 100644 media/src/main/java/com/microsoft/windowsazure/services/media/models/StorageAccounts.java
 create mode 100644 media/src/test/java/com/microsoft/windowsazure/services/media/StorageAccountsTest.java

diff --git a/media/src/main/java/com/microsoft/windowsazure/services/media/implementation/ODataAtomMarshaller.java b/media/src/main/java/com/microsoft/windowsazure/services/media/implementation/ODataAtomMarshaller.java
index 07d2448..cef1ed2 100644
--- a/media/src/main/java/com/microsoft/windowsazure/services/media/implementation/ODataAtomMarshaller.java
+++ b/media/src/main/java/com/microsoft/windowsazure/services/media/implementation/ODataAtomMarshaller.java
@@ -51,6 +51,7 @@ import com.microsoft.windowsazure.services.media.implementation.content.Notifica
 import com.microsoft.windowsazure.services.media.implementation.content.OperationType;
 import com.microsoft.windowsazure.services.media.implementation.content.OriginType;
 import com.microsoft.windowsazure.services.media.implementation.content.ProgramType;
+import com.microsoft.windowsazure.services.media.implementation.content.StorageAccountType;
 import com.microsoft.windowsazure.services.media.implementation.content.StreamingEndpointType;
 import com.microsoft.windowsazure.services.media.implementation.content.TaskType;
 
@@ -161,6 +162,7 @@ public class ODataAtomMarshaller {
         classes.add(OperationType.class);
         classes.add(OriginType.class);
         classes.add(ProgramType.class);
+        classes.add(StorageAccountType.class);
         classes.add(StreamingEndpointType.class);
         classes.add(TaskType.class);
         return classes.toArray(new Class<?>[0]);
diff --git a/media/src/main/java/com/microsoft/windowsazure/services/media/implementation/content/ObjectFactory.java b/media/src/main/java/com/microsoft/windowsazure/services/media/implementation/content/ObjectFactory.java
index 371d089..07e515d 100644
--- a/media/src/main/java/com/microsoft/windowsazure/services/media/implementation/content/ObjectFactory.java
+++ b/media/src/main/java/com/microsoft/windowsazure/services/media/implementation/content/ObjectFactory.java
@@ -232,5 +232,14 @@ public class ObjectFactory {
         return new EncodingReservedUnitRestType();
     }
     
+    /**
+     * Creates a instance of (@link EncodingReservedUnitType).
+     * 
+     * @return the EncodingReservedUnitType type
+     */
+    public StorageAccountType createStorageAccountType() {
+        return new StorageAccountType();
+    }
+    
     
 }
diff --git a/media/src/main/java/com/microsoft/windowsazure/services/media/implementation/content/StorageAccountType.java b/media/src/main/java/com/microsoft/windowsazure/services/media/implementation/content/StorageAccountType.java
new file mode 100644
index 0000000..34e5426
--- /dev/null
+++ b/media/src/main/java/com/microsoft/windowsazure/services/media/implementation/content/StorageAccountType.java
@@ -0,0 +1,81 @@
+/**
+ * Copyright Microsoft Corporation
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.microsoft.windowsazure.services.media.implementation.content;
+
+import javax.xml.bind.annotation.XmlAccessType;
+import javax.xml.bind.annotation.XmlAccessorType;
+import javax.xml.bind.annotation.XmlElement;
+
+/**
+ * This type maps the XML returned in the odata ATOM serialization for StorageAccountType
+ * entities.
+ * 
+ */
+@XmlAccessorType(XmlAccessType.FIELD)
+public class StorageAccountType implements MediaServiceDTO {
+
+    @XmlElement(name = "Name", namespace = Constants.ODATA_DATA_NS)
+    private String name;
+
+    @XmlElement(name = "IsDefault", namespace = Constants.ODATA_DATA_NS)
+    private boolean isdefault;
+
+    @XmlElement(name = "BytesUsed", namespace = Constants.ODATA_DATA_NS)
+    private long bytesUsed;
+
+    /**
+     * @return the name
+     */
+    public String getName() {
+        return name;
+    }
+
+    /**
+     * @param name the name to set
+     */
+    public void setName(String name) {
+        this.name = name;
+    }
+
+    /**
+     * @return the isdefault
+     */
+    public boolean isDefault() {
+        return isdefault;
+    }
+
+    /**
+     * @param isdefault the isdefault to set
+     */
+    public void setAsDefault(boolean isdefault) {
+        this.isdefault = isdefault;
+    }
+
+    /**
+     * @return the bytesUsed
+     */
+    public long getBytesUsed() {
+        return bytesUsed;
+    }
+
+    /**
+     * @param bytesUsed the bytesUsed to set
+     */
+    public void setBytesUsed(long bytesUsed) {
+        this.bytesUsed = bytesUsed;
+    }
+
+}
diff --git a/media/src/main/java/com/microsoft/windowsazure/services/media/models/StorageAccountInfo.java b/media/src/main/java/com/microsoft/windowsazure/services/media/models/StorageAccountInfo.java
new file mode 100644
index 0000000..74f7550
--- /dev/null
+++ b/media/src/main/java/com/microsoft/windowsazure/services/media/models/StorageAccountInfo.java
@@ -0,0 +1,66 @@
+/**
+ * Copyright Microsoft Corporation
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.microsoft.windowsazure.services.media.models;
+
+import com.microsoft.windowsazure.services.media.implementation.ODataEntity;
+import com.microsoft.windowsazure.services.media.implementation.atom.EntryType;
+import com.microsoft.windowsazure.services.media.implementation.content.StorageAccountType;
+
+/**
+ * Data about a Media Services Asset entity.
+ * 
+ */
+public class StorageAccountInfo extends ODataEntity<StorageAccountType> {
+
+    /**
+     * Instantiates a new asset info.
+     * 
+     * @param entry
+     *            the entry
+     * @param content
+     *            the content
+     */
+    public StorageAccountInfo(EntryType entry, StorageAccountType content) {
+        super(entry, content);
+    }
+
+    /**
+     * Get the asset name.
+     * 
+     * @return the name
+     */
+    public String getName() {
+        return this.getContent().getName();
+    }
+
+    /**
+     * Get the bytes used
+     * 
+     * @return the bytes used
+     */
+    public long getBytesUsed() {
+        return getContent().getBytesUsed();
+    }
+
+    /**
+     * Gets true if this storage account is the default one.
+     * 
+     * @return true if this storage account is the default one, instead false.
+     */
+    public boolean isDefault() {
+        return getContent().isDefault();
+    }
+}
diff --git a/media/src/main/java/com/microsoft/windowsazure/services/media/models/StorageAccounts.java b/media/src/main/java/com/microsoft/windowsazure/services/media/models/StorageAccounts.java
new file mode 100644
index 0000000..04862a5
--- /dev/null
+++ b/media/src/main/java/com/microsoft/windowsazure/services/media/models/StorageAccounts.java
@@ -0,0 +1,48 @@
+/**
+ * Copyright Microsoft Corporation
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.microsoft.windowsazure.services.media.models;
+
+import com.microsoft.windowsazure.services.media.entityoperations.DefaultListOperation;
+import com.sun.jersey.api.client.GenericType;
+
+/**
+ * Class for creating operations to manipulate Asset entities.
+ * 
+ */
+public final class StorageAccounts {
+
+    /** The Constant ENTITY_SET. */
+    private static final String ENTITY_SET = "StorageAccounts";
+
+    // Prevent instantiation
+    /**
+     * Instantiates a new asset.
+     */
+    private StorageAccounts() {
+    }
+
+    /**
+     * Create an operation that will list all the assets.
+     * 
+     * @return The list operation
+     */
+    public static DefaultListOperation<StorageAccountInfo> list() {
+        return new DefaultListOperation<StorageAccountInfo>(ENTITY_SET,
+                new GenericType<ListResult<StorageAccountInfo>>() {
+                });
+    }
+
+}
diff --git a/media/src/test/java/com/microsoft/windowsazure/services/media/StorageAccountsTest.java b/media/src/test/java/com/microsoft/windowsazure/services/media/StorageAccountsTest.java
new file mode 100644
index 0000000..40b8017
--- /dev/null
+++ b/media/src/test/java/com/microsoft/windowsazure/services/media/StorageAccountsTest.java
@@ -0,0 +1,41 @@
+/**
+ * Copyright Microsoft Corporation
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.microsoft.windowsazure.services.media;
+
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertTrue;
+
+import org.junit.Test;
+
+import com.microsoft.windowsazure.services.media.models.ListResult;
+import com.microsoft.windowsazure.services.media.models.StorageAccountInfo;
+import com.microsoft.windowsazure.services.media.models.StorageAccounts;
+
+public class StorageAccountsTest extends IntegrationTestBase {
+    
+    @Test
+    public void listStorageAccountsSuccess() throws Exception {
+        // Arrange
+        
+        // Act
+        ListResult<StorageAccountInfo> storageAccounts = service.list(StorageAccounts.list());
+        
+        // Assert
+        assertNotNull(storageAccounts);
+        assertTrue(storageAccounts.size() > 0);
+        
+    } 
+}
-- 
1.9.5.msysgit.1


From bcf990fcb4452913f081e1a7466a51f944eb11bd Mon Sep 17 00:00:00 2001
From: Emanuel Vecchio <vecchioemanuel@gmail.com>
Date: Thu, 30 Jul 2015 15:02:14 -0300
Subject: [PATCH 18/21] README updated with new entities and operations

---
 README.md | 3 +++
 1 file changed, 3 insertions(+)

diff --git a/README.md b/README.md
index 6f57484..274c4fd 100644
--- a/README.md
+++ b/README.md
@@ -29,6 +29,9 @@ This project provides a client library in Java that makes it easy to consume Mic
     * Create/Read/Update/Cancel/Delete jobs
     * Add/Get job notifications
     * Create/Read/Update/Delete notification endpoints
+    * Create/Start/Scale/Stop/Delete streaming endpoints
+    * Get/Update encoding reserved units
+    * Get storage accounts
     * Serialize/Deserialize/GetTestToken [TokenRestriction](https://msdn.microsoft.com/en-us/library/azure/dn783467.aspx#code-snippet-4) Templates
     * Serialize/Deserialize [PlayReadyLicenseResponse](https://azure.microsoft.com/en-us/documentation/articles/media-services-playready-license-template-overview/#_schema) Templates
 * Service Management
-- 
1.9.5.msysgit.1


From a4546b3a4bcc03e79892221c35fe1ddb6ab59382 Mon Sep 17 00:00:00 2001
From: Emanuel Vecchio <vecchioemanuel@gmail.com>
Date: Thu, 30 Jul 2015 16:32:14 -0300
Subject: [PATCH 19/21] Bug fixing and cleanup

---
 .../media/entityoperations/EntityRestProxy.java    |  20 +-
 .../media/implementation/ODataAtomMarshaller.java  |   4 -
 .../implementation/content/ObjectFactory.java      |  15 +-
 .../media/implementation/content/OriginType.java   | 256 ---------------------
 .../media/models/EncodingReservedUnit.java         |   1 -
 .../services/media/models/StreamingEndpoint.java   |  23 ++
 6 files changed, 29 insertions(+), 290 deletions(-)
 delete mode 100644 media/src/main/java/com/microsoft/windowsazure/services/media/implementation/content/OriginType.java

diff --git a/media/src/main/java/com/microsoft/windowsazure/services/media/entityoperations/EntityRestProxy.java b/media/src/main/java/com/microsoft/windowsazure/services/media/entityoperations/EntityRestProxy.java
index 453adc7..6057b39 100644
--- a/media/src/main/java/com/microsoft/windowsazure/services/media/entityoperations/EntityRestProxy.java
+++ b/media/src/main/java/com/microsoft/windowsazure/services/media/entityoperations/EntityRestProxy.java
@@ -133,26 +133,12 @@ public abstract class EntityRestProxy implements EntityContract {
     public <T> T create(EntityCreateOperation<T> creator)
             throws ServiceException {
         creator.setProxyData(createProxyData());
-        ClientResponse clientResponse = getResource(creator).post(
-                ClientResponse.class, creator.getRequestContents());
-        
-        PipelineHelpers.throwIfNotSuccess(clientResponse);
-       
-        Object rawResponse = clientResponse.getEntity(creator.getResponseClass());
+        Object rawResponse = getResource(creator).post(
+                creator.getResponseClass(), creator.getRequestContents());
         Object processedResponse = creator.processResponse(rawResponse);
-        
-        if (processedResponse instanceof EntityWithOperationIdentifier 
-                && clientResponse.getHeaders().containsKey("operation-id")) {
-            EntityWithOperationIdentifier entityWithOpId = (EntityWithOperationIdentifier) processedResponse;
-            List<String> operationIds = clientResponse.getHeaders().get("operation-id");
-            if (operationIds.size() >= 0) {
-                entityWithOpId.setOperationId(operationIds.get(0));
-            }
-        }
-        
         return (T) processedResponse;
     }
-
+    
     /*
      * (non-Javadoc)
      * 
diff --git a/media/src/main/java/com/microsoft/windowsazure/services/media/implementation/ODataAtomMarshaller.java b/media/src/main/java/com/microsoft/windowsazure/services/media/implementation/ODataAtomMarshaller.java
index cef1ed2..11d6c8a 100644
--- a/media/src/main/java/com/microsoft/windowsazure/services/media/implementation/ODataAtomMarshaller.java
+++ b/media/src/main/java/com/microsoft/windowsazure/services/media/implementation/ODataAtomMarshaller.java
@@ -40,7 +40,6 @@ import com.microsoft.windowsazure.services.media.implementation.content.AssetTyp
 import com.microsoft.windowsazure.services.media.implementation.content.ChannelType;
 import com.microsoft.windowsazure.services.media.implementation.content.Constants;
 import com.microsoft.windowsazure.services.media.implementation.content.ContentKeyAuthorizationPolicyOptionType;
-import com.microsoft.windowsazure.services.media.implementation.content.ContentKeyAuthorizationPolicyRestrictionType;
 import com.microsoft.windowsazure.services.media.implementation.content.ContentKeyAuthorizationPolicyType;
 import com.microsoft.windowsazure.services.media.implementation.content.ContentKeyRestType;
 import com.microsoft.windowsazure.services.media.implementation.content.EncodingReservedUnitRestType;
@@ -49,7 +48,6 @@ import com.microsoft.windowsazure.services.media.implementation.content.JobType;
 import com.microsoft.windowsazure.services.media.implementation.content.LocatorRestType;
 import com.microsoft.windowsazure.services.media.implementation.content.NotificationEndPointType;
 import com.microsoft.windowsazure.services.media.implementation.content.OperationType;
-import com.microsoft.windowsazure.services.media.implementation.content.OriginType;
 import com.microsoft.windowsazure.services.media.implementation.content.ProgramType;
 import com.microsoft.windowsazure.services.media.implementation.content.StorageAccountType;
 import com.microsoft.windowsazure.services.media.implementation.content.StreamingEndpointType;
@@ -150,7 +148,6 @@ public class ODataAtomMarshaller {
         classes.add(ChannelType.class);
         classes.add(ContentKeyAuthorizationPolicyType.class);
         classes.add(ContentKeyAuthorizationPolicyOptionType.class);
-        classes.add(ContentKeyAuthorizationPolicyRestrictionType.class);
         classes.add(ContentKeyRestType.class);
         classes.add(EncodingReservedUnitRestType.class);
         classes.add(EntryType.class);
@@ -160,7 +157,6 @@ public class ODataAtomMarshaller {
         classes.add(LocatorRestType.class);
         classes.add(NotificationEndPointType.class);
         classes.add(OperationType.class);
-        classes.add(OriginType.class);
         classes.add(ProgramType.class);
         classes.add(StorageAccountType.class);
         classes.add(StreamingEndpointType.class);
diff --git a/media/src/main/java/com/microsoft/windowsazure/services/media/implementation/content/ObjectFactory.java b/media/src/main/java/com/microsoft/windowsazure/services/media/implementation/content/ObjectFactory.java
index 07e515d..e085840 100644
--- a/media/src/main/java/com/microsoft/windowsazure/services/media/implementation/content/ObjectFactory.java
+++ b/media/src/main/java/com/microsoft/windowsazure/services/media/implementation/content/ObjectFactory.java
@@ -160,15 +160,6 @@ public class ObjectFactory {
     }
 
     /**
-     * Creates an instance of (@link OriginType).
-     * 
-     * @return the origin type
-     */
-    public OriginType createOriginType() {
-        return new OriginType();
-    }
-
-    /**
      * Creates a instance of (@link @ProgramType).
      * 
      * @return the program type
@@ -226,16 +217,16 @@ public class ObjectFactory {
     /**
      * Creates a instance of (@link EncodingReservedUnitType).
      * 
-     * @return the EncodingReservedUnitType type
+     * @return the encoding reserved unit type
      */
     public EncodingReservedUnitRestType createEncodingReservedUnitType() {
         return new EncodingReservedUnitRestType();
     }
     
     /**
-     * Creates a instance of (@link EncodingReservedUnitType).
+     * Creates a instance of (@link StorageAccountType).
      * 
-     * @return the EncodingReservedUnitType type
+     * @return the storage account type
      */
     public StorageAccountType createStorageAccountType() {
         return new StorageAccountType();
diff --git a/media/src/main/java/com/microsoft/windowsazure/services/media/implementation/content/OriginType.java b/media/src/main/java/com/microsoft/windowsazure/services/media/implementation/content/OriginType.java
deleted file mode 100644
index d089c8c..0000000
--- a/media/src/main/java/com/microsoft/windowsazure/services/media/implementation/content/OriginType.java
+++ /dev/null
@@ -1,256 +0,0 @@
-/**
- * Copyright Microsoft Corporation
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.microsoft.windowsazure.services.media.implementation.content;
-
-import java.util.Date;
-
-import javax.xml.bind.annotation.XmlAccessType;
-import javax.xml.bind.annotation.XmlAccessorType;
-import javax.xml.bind.annotation.XmlElement;
-
-/**
- * This type maps the XML returned in the odata ATOM serialization for Asset
- * entities.
- * 
- */
-@XmlAccessorType(XmlAccessType.FIELD)
-public class OriginType implements MediaServiceDTO {
-
-    /** The id. */
-    @XmlElement(name = "Id", namespace = Constants.ODATA_DATA_NS)
-    private String id;
-
-    /** The name. */
-    @XmlElement(name = "Name", namespace = Constants.ODATA_DATA_NS)
-    private String name;
-
-    /** The description. */
-    @XmlElement(name = "Description", namespace = Constants.ODATA_DATA_NS)
-    private String description;
-
-    /** The hostName. */
-    @XmlElement(name = "HostName", namespace = Constants.ODATA_DATA_NS)
-    private String hostName;
-
-    /** The created. */
-    @XmlElement(name = "Created", namespace = Constants.ODATA_DATA_NS)
-    private Date created;
-
-    /** The last modified. */
-    @XmlElement(name = "LastModified", namespace = Constants.ODATA_DATA_NS)
-    private Date lastModified;
-
-    /** The state. */
-    @XmlElement(name = "State", namespace = Constants.ODATA_DATA_NS)
-    private String state;
-
-    /** The reserved units. */
-    @XmlElement(name = "ReservedUnits", namespace = Constants.ODATA_DATA_NS)
-    private int reservedUnits;
-
-    /** The settings. */
-    @XmlElement(name = "Settings", namespace = Constants.ODATA_DATA_NS)
-    private String settings;
-
-    /**
-     * Gets the id.
-     * 
-     * @return the id
-     */
-    public String getId() {
-        return this.id;
-    }
-
-    /**
-     * Sets the id.
-     * 
-     * @param id
-     *            the id
-     * @return the origin type
-     */
-    public OriginType setId(String id) {
-        this.id = id;
-        return this;
-    }
-
-    /**
-     * Gets the name.
-     * 
-     * @return the name
-     */
-    public String getName() {
-        return name;
-    }
-
-    /**
-     * Sets the name.
-     * 
-     * @param name
-     *            the name to set
-     * @return the origin type
-     */
-    public OriginType setName(String name) {
-        this.name = name;
-        return this;
-    }
-
-    /**
-     * Gets the description.
-     * 
-     * @return the description
-     */
-    public String getDescription() {
-        return description;
-    }
-
-    /**
-     * Sets the description.
-     * 
-     * @param description
-     *            the description
-     * @return the origin type
-     */
-    public OriginType setDescription(String description) {
-        this.description = description;
-        return this;
-    }
-
-    /**
-     * Gets the host name.
-     * 
-     * @return the host name
-     */
-    public String getHostName() {
-        return hostName;
-    }
-
-    /**
-     * Sets the host name.
-     * 
-     * @param host
-     *            name the host name to set
-     * @return the origin type
-     */
-    public OriginType setHostName(String hostName) {
-        this.hostName = hostName;
-        return this;
-    }
-
-    /**
-     * Gets the created.
-     * 
-     * @return the created
-     */
-    public Date getCreated() {
-        return created;
-    }
-
-    /**
-     * Sets the created.
-     * 
-     * @param created
-     *            the created
-     * @return the origin type
-     */
-    public OriginType setCreated(Date created) {
-        this.created = created;
-        return this;
-    }
-
-    /**
-     * Gets the last modified.
-     * 
-     * @return the lastModified
-     */
-    public Date getLastModified() {
-        return lastModified;
-    }
-
-    /**
-     * Sets the last modified.
-     * 
-     * @param lastModified
-     *            the last modified
-     * @return the origin type
-     */
-    public OriginType setLastModified(Date lastModified) {
-        this.lastModified = lastModified;
-        return this;
-    }
-
-    /**
-     * Sets the state.
-     * 
-     * @param state
-     *            the state
-     * @return the origin type
-     */
-    public OriginType setState(String state) {
-        this.state = state;
-        return this;
-    }
-
-    /**
-     * Gets the state.
-     * 
-     * @return the state
-     */
-    public String getState() {
-        return this.state;
-    }
-
-    /**
-     * Sets the reserved units.
-     * 
-     * @param reservedUnits
-     *            the reserved units
-     * @return the origin type
-     */
-    public OriginType setReservedUnits(int reservedUnits) {
-        this.reservedUnits = reservedUnits;
-        return this;
-    }
-
-    /**
-     * Gets the reserved units.
-     * 
-     * @return the reserved units
-     */
-    public int getReservedUnits() {
-        return this.reservedUnits;
-    }
-
-    /**
-     * Gets the settings.
-     * 
-     * @return the settings
-     */
-    public String getSettings() {
-        return this.settings;
-    }
-
-    /**
-     * Sets the settings.
-     * 
-     * @param settings
-     *            the settings
-     * @return the origin type
-     */
-    public OriginType setSettings(String settings) {
-        this.settings = settings;
-        return this;
-    }
-}
diff --git a/media/src/main/java/com/microsoft/windowsazure/services/media/models/EncodingReservedUnit.java b/media/src/main/java/com/microsoft/windowsazure/services/media/models/EncodingReservedUnit.java
index cc71763..b4e2824 100644
--- a/media/src/main/java/com/microsoft/windowsazure/services/media/models/EncodingReservedUnit.java
+++ b/media/src/main/java/com/microsoft/windowsazure/services/media/models/EncodingReservedUnit.java
@@ -22,7 +22,6 @@ import com.microsoft.windowsazure.services.media.entityoperations.EntityGetOpera
 import com.microsoft.windowsazure.services.media.entityoperations.EntityOperationBase;
 import com.microsoft.windowsazure.services.media.entityoperations.EntityProxyData;
 import com.microsoft.windowsazure.services.media.entityoperations.EntityUpdateOperation;
-import com.microsoft.windowsazure.services.media.entityoperations.EntityOperationBase.EntityUriBuilder;
 import com.microsoft.windowsazure.services.media.implementation.content.EncodingReservedUnitRestType;
 
 /**
diff --git a/media/src/main/java/com/microsoft/windowsazure/services/media/models/StreamingEndpoint.java b/media/src/main/java/com/microsoft/windowsazure/services/media/models/StreamingEndpoint.java
index 2bf9315..d58471f 100644
--- a/media/src/main/java/com/microsoft/windowsazure/services/media/models/StreamingEndpoint.java
+++ b/media/src/main/java/com/microsoft/windowsazure/services/media/models/StreamingEndpoint.java
@@ -17,6 +17,7 @@ package com.microsoft.windowsazure.services.media.models;
 
 import java.util.List;
 
+import com.microsoft.windowsazure.exception.ServiceException;
 import com.microsoft.windowsazure.services.media.entityoperations.DefaultDeleteOperation;
 import com.microsoft.windowsazure.services.media.entityoperations.DefaultEntityActionOperation;
 import com.microsoft.windowsazure.services.media.entityoperations.DefaultGetOperation;
@@ -33,6 +34,7 @@ import com.microsoft.windowsazure.services.media.implementation.content.CrossSit
 import com.microsoft.windowsazure.services.media.implementation.content.StreamingEndpointAccessControlType;
 import com.microsoft.windowsazure.services.media.implementation.content.StreamingEndpointCacheControlType;
 import com.microsoft.windowsazure.services.media.implementation.content.StreamingEndpointType;
+import com.sun.jersey.api.client.ClientResponse;
 import com.sun.jersey.api.client.GenericType;
 
 /**
@@ -82,6 +84,27 @@ public final class StreamingEndpoint {
         public Creator() {
             super(ENTITY_SET, StreamingEndpointInfo.class);
         }
+        
+        @SuppressWarnings({ "unchecked", "rawtypes" })
+        @Override
+        public Class getResponseClass() {
+            return ClientResponse.class;
+        }
+        
+        @Override
+        public Object processResponse(Object rawResponse)
+                throws ServiceException {
+            ClientResponse clientResponse = (ClientResponse) rawResponse;
+            StreamingEndpointInfo streamingEndpointInfo = clientResponse.getEntity(StreamingEndpointInfo.class);
+            
+            if (clientResponse.getHeaders().containsKey("operation-id")) {
+                List<String> operationIds = clientResponse.getHeaders().get("operation-id");
+                if (operationIds.size() >= 0) {
+                    streamingEndpointInfo.setOperationId(operationIds.get(0));
+                }
+            }
+            return streamingEndpointInfo;
+        }
 
         /*
          * (non-Javadoc)
-- 
1.9.5.msysgit.1


From 815c1581f3d4d82806abcc34d581ec36de988ecf Mon Sep 17 00:00:00 2001
From: Emanuel Vecchio <vecchioemanuel@gmail.com>
Date: Fri, 31 Jul 2015 12:07:22 -0300
Subject: [PATCH 20/21] Organize Imports

---
 .../services/media/EncodingReservedUnitTypeIntegrationTest.java       | 3 ---
 .../microsoft/windowsazure/services/media/IntegrationTestBase.java    | 4 ----
 .../services/media/StreamingEndopointIntegrationTest.java             | 1 -
 .../tokenrestriction/TokenRestrictionTemplateSerializerTests.java     | 1 -
 4 files changed, 9 deletions(-)

diff --git a/media/src/test/java/com/microsoft/windowsazure/services/media/EncodingReservedUnitTypeIntegrationTest.java b/media/src/test/java/com/microsoft/windowsazure/services/media/EncodingReservedUnitTypeIntegrationTest.java
index 9229929..bf170c7 100644
--- a/media/src/test/java/com/microsoft/windowsazure/services/media/EncodingReservedUnitTypeIntegrationTest.java
+++ b/media/src/test/java/com/microsoft/windowsazure/services/media/EncodingReservedUnitTypeIntegrationTest.java
@@ -17,11 +17,8 @@ package com.microsoft.windowsazure.services.media;
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNotNull;
-import static org.junit.Assert.assertTrue;
 
-import org.junit.After;
 import org.junit.AfterClass;
-import org.junit.Before;
 import org.junit.BeforeClass;
 import org.junit.Test;
 
diff --git a/media/src/test/java/com/microsoft/windowsazure/services/media/IntegrationTestBase.java b/media/src/test/java/com/microsoft/windowsazure/services/media/IntegrationTestBase.java
index 44411b3..a823dd9 100644
--- a/media/src/test/java/com/microsoft/windowsazure/services/media/IntegrationTestBase.java
+++ b/media/src/test/java/com/microsoft/windowsazure/services/media/IntegrationTestBase.java
@@ -36,7 +36,6 @@ import org.junit.rules.ExpectedException;
 
 import com.microsoft.windowsazure.Configuration;
 import com.microsoft.windowsazure.exception.ServiceException;
-import com.microsoft.windowsazure.services.media.entityoperations.EntityWithOperationIdentifier;
 import com.microsoft.windowsazure.services.media.models.AccessPolicy;
 import com.microsoft.windowsazure.services.media.models.AccessPolicyInfo;
 import com.microsoft.windowsazure.services.media.models.AccessPolicyPermission;
@@ -56,9 +55,6 @@ import com.microsoft.windowsazure.services.media.models.MediaProcessor;
 import com.microsoft.windowsazure.services.media.models.MediaProcessorInfo;
 import com.microsoft.windowsazure.services.media.models.NotificationEndPoint;
 import com.microsoft.windowsazure.services.media.models.NotificationEndPointInfo;
-import com.microsoft.windowsazure.services.media.models.Operation;
-import com.microsoft.windowsazure.services.media.models.OperationInfo;
-import com.microsoft.windowsazure.services.media.models.OperationState;
 import com.microsoft.windowsazure.services.media.models.StreamingEndpoint;
 import com.microsoft.windowsazure.services.media.models.StreamingEndpointInfo;
 import com.microsoft.windowsazure.services.media.models.StreamingEndpointState;
diff --git a/media/src/test/java/com/microsoft/windowsazure/services/media/StreamingEndopointIntegrationTest.java b/media/src/test/java/com/microsoft/windowsazure/services/media/StreamingEndopointIntegrationTest.java
index bdbb3b4..4a06c51 100644
--- a/media/src/test/java/com/microsoft/windowsazure/services/media/StreamingEndopointIntegrationTest.java
+++ b/media/src/test/java/com/microsoft/windowsazure/services/media/StreamingEndopointIntegrationTest.java
@@ -19,7 +19,6 @@ import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertTrue;
 
-import org.junit.Ignore;
 import org.junit.Test;
 
 import com.microsoft.windowsazure.services.media.models.ListResult;
diff --git a/media/src/test/java/com/microsoft/windowsazure/services/media/implementation/templates/tokenrestriction/TokenRestrictionTemplateSerializerTests.java b/media/src/test/java/com/microsoft/windowsazure/services/media/implementation/templates/tokenrestriction/TokenRestrictionTemplateSerializerTests.java
index 8d287b7..aeae931 100644
--- a/media/src/test/java/com/microsoft/windowsazure/services/media/implementation/templates/tokenrestriction/TokenRestrictionTemplateSerializerTests.java
+++ b/media/src/test/java/com/microsoft/windowsazure/services/media/implementation/templates/tokenrestriction/TokenRestrictionTemplateSerializerTests.java
@@ -8,7 +8,6 @@ import static org.junit.Assert.fail;
 
 import java.net.URI;
 import java.net.URISyntaxException;
-import java.text.ParseException;
 import java.text.SimpleDateFormat;
 import java.util.Date;
 import java.util.Locale;
-- 
1.9.5.msysgit.1


From 83687d0cd70f0b41c665ff0350a477472226e631 Mon Sep 17 00:00:00 2001
From: Emanuel Vecchio <vecchioemanuel@gmail.com>
Date: Mon, 3 Aug 2015 14:47:46 -0300
Subject: [PATCH 21/21] Streaming Endpoint pending Integration Test and bug
 fixing.

---
 .../content/AkamaiAccessControlType.java           |   2 +-
 .../content/IPAccessControlType.java               |   2 +-
 .../StreamingEndpointAccessControlType.java        |  16 +++
 .../content/StreamingEndpointCacheControlType.java |  12 +--
 .../content/StreamingEndpointType.java             |   8 +-
 .../services/media/models/StreamingEndpoint.java   | 100 ++++++++++--------
 .../media/models/StreamingEndpointInfo.java        |   8 +-
 .../media/StreamingEndopointIntegrationTest.java   | 114 ++++++++++++++++++++-
 8 files changed, 199 insertions(+), 63 deletions(-)

diff --git a/media/src/main/java/com/microsoft/windowsazure/services/media/implementation/content/AkamaiAccessControlType.java b/media/src/main/java/com/microsoft/windowsazure/services/media/implementation/content/AkamaiAccessControlType.java
index 7d45079..d73ffeb 100644
--- a/media/src/main/java/com/microsoft/windowsazure/services/media/implementation/content/AkamaiAccessControlType.java
+++ b/media/src/main/java/com/microsoft/windowsazure/services/media/implementation/content/AkamaiAccessControlType.java
@@ -11,7 +11,7 @@ import javax.xml.bind.annotation.XmlElementWrapper;
 public class AkamaiAccessControlType {
     
     @XmlElementWrapper(name = "AkamaiSignatureHeaderAuthenticationKeyList", namespace = Constants.ODATA_DATA_NS)
-    @XmlElement(name = "AkamaiSignatureHeaderAuthenticationKey", namespace = Constants.ODATA_DATA_NS)
+    @XmlElement(name = "element", namespace = Constants.ODATA_DATA_NS)
     private List<AkamaiSignatureHeaderAuthenticationKey> akamaiSignatureHeaderAuthenticationKeyList;
 
     public List<AkamaiSignatureHeaderAuthenticationKey> getAkamaiSignatureHeaderAuthenticationKeyList() {
diff --git a/media/src/main/java/com/microsoft/windowsazure/services/media/implementation/content/IPAccessControlType.java b/media/src/main/java/com/microsoft/windowsazure/services/media/implementation/content/IPAccessControlType.java
index 81f66a0..ddf5791 100644
--- a/media/src/main/java/com/microsoft/windowsazure/services/media/implementation/content/IPAccessControlType.java
+++ b/media/src/main/java/com/microsoft/windowsazure/services/media/implementation/content/IPAccessControlType.java
@@ -11,7 +11,7 @@ import javax.xml.bind.annotation.XmlElementWrapper;
 public class IPAccessControlType {
 
     @XmlElementWrapper(name = "Allow", namespace = Constants.ODATA_DATA_NS)
-    @XmlElement(name = "IPRange", namespace = Constants.ODATA_DATA_NS)
+    @XmlElement(name = "element", namespace = Constants.ODATA_DATA_NS)
     private List<IPRangeType> ipRange;
 
     public List<IPRangeType> getIpRange() {
diff --git a/media/src/main/java/com/microsoft/windowsazure/services/media/implementation/content/StreamingEndpointAccessControlType.java b/media/src/main/java/com/microsoft/windowsazure/services/media/implementation/content/StreamingEndpointAccessControlType.java
index e3a284a..ada028e 100644
--- a/media/src/main/java/com/microsoft/windowsazure/services/media/implementation/content/StreamingEndpointAccessControlType.java
+++ b/media/src/main/java/com/microsoft/windowsazure/services/media/implementation/content/StreamingEndpointAccessControlType.java
@@ -12,4 +12,20 @@ public class StreamingEndpointAccessControlType {
     
     @XmlElement(name = "IP", namespace = Constants.ODATA_DATA_NS)
     private IPAccessControlType iP;
+    
+    public AkamaiAccessControlType getAkamai() {
+        return akamai;
+    }
+
+    public void setAkamai(AkamaiAccessControlType akamai) {
+        this.akamai = akamai;
+    }
+
+    public IPAccessControlType getIP() {
+        return iP;
+    }
+
+    public void setIP(IPAccessControlType iP) {
+        this.iP = iP;
+    }
 }
diff --git a/media/src/main/java/com/microsoft/windowsazure/services/media/implementation/content/StreamingEndpointCacheControlType.java b/media/src/main/java/com/microsoft/windowsazure/services/media/implementation/content/StreamingEndpointCacheControlType.java
index 688cbd9..6ff1d36 100644
--- a/media/src/main/java/com/microsoft/windowsazure/services/media/implementation/content/StreamingEndpointCacheControlType.java
+++ b/media/src/main/java/com/microsoft/windowsazure/services/media/implementation/content/StreamingEndpointCacheControlType.java
@@ -7,14 +7,14 @@ import javax.xml.bind.annotation.XmlElement;
 @XmlAccessorType(XmlAccessType.FIELD)
 public class StreamingEndpointCacheControlType {
 
-    @XmlElement(name = "MaxRange", namespace = Constants.ODATA_DATA_NS)
-    private Integer maxRange;
+    @XmlElement(name = "MaxAge", namespace = Constants.ODATA_DATA_NS)
+    private Integer maxAge;
 
-    public int getMaxRange() {
-        return maxRange;
+    public int getMaxAge() {
+        return maxAge;
     }
 
-    public void setMaxRange(int maxRange) {
-        this.maxRange = maxRange;
+    public void setMaxAge(int maxRange) {
+        this.maxAge = maxRange;
     }
 }
diff --git a/media/src/main/java/com/microsoft/windowsazure/services/media/implementation/content/StreamingEndpointType.java b/media/src/main/java/com/microsoft/windowsazure/services/media/implementation/content/StreamingEndpointType.java
index 4f5a06f..4d8e2aa 100644
--- a/media/src/main/java/com/microsoft/windowsazure/services/media/implementation/content/StreamingEndpointType.java
+++ b/media/src/main/java/com/microsoft/windowsazure/services/media/implementation/content/StreamingEndpointType.java
@@ -152,19 +152,19 @@ public class StreamingEndpointType implements MediaServiceDTO {
         this.cdnEnabled = cdnEnabled;
     }
 
-    public StreamingEndpointAccessControlType getStreamingEndpointAccessControl() {
+    public StreamingEndpointAccessControlType getAccessControl() {
         return streamingEndpointAccessControl;
     }
 
-    public void setStreamingEndpointAccessControl(StreamingEndpointAccessControlType streamingEndpointAccessControl) {
+    public void setAccessControl(StreamingEndpointAccessControlType streamingEndpointAccessControl) {
         this.streamingEndpointAccessControl = streamingEndpointAccessControl;
     }
 
-    public StreamingEndpointCacheControlType getStreamingEndpointCacheControl() {
+    public StreamingEndpointCacheControlType getCacheControl() {
         return streamingEndpointCacheControl;
     }
 
-    public void setStreamingEndpointCacheControl(StreamingEndpointCacheControlType streamingEndpointCacheControl) {
+    public void setCacheControl(StreamingEndpointCacheControlType streamingEndpointCacheControl) {
         this.streamingEndpointCacheControl = streamingEndpointCacheControl;
     }
 
diff --git a/media/src/main/java/com/microsoft/windowsazure/services/media/models/StreamingEndpoint.java b/media/src/main/java/com/microsoft/windowsazure/services/media/models/StreamingEndpoint.java
index d58471f..f75405f 100644
--- a/media/src/main/java/com/microsoft/windowsazure/services/media/models/StreamingEndpoint.java
+++ b/media/src/main/java/com/microsoft/windowsazure/services/media/models/StreamingEndpoint.java
@@ -36,6 +36,7 @@ import com.microsoft.windowsazure.services.media.implementation.content.Streamin
 import com.microsoft.windowsazure.services.media.implementation.content.StreamingEndpointType;
 import com.sun.jersey.api.client.ClientResponse;
 import com.sun.jersey.api.client.GenericType;
+import com.sun.jersey.api.client.UniformInterfaceException;
 
 /**
  * Class for creating operations to manipulate Asset entities.
@@ -65,9 +66,8 @@ public final class StreamingEndpoint {
     /**
      * The Class Creator.
      */
-    public static class Creator extends
-            EntityOperationSingleResultBase<StreamingEndpointInfo> implements
-            EntityCreateOperation<StreamingEndpointInfo> {
+    public static class Creator extends EntityOperationSingleResultBase<StreamingEndpointInfo>
+            implements EntityCreateOperation<StreamingEndpointInfo> {
 
         private String name;
         private String description;
@@ -84,19 +84,24 @@ public final class StreamingEndpoint {
         public Creator() {
             super(ENTITY_SET, StreamingEndpointInfo.class);
         }
-        
+
         @SuppressWarnings({ "unchecked", "rawtypes" })
         @Override
         public Class getResponseClass() {
             return ClientResponse.class;
         }
-        
+
         @Override
-        public Object processResponse(Object rawResponse)
-                throws ServiceException {
+        public Object processResponse(Object rawResponse) throws ServiceException {
             ClientResponse clientResponse = (ClientResponse) rawResponse;
+
+            if (clientResponse.getStatus() >= 300) {
+                throw new UniformInterfaceException(
+                        String.format("Received: %s", clientResponse.getEntity(String.class)), clientResponse);
+            }
+
             StreamingEndpointInfo streamingEndpointInfo = clientResponse.getEntity(StreamingEndpointInfo.class);
-            
+
             if (clientResponse.getHeaders().containsKey("operation-id")) {
                 List<String> operationIds = clientResponse.getHeaders().get("operation-id");
                 if (operationIds.size() >= 0) {
@@ -121,8 +126,8 @@ public final class StreamingEndpoint {
             streamingEndpointType.setCustomHostName(customHostNames);
             streamingEndpointType.setCrossSiteAccessPolicies(crossSiteAccessPolicies);
             streamingEndpointType.setScaleUnits(scaleUnits);
-            streamingEndpointType.setStreamingEndpointAccessControl(streamingEndpointAccessControl);
-            streamingEndpointType.setStreamingEndpointCacheControl(streamingEndpointCacheControl);
+            streamingEndpointType.setAccessControl(streamingEndpointAccessControl);
+            streamingEndpointType.setCacheControl(streamingEndpointCacheControl);
             return streamingEndpointType;
         }
 
@@ -175,19 +180,21 @@ public final class StreamingEndpoint {
         }
 
         /**
-         * Set the access control policies of the streaming endpoint to be created.
+         * Set the access control policies of the streaming endpoint to be
+         * created.
          * 
          * @param streamingEndpointAccessControl
          *            the access control policies
          * @return The creator object (for call chaining)
          */
-        public Creator setStreamingEndpointAccessControl(StreamingEndpointAccessControlType streamingEndpointAccessControl) {
+        public Creator setAccessControl(StreamingEndpointAccessControlType streamingEndpointAccessControl) {
             this.streamingEndpointAccessControl = streamingEndpointAccessControl;
             return this;
         }
 
         /**
-         * Set the list of custom host names of the streaming endpoint to be created.
+         * Set the list of custom host names of the streaming endpoint to be
+         * created.
          * 
          * @param customHostNames
          *            the list of custom host names
@@ -199,29 +206,31 @@ public final class StreamingEndpoint {
         }
 
         /**
-         * Set the streaming endpoint cache control of the streaming endpoint to be created.
+         * Set the streaming endpoint cache control of the streaming endpoint to
+         * be created.
          * 
          * @param streamingEndpointCacheControl
          *            the streaming endpoint cache control
          * @return The creator object (for call chaining)
          */
-        public Creator setStreamingEndpointCacheControl(StreamingEndpointCacheControlType streamingEndpointCacheControl) {
+        public Creator setCacheControl(StreamingEndpointCacheControlType streamingEndpointCacheControl) {
             this.streamingEndpointCacheControl = streamingEndpointCacheControl;
             return this;
         }
 
         /**
-         * Set the cross site access policies of the streaming endpoint to be created.
+         * Set the cross site access policies of the streaming endpoint to be
+         * created.
          * 
          * @param crossSiteAccessPolicies
          *            the cross site access policies
          * @return The creator object (for call chaining)
          */
-        public Creator setSrossSiteAccessPolicies(CrossSiteAccessPoliciesType crossSiteAccessPolicies) {
+        public Creator setCrossSiteAccessPolicies(CrossSiteAccessPoliciesType crossSiteAccessPolicies) {
             this.crossSiteAccessPolicies = crossSiteAccessPolicies;
             return this;
         }
-        
+
     }
 
     /**
@@ -257,7 +266,7 @@ public final class StreamingEndpoint {
     public static Updater update(String streamingEndpointId) {
         return new Updater(streamingEndpointId);
     }
-    
+
     public static Updater update(StreamingEndpointInfo streamingEndpointInfo) {
         return new Updater(streamingEndpointInfo);
     }
@@ -265,13 +274,12 @@ public final class StreamingEndpoint {
     /**
      * The Class Updater.
      */
-    public static class Updater extends EntityOperationBase implements
-            EntityUpdateOperation {
+    public static class Updater extends EntityOperationBase implements EntityUpdateOperation {
 
         private String description = null;
         private boolean cdnEnabled;
-        private List<String> customHostNames  = null;
-        private StreamingEndpointAccessControlType streamingEndpointAccessControl  = null;
+        private List<String> customHostNames = null;
+        private StreamingEndpointAccessControlType streamingEndpointAccessControl = null;
         private StreamingEndpointCacheControlType streamingEndpointCacheControl = null;
         private CrossSiteAccessPoliciesType crossSiteAccessPolicies = null;
 
@@ -282,19 +290,17 @@ public final class StreamingEndpoint {
          *            the asset id
          */
         protected Updater(String streamingEndpointId) {
-            super(new EntityOperationBase.EntityIdUriBuilder(ENTITY_SET,
-                    streamingEndpointId));
+            super(new EntityOperationBase.EntityIdUriBuilder(ENTITY_SET, streamingEndpointId));
         }
-        
+
         protected Updater(StreamingEndpointInfo streamingEndpointInfo) {
-            super(new EntityOperationBase.EntityIdUriBuilder(ENTITY_SET,
-                    streamingEndpointInfo.getId()));
+            super(new EntityOperationBase.EntityIdUriBuilder(ENTITY_SET, streamingEndpointInfo.getId()));
             this.setCdnEnabled(streamingEndpointInfo.isCdnEnabled());
             this.setCustomHostNames(streamingEndpointInfo.getCustomHostNames());
             this.setDescription(streamingEndpointInfo.getDescription());
-            this.setSrossSiteAccessPolicies(streamingEndpointInfo.getCrossSiteAccessPolicies());
-            this.setStreamingEndpointAccessControl(streamingEndpointInfo.getStreamingEndpointAccessControl());
-            this.setStreamingEndpointCacheControl(streamingEndpointInfo.getStreamingEndpointCacheControl());
+            this.setCrossSiteAccessPolicies(streamingEndpointInfo.getCrossSiteAccessPolicies());
+            this.setAccessControl(streamingEndpointInfo.getAccessControl());
+            this.setCacheControl(streamingEndpointInfo.getCacheControl());
         }
 
         /*
@@ -323,8 +329,8 @@ public final class StreamingEndpoint {
             streamingEndpointType.setCdnEnabled(cdnEnabled);
             streamingEndpointType.setCustomHostName(customHostNames);
             streamingEndpointType.setCrossSiteAccessPolicies(crossSiteAccessPolicies);
-            streamingEndpointType.setStreamingEndpointAccessControl(streamingEndpointAccessControl);
-            streamingEndpointType.setStreamingEndpointCacheControl(streamingEndpointCacheControl);
+            streamingEndpointType.setAccessControl(streamingEndpointAccessControl);
+            streamingEndpointType.setCacheControl(streamingEndpointCacheControl);
             return streamingEndpointType;
         }
 
@@ -341,7 +347,8 @@ public final class StreamingEndpoint {
         }
 
         /**
-         * Set the new value for CDN enabled on the streaming endpoint to be updated.
+         * Set the new value for CDN enabled on the streaming endpoint to be
+         * updated.
          * 
          * @param cdnEnabled
          *            true if CDN is enabled
@@ -353,19 +360,21 @@ public final class StreamingEndpoint {
         }
 
         /**
-         * Set the new access control policies of the streaming endpoint to be updated.
+         * Set the new access control policies of the streaming endpoint to be
+         * updated.
          * 
          * @param streamingEndpointAccessControl
          *            the access control policies
          * @return The creator object (for call chaining)
          */
-        public Updater setStreamingEndpointAccessControl(StreamingEndpointAccessControlType streamingEndpointAccessControl) {
+        public Updater setAccessControl(StreamingEndpointAccessControlType streamingEndpointAccessControl) {
             this.streamingEndpointAccessControl = streamingEndpointAccessControl;
             return this;
         }
 
         /**
-         * Set the new list of custom host names of the streaming endpoint to be updated.
+         * Set the new list of custom host names of the streaming endpoint to be
+         * updated.
          * 
          * @param customHostNames
          *            the list of custom host names
@@ -377,25 +386,27 @@ public final class StreamingEndpoint {
         }
 
         /**
-         * Set the new streaming endpoint cache control of the streaming endpoint to be updated.
+         * Set the new streaming endpoint cache control of the streaming
+         * endpoint to be updated.
          * 
          * @param streamingEndpointCacheControl
          *            the streaming endpoint cache control
          * @return The creator object (for call chaining)
          */
-        public Updater setStreamingEndpointCacheControl(StreamingEndpointCacheControlType streamingEndpointCacheControl) {
+        public Updater setCacheControl(StreamingEndpointCacheControlType streamingEndpointCacheControl) {
             this.streamingEndpointCacheControl = streamingEndpointCacheControl;
             return this;
         }
 
         /**
-         * Set the new cross site access policies of the streaming endpoint to be updated.
+         * Set the new cross site access policies of the streaming endpoint to
+         * be updated.
          * 
          * @param crossSiteAccessPolicies
          *            the cross site access policies
          * @return The creator object (for call chaining)
          */
-        public Updater setSrossSiteAccessPolicies(CrossSiteAccessPoliciesType crossSiteAccessPolicies) {
+        public Updater setCrossSiteAccessPolicies(CrossSiteAccessPoliciesType crossSiteAccessPolicies) {
             this.crossSiteAccessPolicies = crossSiteAccessPolicies;
             return this;
         }
@@ -415,13 +426,14 @@ public final class StreamingEndpoint {
     public static EntityActionOperation start(String streamingEndpointId) {
         return new DefaultEntityActionOperation(ENTITY_SET, streamingEndpointId, "Start");
     }
-    
+
     public static EntityActionOperation stop(String streamingEndpointId) {
         return new DefaultEntityActionOperation(ENTITY_SET, streamingEndpointId, "Stop");
     }
-    
+
     public static EntityActionOperation scale(String streamingEndpointId, int scaleUnits) {
-        DefaultEntityActionOperation operation = new DefaultEntityActionOperation(ENTITY_SET, streamingEndpointId, "Scale");
+        DefaultEntityActionOperation operation = new DefaultEntityActionOperation(ENTITY_SET, streamingEndpointId,
+                "Scale");
         operation.addBodyParameter("scaleUnits", scaleUnits);
         return operation;
     }
diff --git a/media/src/main/java/com/microsoft/windowsazure/services/media/models/StreamingEndpointInfo.java b/media/src/main/java/com/microsoft/windowsazure/services/media/models/StreamingEndpointInfo.java
index 40d75fd..07b7e2e 100644
--- a/media/src/main/java/com/microsoft/windowsazure/services/media/models/StreamingEndpointInfo.java
+++ b/media/src/main/java/com/microsoft/windowsazure/services/media/models/StreamingEndpointInfo.java
@@ -140,8 +140,8 @@ public class StreamingEndpointInfo extends ODataEntity<StreamingEndpointType>
      * 
      * @return the access control policy
      */
-    public StreamingEndpointAccessControlType getStreamingEndpointAccessControl() {
-        return getContent().getStreamingEndpointAccessControl();
+    public StreamingEndpointAccessControlType getAccessControl() {
+        return getContent().getAccessControl();
     }
 
     /**
@@ -149,8 +149,8 @@ public class StreamingEndpointInfo extends ODataEntity<StreamingEndpointType>
      * 
      * @return the cahe control policy
      */
-    public StreamingEndpointCacheControlType getStreamingEndpointCacheControl() {
-        return getContent().getStreamingEndpointCacheControl();
+    public StreamingEndpointCacheControlType getCacheControl() {
+        return getContent().getCacheControl();
     }
 
     /**
diff --git a/media/src/test/java/com/microsoft/windowsazure/services/media/StreamingEndopointIntegrationTest.java b/media/src/test/java/com/microsoft/windowsazure/services/media/StreamingEndopointIntegrationTest.java
index 4a06c51..3ad9a0d 100644
--- a/media/src/test/java/com/microsoft/windowsazure/services/media/StreamingEndopointIntegrationTest.java
+++ b/media/src/test/java/com/microsoft/windowsazure/services/media/StreamingEndopointIntegrationTest.java
@@ -19,8 +19,20 @@ import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertTrue;
 
+import java.util.ArrayList;
+import java.util.Calendar;
+import java.util.Date;
+import java.util.List;
+
 import org.junit.Test;
 
+import com.microsoft.windowsazure.services.media.implementation.content.AkamaiAccessControlType;
+import com.microsoft.windowsazure.services.media.implementation.content.AkamaiSignatureHeaderAuthenticationKey;
+import com.microsoft.windowsazure.services.media.implementation.content.CrossSiteAccessPoliciesType;
+import com.microsoft.windowsazure.services.media.implementation.content.IPAccessControlType;
+import com.microsoft.windowsazure.services.media.implementation.content.IPRangeType;
+import com.microsoft.windowsazure.services.media.implementation.content.StreamingEndpointAccessControlType;
+import com.microsoft.windowsazure.services.media.implementation.content.StreamingEndpointCacheControlType;
 import com.microsoft.windowsazure.services.media.models.ListResult;
 import com.microsoft.windowsazure.services.media.models.OperationState;
 import com.microsoft.windowsazure.services.media.models.StreamingEndpoint;
@@ -50,7 +62,9 @@ public class StreamingEndopointIntegrationTest extends IntegrationTestBase {
         
         // Cleanup
         String deleteOpId = service.delete(StreamingEndpoint.delete(info.getId()));
-        OperationUtils.await(service, deleteOpId);
+        OperationState state = OperationUtils.await(service, deleteOpId);
+        // Assert Cleanup
+        assertEquals(state, OperationState.Succeeded);
     }
     
     @Test
@@ -85,7 +99,6 @@ public class StreamingEndopointIntegrationTest extends IntegrationTestBase {
         assertEquals(state, OperationState.Succeeded);
     }
     
-    
     @Test
     public void streamingEndpointCreateStartScaleStopDeleteTest() throws Exception {
         // Arrange
@@ -162,6 +175,101 @@ public class StreamingEndopointIntegrationTest extends IntegrationTestBase {
         assertEquals(state, OperationState.Succeeded);
     }
     
-    
+    @Test
+    public void createAndRetrieveTheSameStreamingEndpointTest() throws Exception {
+        // Arrange
+        int expectedScaleUnits = 1;
+        boolean expectedCdnState = false;
+        String expectedName = testStreamingEndPointPrefix + "createAndRetrieve";
+        String expectedDesc = "expected description";
+        int expectedMaxAge = 1800;
+        String expectedClientAccessPolicy = "<access-policy><cross-domain-access><policy><allow-from http-request-headers='*'><domain uri='http://*' /></allow-from><grant-to><resource path='/' include-subpaths='false' /></grant-to></policy></cross-domain-access></access-policy>";
+        String expectedCrossDomainPolicy = "<?xml version='1.0'?><!DOCTYPE cross-domain-policy SYSTEM 'http://www.macromedia.com/xml/dtds/cross-domain-policy.dtd'><cross-domain-policy><allow-access-from domain='*' /></cross-domain-policy>";
+        String expectedAkamaiIdentifier = "akamaikey";
+        
+        Calendar cal = Calendar.getInstance();
+        cal.setTime(new Date());
+        cal.add(Calendar.HOUR, 48);
+        Date expectedAkamaiExpiration = cal.getTime();
+        String expectedAkamaiB64 = "/31iWKdqNC7YUnj8zQ3XHA==";
+        String expectedIPAddress = "0.0.0.0";
+        String expectedIPName = "Allow All";
+        
+        CrossSiteAccessPoliciesType expectedCrossSiteAccessPolicies = new CrossSiteAccessPoliciesType();
+        expectedCrossSiteAccessPolicies.setClientAccessPolicy(expectedClientAccessPolicy);
+        expectedCrossSiteAccessPolicies.setCrossDomainPolicy(expectedCrossDomainPolicy);
+        
+        IPAccessControlType expectedIP = new IPAccessControlType();
+        expectedIP.setIpRange(new ArrayList<IPRangeType>());
+        expectedIP.getIpRange().add(new IPRangeType());
+        expectedIP.getIpRange().get(0).setAddress(expectedIPAddress);
+        expectedIP.getIpRange().get(0).setName(expectedIPName);
+        expectedIP.getIpRange().get(0).setSubnetPrefixLength(0);
+        
+        AkamaiAccessControlType expectedAkamai = new AkamaiAccessControlType();
+        List<AkamaiSignatureHeaderAuthenticationKey> akamaiSignatureHeaderAuthenticationKeyList = 
+                new ArrayList<AkamaiSignatureHeaderAuthenticationKey>();
+        akamaiSignatureHeaderAuthenticationKeyList.add(new AkamaiSignatureHeaderAuthenticationKey());
+        akamaiSignatureHeaderAuthenticationKeyList.get(0).setExpiration(expectedAkamaiExpiration);
+        akamaiSignatureHeaderAuthenticationKeyList.get(0).setId(expectedAkamaiIdentifier);
+        akamaiSignatureHeaderAuthenticationKeyList.get(0).setBase64Key(expectedAkamaiB64);
+        expectedAkamai.setAkamaiSignatureHeaderAuthenticationKeyList(akamaiSignatureHeaderAuthenticationKeyList);
+        
+        StreamingEndpointAccessControlType expectedStreamingEndpointAccessControl = new StreamingEndpointAccessControlType();
+        expectedStreamingEndpointAccessControl.setAkamai(expectedAkamai);       
+        expectedStreamingEndpointAccessControl.setIP(expectedIP);
+        
+        StreamingEndpointCacheControlType expectedStreamingEndpointCacheControl = new StreamingEndpointCacheControlType();
+
+        expectedStreamingEndpointCacheControl.setMaxAge(expectedMaxAge );
+        
+        // Act
+        StreamingEndpointInfo streamingEndpointInfo = service.create(
+                        StreamingEndpoint.create()
+                            .setName(expectedName)
+                            .setCdnEnabled(expectedCdnState)
+                            .setDescription(expectedDesc)
+                            .setScaleUnits(expectedScaleUnits)  
+                            .setCrossSiteAccessPolicies(expectedCrossSiteAccessPolicies)
+                            .setAccessControl(expectedStreamingEndpointAccessControl)
+                            .setCacheControl(expectedStreamingEndpointCacheControl )
+                        );
+        
+        OperationState state = OperationUtils.await(service, streamingEndpointInfo);
+        
+        // Act validations
+        assertEquals(OperationState.Succeeded, state);
+        assertNotNull(streamingEndpointInfo);
+        
+        // Retrieve the StramingEndpoint again.
+        StreamingEndpointInfo result = service.get(StreamingEndpoint.get(streamingEndpointInfo.getId()));
+        
+        // Assert
+        assertNotNull(result);        
+        assertEquals(result.getScaleUnits(), expectedScaleUnits);
+        assertEquals(result.getName(), expectedName);
+        assertEquals(result.getDescription(), expectedDesc);
+        assertEquals(result.getCrossSiteAccessPolicies().getClientAccessPolicy(), expectedClientAccessPolicy);
+        assertEquals(result.getCrossSiteAccessPolicies().getCrossDomainPolicy(), expectedCrossDomainPolicy);
+        assertEquals(result.getCacheControl().getMaxAge(), expectedMaxAge);
+        List<AkamaiSignatureHeaderAuthenticationKey> akamai = result.getAccessControl().getAkamai().getAkamaiSignatureHeaderAuthenticationKeyList();
+        assertNotNull(akamai);  
+        assertEquals(akamai.size(), 1);
+        assertEquals(akamai.get(0).getId(), expectedAkamaiIdentifier);
+        assertEquals(akamai.get(0).getExpiration(), expectedAkamaiExpiration);
+        assertEquals(akamai.get(0).getBase64Key(), expectedAkamaiB64);
+        List<IPRangeType> ip = result.getAccessControl().getIP().getIpRange();
+        assertNotNull(ip);
+        assertEquals(ip.size(), 1);
+        assertEquals(ip.get(0).getAddress(), expectedIPAddress);
+        assertEquals(ip.get(0).getName(), expectedIPName);
+        assertEquals(ip.get(0).getSubnetPrefixLength(), 0);
+        
+        // Cleanup
+        String deleteOpId = service.delete(StreamingEndpoint.delete(result.getId()));
+        state = OperationUtils.await(service, deleteOpId);
+        // Assert Cleanup
+        assertEquals(state, OperationState.Succeeded);
+    }
 
 }
-- 
1.9.5.msysgit.1

