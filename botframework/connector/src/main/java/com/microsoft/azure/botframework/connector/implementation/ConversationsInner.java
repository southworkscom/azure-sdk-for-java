/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 */

package com.microsoft.azure.botframework.connector.implementation;

import retrofit2.Retrofit;
import com.google.common.reflect.TypeToken;
import com.microsoft.azure.CloudException;
import com.microsoft.rest.ServiceCallback;
import com.microsoft.rest.ServiceFuture;
import com.microsoft.rest.ServiceResponse;
import com.microsoft.rest.Validator;
import java.io.IOException;
import java.util.List;
import okhttp3.ResponseBody;
import retrofit2.http.Body;
import retrofit2.http.GET;
import retrofit2.http.Header;
import retrofit2.http.Headers;
import retrofit2.http.HTTP;
import retrofit2.http.Path;
import retrofit2.http.POST;
import retrofit2.http.PUT;
import retrofit2.Response;
import rx.functions.Func1;
import rx.Observable;

/**
 * An instance of this class provides access to all the operations defined
 * in Conversations.
 */
public class ConversationsInner {
    /** The Retrofit service to perform REST calls. */
    private ConversationsService service;
    /** The service client containing this operation class. */
    private MicrosoftBotConnectorAPIV30Impl client;

    /**
     * Initializes an instance of ConversationsInner.
     *
     * @param retrofit the Retrofit instance built from a Retrofit Builder.
     * @param client the instance of the service client containing this operation class.
     */
    public ConversationsInner(Retrofit retrofit, MicrosoftBotConnectorAPIV30Impl client) {
        this.service = retrofit.create(ConversationsService.class);
        this.client = client;
    }

    /**
     * The interface defining all the services for Conversations to be
     * used by Retrofit to perform actually REST calls.
     */
    interface ConversationsService {
        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.botframework.connector.Conversations createConversation" })
        @POST("v3/conversations")
        Observable<Response<ResponseBody>> createConversation(@Body ConversationParametersInner parameters, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.botframework.connector.Conversations sendToConversation" })
        @POST("v3/conversations/{conversationId}/activities")
        Observable<Response<ResponseBody>> sendToConversation(@Path("conversationId") String conversationId, @Body ActivityInner activity, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.botframework.connector.Conversations updateActivity" })
        @PUT("v3/conversations/{conversationId}/activities/{activityId}")
        Observable<Response<ResponseBody>> updateActivity(@Path("conversationId") String conversationId, @Path("activityId") String activityId, @Body ActivityInner activity, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.botframework.connector.Conversations replyToActivity" })
        @POST("v3/conversations/{conversationId}/activities/{activityId}")
        Observable<Response<ResponseBody>> replyToActivity(@Path("conversationId") String conversationId, @Path("activityId") String activityId, @Body ActivityInner activity, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.botframework.connector.Conversations deleteActivity" })
        @HTTP(path = "v3/conversations/{conversationId}/activities/{activityId}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deleteActivity(@Path("conversationId") String conversationId, @Path("activityId") String activityId, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.botframework.connector.Conversations getConversationMembers" })
        @GET("v3/conversations/{conversationId}/members")
        Observable<Response<ResponseBody>> getConversationMembers(@Path("conversationId") String conversationId, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.botframework.connector.Conversations getActivityMembers" })
        @GET("v3/conversations/{conversationId}/activities/{activityId}/members")
        Observable<Response<ResponseBody>> getActivityMembers(@Path("conversationId") String conversationId, @Path("activityId") String activityId, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.botframework.connector.Conversations uploadAttachment" })
        @POST("v3/conversations/{conversationId}/attachments")
        Observable<Response<ResponseBody>> uploadAttachment(@Path("conversationId") String conversationId, @Body AttachmentDataInner attachmentUpload, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

    }

    /**
     * CreateConversation.
     * Create a new Conversation.
     POST to this method with a
     * Bot being the bot creating the conversation
     * IsGroup set to true if this is not a direct message (default is false)
     * Members array containing the members you want to have be in the conversation.
     The return value is a ResourceResponse which contains a conversation id which is suitable for use
     in the message payload and REST API uris.
     Most channels only support the semantics of bots initiating a direct message conversation.  An example of how to do that would be:
     ```
     var resource = await connector.conversations.CreateConversation(new ConversationParameters(){ Bot = bot, members = new ChannelAccount[] { new ChannelAccount("user1") } );
     await connect.Conversations.SendToConversationAsync(resource.Id, new Activity() ... ) ;
     ```.
     *
     * @param parameters Parameters to create the conversation from.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object createConversation(ConversationParametersInner parameters) {
        return createConversationWithServiceResponseAsync(parameters).toBlocking().single().body();
    }

    /**
     * CreateConversation.
     * Create a new Conversation.
     POST to this method with a
     * Bot being the bot creating the conversation
     * IsGroup set to true if this is not a direct message (default is false)
     * Members array containing the members you want to have be in the conversation.
     The return value is a ResourceResponse which contains a conversation id which is suitable for use
     in the message payload and REST API uris.
     Most channels only support the semantics of bots initiating a direct message conversation.  An example of how to do that would be:
     ```
     var resource = await connector.conversations.CreateConversation(new ConversationParameters(){ Bot = bot, members = new ChannelAccount[] { new ChannelAccount("user1") } );
     await connect.Conversations.SendToConversationAsync(resource.Id, new Activity() ... ) ;
     ```.
     *
     * @param parameters Parameters to create the conversation from.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> createConversationAsync(ConversationParametersInner parameters, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromResponse(createConversationWithServiceResponseAsync(parameters), serviceCallback);
    }

    /**
     * CreateConversation.
     * Create a new Conversation.
     POST to this method with a
     * Bot being the bot creating the conversation
     * IsGroup set to true if this is not a direct message (default is false)
     * Members array containing the members you want to have be in the conversation.
     The return value is a ResourceResponse which contains a conversation id which is suitable for use
     in the message payload and REST API uris.
     Most channels only support the semantics of bots initiating a direct message conversation.  An example of how to do that would be:
     ```
     var resource = await connector.conversations.CreateConversation(new ConversationParameters(){ Bot = bot, members = new ChannelAccount[] { new ChannelAccount("user1") } );
     await connect.Conversations.SendToConversationAsync(resource.Id, new Activity() ... ) ;
     ```.
     *
     * @param parameters Parameters to create the conversation from.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> createConversationAsync(ConversationParametersInner parameters) {
        return createConversationWithServiceResponseAsync(parameters).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.body();
            }
        });
    }

    /**
     * CreateConversation.
     * Create a new Conversation.
     POST to this method with a
     * Bot being the bot creating the conversation
     * IsGroup set to true if this is not a direct message (default is false)
     * Members array containing the members you want to have be in the conversation.
     The return value is a ResourceResponse which contains a conversation id which is suitable for use
     in the message payload and REST API uris.
     Most channels only support the semantics of bots initiating a direct message conversation.  An example of how to do that would be:
     ```
     var resource = await connector.conversations.CreateConversation(new ConversationParameters(){ Bot = bot, members = new ChannelAccount[] { new ChannelAccount("user1") } );
     await connect.Conversations.SendToConversationAsync(resource.Id, new Activity() ... ) ;
     ```.
     *
     * @param parameters Parameters to create the conversation from.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> createConversationWithServiceResponseAsync(ConversationParametersInner parameters) {
        if (parameters == null) {
            throw new IllegalArgumentException("Parameter parameters is required and cannot be null.");
        }
        Validator.validate(parameters);
        return service.createConversation(parameters, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = createConversationDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> createConversationDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Object, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<ConversationResourceResponseInner>() { }.getType())
                .register(201, new TypeToken<ConversationResourceResponseInner>() { }.getType())
                .register(202, new TypeToken<ConversationResourceResponseInner>() { }.getType())
                .register(400, new TypeToken<ErrorResponseInner>() { }.getType())
                .register(401, new TypeToken<ErrorResponseInner>() { }.getType())
                .register(403, new TypeToken<ErrorResponseInner>() { }.getType())
                .register(404, new TypeToken<ErrorResponseInner>() { }.getType())
                .register(405, new TypeToken<ErrorResponseInner>() { }.getType())
                .register(429, new TypeToken<ErrorResponseInner>() { }.getType())
                .register(500, new TypeToken<ErrorResponseInner>() { }.getType())
                .register(503, new TypeToken<ErrorResponseInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * SendToConversation.
     * This method allows you to send an activity to the end of a conversation.
     This is slightly different from ReplyToActivity.
     * SendToConversation - will append the activity to the end of the conversation according to the timestamp or semantics of the channel.
     * ReplyToActivity - adds the activity as a reply to another activity, if the channel supports it. If the channel does not support nested replies, ReplyToActivity falls back to SendToConversation.
     Use ReplyToActivity when replying to a specific activity in the conversation.
     Use SendToConversation in all other cases.
     *
     * @param conversationId Conversation ID.
     * @param activity Activity to send.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object sendToConversation(String conversationId, ActivityInner activity) {
        return sendToConversationWithServiceResponseAsync(conversationId, activity).toBlocking().single().body();
    }

    /**
     * SendToConversation.
     * This method allows you to send an activity to the end of a conversation.
     This is slightly different from ReplyToActivity.
     * SendToConversation - will append the activity to the end of the conversation according to the timestamp or semantics of the channel.
     * ReplyToActivity - adds the activity as a reply to another activity, if the channel supports it. If the channel does not support nested replies, ReplyToActivity falls back to SendToConversation.
     Use ReplyToActivity when replying to a specific activity in the conversation.
     Use SendToConversation in all other cases.
     *
     * @param conversationId Conversation ID.
     * @param activity Activity to send.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> sendToConversationAsync(String conversationId, ActivityInner activity, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromResponse(sendToConversationWithServiceResponseAsync(conversationId, activity), serviceCallback);
    }

    /**
     * SendToConversation.
     * This method allows you to send an activity to the end of a conversation.
     This is slightly different from ReplyToActivity.
     * SendToConversation - will append the activity to the end of the conversation according to the timestamp or semantics of the channel.
     * ReplyToActivity - adds the activity as a reply to another activity, if the channel supports it. If the channel does not support nested replies, ReplyToActivity falls back to SendToConversation.
     Use ReplyToActivity when replying to a specific activity in the conversation.
     Use SendToConversation in all other cases.
     *
     * @param conversationId Conversation ID.
     * @param activity Activity to send.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> sendToConversationAsync(String conversationId, ActivityInner activity) {
        return sendToConversationWithServiceResponseAsync(conversationId, activity).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.body();
            }
        });
    }

    /**
     * SendToConversation.
     * This method allows you to send an activity to the end of a conversation.
     This is slightly different from ReplyToActivity.
     * SendToConversation - will append the activity to the end of the conversation according to the timestamp or semantics of the channel.
     * ReplyToActivity - adds the activity as a reply to another activity, if the channel supports it. If the channel does not support nested replies, ReplyToActivity falls back to SendToConversation.
     Use ReplyToActivity when replying to a specific activity in the conversation.
     Use SendToConversation in all other cases.
     *
     * @param conversationId Conversation ID.
     * @param activity Activity to send.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> sendToConversationWithServiceResponseAsync(String conversationId, ActivityInner activity) {
        if (conversationId == null) {
            throw new IllegalArgumentException("Parameter conversationId is required and cannot be null.");
        }
        if (activity == null) {
            throw new IllegalArgumentException("Parameter activity is required and cannot be null.");
        }
        Validator.validate(activity);
        return service.sendToConversation(conversationId, activity, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = sendToConversationDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> sendToConversationDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Object, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<ResourceResponseInner>() { }.getType())
                .register(201, new TypeToken<ResourceResponseInner>() { }.getType())
                .register(202, new TypeToken<ResourceResponseInner>() { }.getType())
                .register(400, new TypeToken<ErrorResponseInner>() { }.getType())
                .register(401, new TypeToken<ErrorResponseInner>() { }.getType())
                .register(403, new TypeToken<ErrorResponseInner>() { }.getType())
                .register(404, new TypeToken<ErrorResponseInner>() { }.getType())
                .register(429, new TypeToken<ErrorResponseInner>() { }.getType())
                .register(500, new TypeToken<ErrorResponseInner>() { }.getType())
                .register(503, new TypeToken<ErrorResponseInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * UpdateActivity.
     * Edit an existing activity.
     Some channels allow you to edit an existing activity to reflect the new state of a bot conversation.
     For example, you might remove buttons from a message in the conversation after the user has clicked one of the buttons. If successful, this operation updates the specified activity within the specified conversation.
     *
     * @param conversationId Conversation ID.
     * @param activityId Activity Id to update.
     * @param activity replacement Activity.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object updateActivity(String conversationId, String activityId, ActivityInner activity) {
        return updateActivityWithServiceResponseAsync(conversationId, activityId, activity).toBlocking().single().body();
    }

    /**
     * UpdateActivity.
     * Edit an existing activity.
     Some channels allow you to edit an existing activity to reflect the new state of a bot conversation.
     For example, you might remove buttons from a message in the conversation after the user has clicked one of the buttons. If successful, this operation updates the specified activity within the specified conversation.
     *
     * @param conversationId Conversation ID.
     * @param activityId Activity Id to update.
     * @param activity replacement Activity.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> updateActivityAsync(String conversationId, String activityId, ActivityInner activity, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromResponse(updateActivityWithServiceResponseAsync(conversationId, activityId, activity), serviceCallback);
    }

    /**
     * UpdateActivity.
     * Edit an existing activity.
     Some channels allow you to edit an existing activity to reflect the new state of a bot conversation.
     For example, you might remove buttons from a message in the conversation after the user has clicked one of the buttons. If successful, this operation updates the specified activity within the specified conversation.
     *
     * @param conversationId Conversation ID.
     * @param activityId Activity Id to update.
     * @param activity replacement Activity.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> updateActivityAsync(String conversationId, String activityId, ActivityInner activity) {
        return updateActivityWithServiceResponseAsync(conversationId, activityId, activity).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.body();
            }
        });
    }

    /**
     * UpdateActivity.
     * Edit an existing activity.
     Some channels allow you to edit an existing activity to reflect the new state of a bot conversation.
     For example, you might remove buttons from a message in the conversation after the user has clicked one of the buttons. If successful, this operation updates the specified activity within the specified conversation.
     *
     * @param conversationId Conversation ID.
     * @param activityId Activity Id to update.
     * @param activity replacement Activity.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> updateActivityWithServiceResponseAsync(String conversationId, String activityId, ActivityInner activity) {
        if (conversationId == null) {
            throw new IllegalArgumentException("Parameter conversationId is required and cannot be null.");
        }
        if (activityId == null) {
            throw new IllegalArgumentException("Parameter activityId is required and cannot be null.");
        }
        if (activity == null) {
            throw new IllegalArgumentException("Parameter activity is required and cannot be null.");
        }
        Validator.validate(activity);
        return service.updateActivity(conversationId, activityId, activity, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = updateActivityDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> updateActivityDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Object, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<ResourceResponseInner>() { }.getType())
                .register(201, new TypeToken<ResourceResponseInner>() { }.getType())
                .register(202, new TypeToken<ResourceResponseInner>() { }.getType())
                .register(400, new TypeToken<ErrorResponseInner>() { }.getType())
                .register(401, new TypeToken<ErrorResponseInner>() { }.getType())
                .register(403, new TypeToken<ErrorResponseInner>() { }.getType())
                .register(404, new TypeToken<ErrorResponseInner>() { }.getType())
                .register(405, new TypeToken<ErrorResponseInner>() { }.getType())
                .register(429, new TypeToken<ErrorResponseInner>() { }.getType())
                .register(500, new TypeToken<ErrorResponseInner>() { }.getType())
                .register(503, new TypeToken<ErrorResponseInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * ReplyToActivity.
     * This method allows you to reply to an activity.
     This is slightly different from SendToConversation().
     * SendToConversation - will append the activity to the end of the conversation according to the timestamp or semantics of the channel.
     * ReplyToActivity - adds the activity as a reply to another activity, if the channel supports it. If the channel does not support nested replies, ReplyToActivity falls back to SendToConversation.
     Use ReplyToActivity when replying to a specific activity in the conversation.
     Use SendToConversation in all other cases.
     *
     * @param conversationId Conversation ID.
     * @param activityId ID of the activity.
     * @param activity Activity to send.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object replyToActivity(String conversationId, String activityId, ActivityInner activity) {
        return replyToActivityWithServiceResponseAsync(conversationId, activityId, activity).toBlocking().single().body();
    }

    /**
     * ReplyToActivity.
     * This method allows you to reply to an activity.
     This is slightly different from SendToConversation().
     * SendToConversation - will append the activity to the end of the conversation according to the timestamp or semantics of the channel.
     * ReplyToActivity - adds the activity as a reply to another activity, if the channel supports it. If the channel does not support nested replies, ReplyToActivity falls back to SendToConversation.
     Use ReplyToActivity when replying to a specific activity in the conversation.
     Use SendToConversation in all other cases.
     *
     * @param conversationId Conversation ID.
     * @param activityId ID of the activity.
     * @param activity Activity to send.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> replyToActivityAsync(String conversationId, String activityId, ActivityInner activity, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromResponse(replyToActivityWithServiceResponseAsync(conversationId, activityId, activity), serviceCallback);
    }

    /**
     * ReplyToActivity.
     * This method allows you to reply to an activity.
     This is slightly different from SendToConversation().
     * SendToConversation - will append the activity to the end of the conversation according to the timestamp or semantics of the channel.
     * ReplyToActivity - adds the activity as a reply to another activity, if the channel supports it. If the channel does not support nested replies, ReplyToActivity falls back to SendToConversation.
     Use ReplyToActivity when replying to a specific activity in the conversation.
     Use SendToConversation in all other cases.
     *
     * @param conversationId Conversation ID.
     * @param activityId ID of the activity.
     * @param activity Activity to send.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> replyToActivityAsync(String conversationId, String activityId, ActivityInner activity) {
        return replyToActivityWithServiceResponseAsync(conversationId, activityId, activity).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.body();
            }
        });
    }

    /**
     * ReplyToActivity.
     * This method allows you to reply to an activity.
     This is slightly different from SendToConversation().
     * SendToConversation - will append the activity to the end of the conversation according to the timestamp or semantics of the channel.
     * ReplyToActivity - adds the activity as a reply to another activity, if the channel supports it. If the channel does not support nested replies, ReplyToActivity falls back to SendToConversation.
     Use ReplyToActivity when replying to a specific activity in the conversation.
     Use SendToConversation in all other cases.
     *
     * @param conversationId Conversation ID.
     * @param activityId ID of the activity.
     * @param activity Activity to send.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> replyToActivityWithServiceResponseAsync(String conversationId, String activityId, ActivityInner activity) {
        if (conversationId == null) {
            throw new IllegalArgumentException("Parameter conversationId is required and cannot be null.");
        }
        if (activityId == null) {
            throw new IllegalArgumentException("Parameter activityId is required and cannot be null.");
        }
        if (activity == null) {
            throw new IllegalArgumentException("Parameter activity is required and cannot be null.");
        }
        Validator.validate(activity);
        return service.replyToActivity(conversationId, activityId, activity, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = replyToActivityDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> replyToActivityDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Object, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<ResourceResponseInner>() { }.getType())
                .register(201, new TypeToken<ResourceResponseInner>() { }.getType())
                .register(202, new TypeToken<ResourceResponseInner>() { }.getType())
                .register(400, new TypeToken<ErrorResponseInner>() { }.getType())
                .register(401, new TypeToken<ErrorResponseInner>() { }.getType())
                .register(403, new TypeToken<ErrorResponseInner>() { }.getType())
                .register(404, new TypeToken<ErrorResponseInner>() { }.getType())
                .register(429, new TypeToken<ErrorResponseInner>() { }.getType())
                .register(500, new TypeToken<ErrorResponseInner>() { }.getType())
                .register(503, new TypeToken<ErrorResponseInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * DeleteActivity.
     * Delete an existing activity.
     Some channels allow you to delete an existing activity. If successful, this operation removes the specified activity from the specified conversation.
     *
     * @param conversationId Conversation ID.
     * @param activityId ID of activity to delete.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ErrorResponseInner object if successful.
     */
    public ErrorResponseInner deleteActivity(String conversationId, String activityId) {
        return deleteActivityWithServiceResponseAsync(conversationId, activityId).toBlocking().single().body();
    }

    /**
     * DeleteActivity.
     * Delete an existing activity.
     Some channels allow you to delete an existing activity. If successful, this operation removes the specified activity from the specified conversation.
     *
     * @param conversationId Conversation ID.
     * @param activityId ID of activity to delete.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ErrorResponseInner> deleteActivityAsync(String conversationId, String activityId, final ServiceCallback<ErrorResponseInner> serviceCallback) {
        return ServiceFuture.fromResponse(deleteActivityWithServiceResponseAsync(conversationId, activityId), serviceCallback);
    }

    /**
     * DeleteActivity.
     * Delete an existing activity.
     Some channels allow you to delete an existing activity. If successful, this operation removes the specified activity from the specified conversation.
     *
     * @param conversationId Conversation ID.
     * @param activityId ID of activity to delete.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ErrorResponseInner object
     */
    public Observable<ErrorResponseInner> deleteActivityAsync(String conversationId, String activityId) {
        return deleteActivityWithServiceResponseAsync(conversationId, activityId).map(new Func1<ServiceResponse<ErrorResponseInner>, ErrorResponseInner>() {
            @Override
            public ErrorResponseInner call(ServiceResponse<ErrorResponseInner> response) {
                return response.body();
            }
        });
    }

    /**
     * DeleteActivity.
     * Delete an existing activity.
     Some channels allow you to delete an existing activity. If successful, this operation removes the specified activity from the specified conversation.
     *
     * @param conversationId Conversation ID.
     * @param activityId ID of activity to delete.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ErrorResponseInner object
     */
    public Observable<ServiceResponse<ErrorResponseInner>> deleteActivityWithServiceResponseAsync(String conversationId, String activityId) {
        if (conversationId == null) {
            throw new IllegalArgumentException("Parameter conversationId is required and cannot be null.");
        }
        if (activityId == null) {
            throw new IllegalArgumentException("Parameter activityId is required and cannot be null.");
        }
        return service.deleteActivity(conversationId, activityId, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ErrorResponseInner>>>() {
                @Override
                public Observable<ServiceResponse<ErrorResponseInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ErrorResponseInner> clientResponse = deleteActivityDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<ErrorResponseInner> deleteActivityDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<ErrorResponseInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .register(202, new TypeToken<Void>() { }.getType())
                .register(400, new TypeToken<ErrorResponseInner>() { }.getType())
                .register(401, new TypeToken<ErrorResponseInner>() { }.getType())
                .register(403, new TypeToken<ErrorResponseInner>() { }.getType())
                .register(404, new TypeToken<ErrorResponseInner>() { }.getType())
                .register(405, new TypeToken<ErrorResponseInner>() { }.getType())
                .register(429, new TypeToken<ErrorResponseInner>() { }.getType())
                .register(500, new TypeToken<ErrorResponseInner>() { }.getType())
                .register(503, new TypeToken<ErrorResponseInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * GetConversationMembers.
     * Enumerate the members of a conversation.
     This REST API takes a Conversation ID and returns an array of ChannelAccount objects representing the members of the conversation.
     *
     * @param conversationId Conversation ID.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object getConversationMembers(String conversationId) {
        return getConversationMembersWithServiceResponseAsync(conversationId).toBlocking().single().body();
    }

    /**
     * GetConversationMembers.
     * Enumerate the members of a conversation.
     This REST API takes a Conversation ID and returns an array of ChannelAccount objects representing the members of the conversation.
     *
     * @param conversationId Conversation ID.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> getConversationMembersAsync(String conversationId, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromResponse(getConversationMembersWithServiceResponseAsync(conversationId), serviceCallback);
    }

    /**
     * GetConversationMembers.
     * Enumerate the members of a conversation.
     This REST API takes a Conversation ID and returns an array of ChannelAccount objects representing the members of the conversation.
     *
     * @param conversationId Conversation ID.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> getConversationMembersAsync(String conversationId) {
        return getConversationMembersWithServiceResponseAsync(conversationId).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.body();
            }
        });
    }

    /**
     * GetConversationMembers.
     * Enumerate the members of a conversation.
     This REST API takes a Conversation ID and returns an array of ChannelAccount objects representing the members of the conversation.
     *
     * @param conversationId Conversation ID.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> getConversationMembersWithServiceResponseAsync(String conversationId) {
        if (conversationId == null) {
            throw new IllegalArgumentException("Parameter conversationId is required and cannot be null.");
        }
        return service.getConversationMembers(conversationId, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = getConversationMembersDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> getConversationMembersDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Object, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<List<ChannelAccountInner>>() { }.getType())
                .register(400, new TypeToken<ErrorResponseInner>() { }.getType())
                .register(401, new TypeToken<ErrorResponseInner>() { }.getType())
                .register(403, new TypeToken<ErrorResponseInner>() { }.getType())
                .register(404, new TypeToken<ErrorResponseInner>() { }.getType())
                .register(405, new TypeToken<ErrorResponseInner>() { }.getType())
                .register(429, new TypeToken<ErrorResponseInner>() { }.getType())
                .register(500, new TypeToken<ErrorResponseInner>() { }.getType())
                .register(503, new TypeToken<ErrorResponseInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * GetActivityMembers.
     * Enumerate the members of an activity.
     This REST API takes a Conversation ID and an Activity ID, returning an array of ChannelAccount objects representing the members of the particular activity in the conversation.
     *
     * @param conversationId Conversation ID.
     * @param activityId Activity ID.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object getActivityMembers(String conversationId, String activityId) {
        return getActivityMembersWithServiceResponseAsync(conversationId, activityId).toBlocking().single().body();
    }

    /**
     * GetActivityMembers.
     * Enumerate the members of an activity.
     This REST API takes a Conversation ID and an Activity ID, returning an array of ChannelAccount objects representing the members of the particular activity in the conversation.
     *
     * @param conversationId Conversation ID.
     * @param activityId Activity ID.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> getActivityMembersAsync(String conversationId, String activityId, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromResponse(getActivityMembersWithServiceResponseAsync(conversationId, activityId), serviceCallback);
    }

    /**
     * GetActivityMembers.
     * Enumerate the members of an activity.
     This REST API takes a Conversation ID and an Activity ID, returning an array of ChannelAccount objects representing the members of the particular activity in the conversation.
     *
     * @param conversationId Conversation ID.
     * @param activityId Activity ID.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> getActivityMembersAsync(String conversationId, String activityId) {
        return getActivityMembersWithServiceResponseAsync(conversationId, activityId).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.body();
            }
        });
    }

    /**
     * GetActivityMembers.
     * Enumerate the members of an activity.
     This REST API takes a Conversation ID and an Activity ID, returning an array of ChannelAccount objects representing the members of the particular activity in the conversation.
     *
     * @param conversationId Conversation ID.
     * @param activityId Activity ID.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> getActivityMembersWithServiceResponseAsync(String conversationId, String activityId) {
        if (conversationId == null) {
            throw new IllegalArgumentException("Parameter conversationId is required and cannot be null.");
        }
        if (activityId == null) {
            throw new IllegalArgumentException("Parameter activityId is required and cannot be null.");
        }
        return service.getActivityMembers(conversationId, activityId, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = getActivityMembersDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> getActivityMembersDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Object, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<List<ChannelAccountInner>>() { }.getType())
                .register(400, new TypeToken<ErrorResponseInner>() { }.getType())
                .register(401, new TypeToken<ErrorResponseInner>() { }.getType())
                .register(403, new TypeToken<ErrorResponseInner>() { }.getType())
                .register(404, new TypeToken<ErrorResponseInner>() { }.getType())
                .register(405, new TypeToken<ErrorResponseInner>() { }.getType())
                .register(429, new TypeToken<ErrorResponseInner>() { }.getType())
                .register(500, new TypeToken<ErrorResponseInner>() { }.getType())
                .register(503, new TypeToken<ErrorResponseInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * UploadAttachment.
     * Upload an attachment directly into a channel's blob storage.
     This is useful because it allows you to store data in a compliant store when dealing with enterprises.
     The response is a ResourceResponse which contains an Attachment ID which is suitable for using with the attachments API.
     *
     * @param conversationId Conversation ID.
     * @param attachmentUpload Attachment data.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object uploadAttachment(String conversationId, AttachmentDataInner attachmentUpload) {
        return uploadAttachmentWithServiceResponseAsync(conversationId, attachmentUpload).toBlocking().single().body();
    }

    /**
     * UploadAttachment.
     * Upload an attachment directly into a channel's blob storage.
     This is useful because it allows you to store data in a compliant store when dealing with enterprises.
     The response is a ResourceResponse which contains an Attachment ID which is suitable for using with the attachments API.
     *
     * @param conversationId Conversation ID.
     * @param attachmentUpload Attachment data.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> uploadAttachmentAsync(String conversationId, AttachmentDataInner attachmentUpload, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromResponse(uploadAttachmentWithServiceResponseAsync(conversationId, attachmentUpload), serviceCallback);
    }

    /**
     * UploadAttachment.
     * Upload an attachment directly into a channel's blob storage.
     This is useful because it allows you to store data in a compliant store when dealing with enterprises.
     The response is a ResourceResponse which contains an Attachment ID which is suitable for using with the attachments API.
     *
     * @param conversationId Conversation ID.
     * @param attachmentUpload Attachment data.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> uploadAttachmentAsync(String conversationId, AttachmentDataInner attachmentUpload) {
        return uploadAttachmentWithServiceResponseAsync(conversationId, attachmentUpload).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.body();
            }
        });
    }

    /**
     * UploadAttachment.
     * Upload an attachment directly into a channel's blob storage.
     This is useful because it allows you to store data in a compliant store when dealing with enterprises.
     The response is a ResourceResponse which contains an Attachment ID which is suitable for using with the attachments API.
     *
     * @param conversationId Conversation ID.
     * @param attachmentUpload Attachment data.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> uploadAttachmentWithServiceResponseAsync(String conversationId, AttachmentDataInner attachmentUpload) {
        if (conversationId == null) {
            throw new IllegalArgumentException("Parameter conversationId is required and cannot be null.");
        }
        if (attachmentUpload == null) {
            throw new IllegalArgumentException("Parameter attachmentUpload is required and cannot be null.");
        }
        Validator.validate(attachmentUpload);
        return service.uploadAttachment(conversationId, attachmentUpload, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = uploadAttachmentDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> uploadAttachmentDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Object, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<ResourceResponseInner>() { }.getType())
                .register(201, new TypeToken<ResourceResponseInner>() { }.getType())
                .register(202, new TypeToken<ResourceResponseInner>() { }.getType())
                .register(400, new TypeToken<ErrorResponseInner>() { }.getType())
                .register(401, new TypeToken<ErrorResponseInner>() { }.getType())
                .register(403, new TypeToken<ErrorResponseInner>() { }.getType())
                .register(404, new TypeToken<ErrorResponseInner>() { }.getType())
                .register(405, new TypeToken<ErrorResponseInner>() { }.getType())
                .register(429, new TypeToken<ErrorResponseInner>() { }.getType())
                .register(500, new TypeToken<ErrorResponseInner>() { }.getType())
                .register(503, new TypeToken<ErrorResponseInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

}
